<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud快速开发入门第02篇]]></title>
    <url>%2F2019%2F12%2F12%2FSpring%20Cloud%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%AC%AC02%E7%AF%87%2F</url>
    <content type="text"><![CDATA[0.学习目标 会配置Hystix熔断 会使用Feign进行远程调用 能独立搭建Zuul网关 能编写Zuul的过滤器 1.Hystrix1.1.简介Hystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。 Hystrix也是Netflix公司的一款组件。 主页：https://github.com/Netflix/Hystrix/ 那么Hystix的作用是什么呢？具体要保护什么呢？ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.2.雪崩问题微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路： 如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。 如果此时，某个服务出现异常： 例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。 这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。 此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 Hystix解决雪崩问题的手段有两个： 线程隔离 服务熔断 1.3.线程隔离，服务降级1.3.1.原理线程隔离示意图： 解读： Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。 用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，或者请求超时，则会进行降级处理，什么是服务降级？ 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。 用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。 服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。 触发Hystix服务降级的情况： 线程池已满 请求超时 1.3.2.动手实践1.3.2.1.引入依赖首先在itcast-service-consumer的pom.xml中引入Hystrix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.2.开启熔断 可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication 因此，我们可以使用这个组合注解来代替之前的3个注解。 12345678910111213@SpringCloudApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 1.3.2.3.编写降级逻辑我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成： 12345678910111213141516171819@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand(fallbackMethod = "queryUserByIdFallBack") public String queryUserById(@RequestParam("id") Long id) &#123; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user; &#125; public String queryUserByIdFallBack(Long id)&#123; return "请求繁忙，请稍后再试！"; &#125;&#125; 要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。 说明： @HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法 测试： 当itcast-service-provder正常提供服务时，访问与以前一致。但是当我们将itcast-service-provider停机时，会发现页面返回了降级处理信息： 1.3.2.4.默认FallBack我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback： 1234567891011121314151617181920212223242526@Controller@RequestMapping("consumer/user")@DefaultProperties(defaultFallback = "fallBackMethod") // 指定一个类的全局熔断方法public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand // 标记该方法需要熔断 public String queryUserById(@RequestParam("id") Long id) &#123; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user; &#125; /** * 熔断方法 * 返回值要和被熔断的方法的返回值一致 * 熔断方法不需要参数 * @return */ public String fallBackMethod()&#123; return "请求繁忙，请稍后再试！"; &#125;&#125; @DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的失败降级方法 @HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法。 defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致 1.3.2.5.设置超时在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值： 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。该配置没有提示。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms 改造服务提供者 改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断： 123456789@GetMapping("&#123;id&#125;")public User queryUserById(@PathVariable("id") Long id) &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return this.userService.queryUserById(id);&#125; 1.4.服务熔断1.4.1.熔断原理熔断器，也叫断路器，其英文单词为：Circuit Breaker 熔断状态机3个状态： Closed：关闭状态，所有请求都正常访问。 Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。 Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时 1.4.2.动手实践为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑： 123456789@GetMapping("&#123;id&#125;")@HystrixCommandpublic String queryUserById(@PathVariable("id") Long id)&#123; if(id == 1)&#123; throw new RuntimeException("太忙了"); &#125; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user;&#125; 这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑） 我们准备两个请求窗口： 一个请求：http://localhost/consumer/user/1，注定失败 一个请求：http://localhost/consumer/user/2，肯定成功 当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。 此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右： 不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略： 123circuitBreaker.requestVolumeThreshold=10circuitBreaker.sleepWindowInMilliseconds=10000circuitBreaker.errorThresholdPercentage=50 解读： requestVolumeThreshold：触发熔断的最小请求次数，默认20 errorThresholdPercentage：触发熔断的失败请求最小占比，默认50% sleepWindowInMilliseconds：休眠时长，默认是5000毫秒 2.Feign在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 1String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 2.1.简介有道词典的英文解释： 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 2.2.快速入门改造itcast-service-consumer工程 2.2.1.导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.2.开启Feign功能我们在启动类上，添加注解，开启Feign功能 12345678@SpringCloudApplication@EnableFeignClients // 开启feign客户端public class ItcastServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 删除RestTemplate：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。 2.2.3.Feign的客户端在itcast-service-consumer工程中，添加UserClient接口： 内容： 123456@FeignClient(value = "service-provider") // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping("user/&#123;id&#125;") User queryById(@PathVariable("id") Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，调用UserClient接口： 123456789101112131415@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private UserClient userClient; @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; User user = this.userClient.queryUserById(id); return user; &#125;&#125; 2.2.4.启动测试访问接口： 正常获取到了结果。 2.3.负载均衡Feign中本身已经集成了Ribbon依赖和自动配置： 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 2.4.Hystrix支持Feign默认也有对Hystrix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在itcast-service-consumer工程添加配置内容) 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像hystrix中那样简单了。 1）首先，我们要定义一个类UserClientFallback，实现刚才编写的UserClient，作为fallback的处理类 12345678910@Componentpublic class UserClientFallback implements UserClient &#123; @Override public User queryById(Long id) &#123; User user = new User(); user.setUserName("服务器繁忙，请稍后再试！"); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = "service-provider", fallback = UserClientFallback.class) // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping("user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 3）重启测试： 2.5.请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 2.6.日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: cn.itcast: debug 2）编写配置类，定义日志级别 内容： 12345678@Configurationpublic class FeignLogConfiguration &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = "service-privider", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 4）重启项目，即可看到每次访问的日志： 3.Zuul网关通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 3.1.简介官网：https://github.com/Netflix/zuul Zuul：维基百科 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ 3.2.Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 3.3.快速入门3.3.1.新建工程填写基本信息： 添加Zuul依赖： 3.3.2.编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 3.3.3.编写引导类通过@EnableZuulProxy注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启网关功能public class ItcastZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastZuulApplication.class, args); &#125;&#125; 3.3.4.编写路由规则我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345678910server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名zuul: routes: service-provider: # 这里是路由id，随意写 path: /service-provider/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /service-provider/**开头的请求，代理到http://127.0.0.1:8081 3.3.5.启动测试访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:10010/service-provider/user/1 3.4.面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 对itcast-zuul工程修改优化： 3.4.1.添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.添加Eureka配置，获取服务信息12345eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka 3.4.3.开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.4.4.修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: service-provider: # 这里是路由id，随意写 path: /service-provider/** # 这里是映射路径 serviceId: service-provider # 指定服务名称 3.4.5.启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 3.5.简化的路由配置在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=service-provider：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于service-provider的配置可以简化为一条： 123zuul: routes: service-provider: /service-provider/** # 这里是映射路径 省去了对服务名称的配置。 3.6.默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：service-provider，则默认的映射路径就 是：/service-provider/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 3.7.路由前缀配置示例： 12345zuul: routes: service-provider: /service-provider/** service-consumer: /service-consumer/** prefix: /api # 添加路由前缀 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 3.8.过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 3.8.1.ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 route：在路由请求时调用 post：在route和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 3.8.2.过滤器执行生命周期这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 正常流程： 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。 所有内置过滤器列表： 3.8.3.使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 3.9.自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 3.9.1.定义过滤器类 内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Componentpublic class LoginFilter extends ZuulFilter &#123; /** * 过滤器类型，前置过滤器 * @return */ @Override public String filterType() &#123; return "pre"; &#125; /** * 过滤器的执行顺序 * @return */ @Override public int filterOrder() &#123; return 1; &#125; /** * 该过滤器是否生效 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 登陆校验逻辑 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; // 获取zuul提供的上下文对象 RequestContext context = RequestContext.getCurrentContext(); // 从上下文对象中获取请求对象 HttpServletRequest request = context.getRequest(); // 获取token信息 String token = request.getParameter("access-token"); // 判断 if (StringUtils.isBlank(token)) &#123; // 过滤该请求，不对其进行路由 context.setSendZuulResponse(false); // 设置响应状态码，401 context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); // 设置响应信息 context.setResponseBody("&#123;\"status\":\"401\", \"text\":\"request error!\"&#125;"); &#125; // 校验通过，把登陆信息放入上下文信息，继续向后执行 context.set("token", token); return null; &#125;&#125; 3.9.2.测试没有token参数时，访问失败： 添加token参数后： 3.10.负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms]]></content>
      <categories>
        <category>Spring Cloud</category>
        <category>微服务框架</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud快速开发入门第01篇]]></title>
    <url>%2F2019%2F12%2F11%2FSpring%20Cloud%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%AC%AC01%E7%AF%87%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解系统架构的演变 了解RPC与Http的区别 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1.集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4.流动计算架构（SOA）SOA ：面向服务的架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 2.服务调用方式2.1.RPC和HTTP无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下2种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 现在热门的Rest风格，就可以通过http协议来实现。 如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。 相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。 2.2.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，不过这些不同的客户端，API各不相同 2.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 我们导入课前资料提供的demo工程： 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; // 调用springboot案例中的rest接口 User user = this.restTemplate.getForObject("http://localhost/user/1", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 3.初识SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 3.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） Zuul：网关组件，提供智能路由，访问过滤功能 Ribbon：客户端负载均衡的服务调用组件（客户端负载） Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) 架构图： 以上只是其中一部分。 3.2.版本因为Spring Cloud不同其他独立项目，它拥有很多子项目的大项目。所以它的版本是版本名+版本号 （如Angel.SR6）。 版本名：是伦敦的地铁名 版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 所以 Edgware.SR3就是Edgware的第3个Release版本。 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 4.微服务场景模拟首先，我们需要模拟一个服务调用的场景，搭建两个工程：itcast-service-provider（服务提供方）和itcast-service-consumer（服务调用方）。方便后面学习微服务架构 服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。 服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。 4.1.服务提供者我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。 4.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具： next—&gt;填写项目信息： next —&gt; 添加web依赖： 添加mybatis依赖： Next —&gt; 填写项目位置： 生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）： 依赖也已经全部自动引入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 非常快捷啊！ 4.1.2.编写代码 4.1.2.1.配置属性文件,这里我们采用了yaml语法，而不是properties： 123456789server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mybatis #你学习mybatis时，使用的数据库地址 username: root password: rootmybatis: type-aliases-package: cn.itcast.service.pojo 4.1.2.2.实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; public Date getUpdated() &#123; return updated; &#125; public void setUpdated(Date updated) &#123; this.updated = updated; &#125;&#125; 4.1.2.3.UserMapper123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 4.1.2.4.UserService12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 4.1.2.5.UserController添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; 4.1.3.启动并测试启动项目，访问接口：http://localhost:8081/user/1 4.2.服务调用者搭建itcast-service-consumer服务消费方工程。 4.2.1.创建工程与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。 pom： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.2.2.编写代码 首先在引导类中注册RestTemplate： 123456789101112@SpringBootApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 编写配置（application.yml）： 12server: port: 80 编写UserController： 123456789101112131415@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; User user = this.restTemplate.getForObject("http://localhost:8081/user/" + id, User.class); return user; &#125;&#125; pojo对象（User）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; public Date getUpdated() &#123; return updated; &#125; public void setUpdated(Date updated) &#123; this.updated = updated; &#125;&#125; 4.2.3.启动测试因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost/consumer/user?id=1 一个简单的远程服务调用案例就实现了。 4.3.有没有问题？简单回顾一下，刚才我们写了什么： itcast-service-provider：一个提供根据id查询用户的微服务。 itcast-service-consumer：一个服务调用者，通过RestTemplate远程调用itcast-service-provider。 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚provider的状态，服务宕机也不知道 provider只有1台服务，不具备高可用性 即便provider形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 5.Eureka注册中心5.1.认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，itcast-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 5.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 5.3.入门案例5.3.1.搭建EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。因为，对于eureka来说：服务提供方和服务消费方都属于客户端 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.eureka&lt;/groupId&gt; &lt;artifactId&gt;itcast-eureka&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写application.yml配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 修改引导类，在类上添加@EnableEurekaServer注解： 12345678@SpringBootApplication@EnableEurekaServer // 声明当前springboot应用是一个eureka服务中心public class ItcastEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastEurekaApplication.class, args); &#125;&#125; 启动服务，并访问：http://127.0.0.1:10086 5.3.2.注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 修改itcast-service-provider工程 在pom.xml中，添加springcloud的相关依赖。 在application.yml中，添加springcloud的相关依赖。 在引导类上添加注解，把服务注入到eureka注册中心。 具体操作 5.3.2.1.pom.xml参照itcast-eureka，先添加SpringCloud依赖： 123456789101112&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 完整pom.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 5.3.2.2.application.yml12345678910111213141516server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/heima username: root password: root driverClassName: com.mysql.jdbc.Driver application: name: service-provider # 应用名称，注册到eureka后的服务名称mybatis: type-aliases-package: cn.itcast.service.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 5.3.2.3.引导类在引导类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 12345678@SpringBootApplication@EnableDiscoveryClientpublic class ItcastServiceProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceApplication.class, args); &#125;&#125; 重启项目，访问Eureka监控页面查看 我们发现service-provider服务已经注册成功了 5.3.3.从Eureka获取服务接下来我们修改itcast-service-consumer，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- SpringCloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 修改配置 123456789server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://localhost:10086/eureka 在启动类开启Eureka客户端 12345678910111213@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 修改UserController代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 123456789101112131415161718192021222324@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; // eureka客户端，可以获取到eureka中服务的信息 @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("service-provider"); // 因为只有一个Service-provider。所以获取第一个实例 ServiceInstance instance = instances.get(0); // 获取ip和端口信息，拼接成服务地址 String baseUrl = "http://" + instance.getHost() + ":" + instance.getPort() + "/user/" + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： 5.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。 5.4.1.基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的itcast-eureka。 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的itcast-service-provider。 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的itcast-service-consumer。 5.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把itcast-eureka启动两次即可。 1）启动第一个eurekaServer，我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 启动报错，很正常。因为10087服务没有启动： 2）启动第二个eurekaServer，再次修改itcast-eureka的配置： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）访问集群，测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 10086： 10087： 5.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-eureka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。 第一层Map的Key就是服务id，一般是配置中的spring.application.name属性 第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：locahost:service-provider:8081 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 5.4.4.服务消费者 获取服务列表 当服务消费者启动时，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 5.4.5.失效剔除和自我保护 服务下线 当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生产环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka） 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 6.负载均衡Ribbon在刚才的案例中，我们启动了一个itcast-service-provider，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个itcast-service-provider的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 6.1.启动两个服务实例首先参照itcast-eureka启动两个ItcastServiceProviderApplication实例，一个8081，一个8082。 Eureka监控面板： 6.2.开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。 修改itcast-service-consumer的引导类，在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 123456789101112131415161718192021@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; //@Autowired //private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表 @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; // 通过client获取服务提供方的服务列表，这里我们只有一个 // ServiceInstance instance = discoveryClient.getInstances("service-provider").get(0); String baseUrl = "http://service-provider/user/" + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; 访问页面，查看结果： 完美！ 6.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 在如下代码打断点： 一路源码跟踪：RestTemplate.getForObject —&gt; RestTemplate.execute —&gt; RestTemplate.doExecute： 点击进入AbstractClientHttpRequest.execute —&gt; AbstractBufferingClientHttpRequest.executeInternal —&gt; InterceptingClientHttpRequest.executeInternal —&gt; InterceptingClientHttpRequest.execute: 继续跟入：LoadBalancerInterceptor.intercept方法 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 6.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们注入这个类的对象，然后对其测试： 测试内容： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastServiceConsumerApplication.class)public class LoadBalanceTest &#123; @Autowired private RibbonLoadBalancerClient client; @Test public void testLoadBalance()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("service-provider"); System.out.println(instance.getHost() + ":" +instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口，在itcast-service-consumer的application.yml中添加如下配置： 123456789101112server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekaservice-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机：]]></content>
      <categories>
        <category>Spring Cloud</category>
        <category>微服务框架</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot快速开发入门]]></title>
    <url>%2F2019%2F12%2F11%2FSpring%20Boot%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. 翻译一下： Spring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。 我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。 其实人们把Spring Boot称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点： 复杂的配置 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 混乱的依赖管理 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ 1.3.SpringBoot的特点Spring Boot 主要特征是： 创建独立的spring应用程序 直接内嵌tomcat、jetty和undertow（不需要打包成war包部署） 提供了固定化的“starter”配置，以简化构建配置 尽可能的自动配置spring和第三方库 提供产品级的功能，如：安全指标、运行状况监测和外部化配置等 绝对不会生成代码，并且不需要XML配置 总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的入门体验 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 环境要求： 2.1.创建工程我们先新建一个空的demo工程，如下： 创建以moduel： 填写坐标信息： 目录结构： 创建完成后的目录结构： 2.2.引入依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.springboot&lt;/groupId&gt; &lt;artifactId&gt;itcast-springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.编写HelloController 代码： 12345678910111213@RestController@EnableAutoConfigurationpublic class HelloController &#123; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloController.class, args); &#125;&#125; 2.4.启动测试 bingo！访问成功！ 2.5.详解入门工程中：pom.xml里引入了启动器的概念以@EnableAutoConfiguration注解。 2.5.1.启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.5.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. 简单翻译以下： 开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。 2.6.优化入门程序现在工程中只有一个Controller，可以这么玩；那么如果有多个Controller，怎么办呢？ 添加Hello2Controller： 代码： 123456789@RestControllerpublic class Hello2Controller &#123; @GetMapping("show2") public String test()&#123; return "hello Spring Boot2!"; &#125;&#125; 启动重新启动，访问show2测试，失败： 难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。 所以，springboot程序引入了一个全局的引导类。 2.5.1.添加引导类通常请求下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。 在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class： 内容如下： 1234567@EnableAutoConfigurationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 并修改HelloController，去掉main方法及@EnableAutoConfiguration： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125;&#125; 启动引导类，访问show测试： 发现所有的Controller都不能访问，为什么？ 回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——@ComponentScan注解 2.5.2.@ComponentScanspring框架除了提供配置方式的注解扫描&lt;context:component-scan /&gt;，还提供了注解方式的注解扫描@ComponentScan。 在TestApplication.class中，使用@ComponentScan注解： 123456789@EnableAutoConfiguration@ComponentScanpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 重新启动，访问show或者show2： 我们跟进该注解的源码，并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。一般启动类会放在一个比较浅的包目录中。 2.5.3.@SpringBootApplication我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解 使用@SpringBootApplication改造TestApplication： 12345678@SpringBootApplicationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 点击进入，查看源码： 发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration：开启自动配置 @ComponentScan：开启注解扫描 2.5.4.@SpringBootConfiguration@SpringBootConfiguration注解的源码： 我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 3.默认配置原理springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢? 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @Value：属性注入 @PropertySource：指定外部属性文件。 我们接下来用java配置来尝试实现连接池配置 3.2.1.引入依赖首先在pom.xml中，引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot2-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 3.2.2.添加jdbc.properties1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 3.2.3.配置数据源创建JdbcConfiguration类： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfiguration &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明JdbcConfiguration是一个配置类。 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值。 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签 然后就可以在任意位置通过@Autowired注入DataSource了！ 3.2.4.测试我们在HelloController中测试： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125;&#125; 在test方法中打一个断点，然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）新建JdbcProperties，用来进行属性注入： 代码： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致，并且必须具有getter和setter方法 需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们把jdbc.properties名称改为application.properties 2）在JdbcConfiguration中使用这个属性： 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties： @Autowired注入 123456789101112131415161718@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Autowired private JdbcProperties jdbcProperties; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbcProperties.getUrl()); dataSource.setDriverClassName(jdbcProperties.getDriverClassName()); dataSource.setUsername(jdbcProperties.getUsername()); dataSource.setPassword(jdbcProperties.getPassword()); return dataSource; &#125;&#125; 构造函数注入 12345678910111213141516@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; private JdbcProperties jdbcProperties; public JdbcConfiguration(JdbcProperties jdbcProperties)&#123; this.jdbcProperties = jdbcProperties; &#125; @Bean public DataSource dataSource() &#123; // 略 &#125;&#125; @Bean方法的参数注入 123456789@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Bean public DataSource dataSource(JdbcProperties jdbcProperties) &#123; // ... &#125;&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 3.4.更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfiguration &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 3.5.SpringBoot中的默认配置通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是怎么配置的，在哪里配置的呢？ 为何依赖引入就会触发配置呢？ 这些默认配置的属性来自哪里呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 3.6.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 4.SpringBoot实战接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 4.1.创建工程 4.2.编写基本代码 pom.xml: 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 参照上边的项目，编写引导类： 1234567@SpringBootApplicationpublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class); &#125;&#125; 编写UserController： 123456789@RestController@RequestMapping("user")public class UserController &#123; @GetMapping("hello") public String test()&#123; return "hello ssm"; &#125;&#125; 4.3.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 4.3.1.修改端口添加全局配置文件：application.properties 端口通过以下方式配置 12# 映射端口server.port=80 重启服务后测试： 4.3.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 4.3.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 实现如下： 首先我们定义一个拦截器： 123456789101112131415161718@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle method is running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle method is running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion method is running!"); &#125;&#125; 然后定义配置类，注册拦截器： 123456789101112131415@Configurationpublic class MvcConfiguration implements WebMvcConfigurer &#123; @Autowired private HandlerInterceptor myInterceptor; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns("/**"); &#125;&#125; 接下来运行并查看日志： 123preHandle method is running!postHandle method is running!afterCompletion method is running! 你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置org.springframework包的日志级别为debuglogging.level.org.springframework=debug 再次运行查看： 4.4.整合连接池jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 在pom.xml中引入jdbc的启动器： 12345678910&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 4.5.整合mybatis4.5.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官方自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; user对象参照课前资料，需要通用mapper的注解： 接下来，就去集成通用mapper。 4.5.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 4.6.整合事务其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 4.7.启动测试在UserController中添加测试方法，内容： 1234567891011121314151617@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("&#123;id&#125;") public User queryUserById(@PathVariable("id")Long id)&#123; return this.userService.queryById(id); &#125; @GetMapping("hello") public String test()&#123; return "hello ssm"; &#125;&#125; 我们启动项目，查看： 4.8.完整项目结构 完整的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用mapper --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 完整的application.properties： 123456789101112server.port=80logging.level.org.springframework=debugspring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉# mybatis.mapper-locations=classpath:mappers/*.xml 5.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 5.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 5.2.提供数据编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 5.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 5.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125;"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;user.birthday&#125;"&gt;1980-02-30&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 5.5.测试接下来，我们打开页面测试一下： 5.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： 在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。 eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客一些写作标签]]></title>
    <url>%2F2019%2F12%2F08%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E4%BA%9B%E5%86%99%E4%BD%9C%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 一、代码标签代码：123&#123;% codeblock lang:command %&#125;这是一行代码&#123;% endcodeblock %&#125; 效果： 1这是一行代码 1这是一行代码 二、文本居中标签 代码： 123&#123;% cq %&#125;四郎，那年杏花微雨，你说你是果郡王。原来自那时起，一切便都是错的。&#123;% endcq %&#125; 效果： 四郎，那年杏花微雨，你说你是果郡王。原来自那时起，一切便都是错的。 三、note标签 _config 文件配置关键字：note, 我的配置如下： style: flaticons: trueborder_radius: 3 代码： 123456789101112131415161718&#123;% note default %&#125;default&#123;% endnote %&#125;&#123;% note primary %&#125;primary&#123;% endnote %&#125;&#123;% note success %&#125;success&#123;% endnote %&#125;&#123;% note info %&#125;info&#123;% endnote %&#125;&#123;% note warning %&#125;warning&#123;% endnote %&#125;&#123;% note danger %&#125;danger&#123;% endnote %&#125; 效果： default primary success info warning danger 四、label标签 _config 文件配置关键字：Label , 需要用的话把值设为true即可。 代码： 123456&#123;% label default@默认 %&#125;&#123;% label primary@主要 %&#125;&#123;% label success@成功 %&#125;&#123;% label info@信息 %&#125;&#123;% label warning@警告 %&#125;&#123;% label danger@危险 %&#125; 效果： 默认 主要 成功 信息 警告 危险]]></content>
      <categories>
        <category>Hexo个人博客</category>
        <category>写作标签</category>
      </categories>
      <tags>
        <tag>Hexo个人博客</tag>
        <tag>写作标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客自定义友链页面]]></title>
    <url>%2F2019%2F12%2F08%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 一、常规操作：在主题配置文件中添加在next主题的配置文件\themes\next_config.yml 中添加友链12345678910# Blog rollslinks_icon: linklinks_title: Links# links_layout: blocklinks_layout: inlinelinks: 博采众长: https://lruihao.cn/ 乐余地: https://www.leridy.pw/ 同盟源: https://tmy123.com/ Yremp: https://yremp.live next主题 的友链，默认是在主题配置文件中 links 下添加，当链接变多以后，侧栏页面的排版很不美观。当友链达到10+以上，那么侧边栏就会很不雅观。 二、骚操作：自定义友链页面这时候就需要给友链新增一个单独的页面了，下面说一下具体步骤。 2.1 新增 links 页面 在控制台使用命令创建： 1hexo new page links 也可在博客根目录 /source 下手动创建 links 文件夹和里边的 index.md 文件 然后在博客根目录 /source 下会生成一个 links 文件夹，打开其中的 index.md 文件，在头部写入 type = “links”，这个一定要写，如下： 12345---title: 友情链接date: 2019-12-08 03:21:39type: &quot;links&quot;--- 2.2 配置 menu 主题配置文件中menu下添加： 1links: /links/ || link 在 /themes/next/languages/zh-Hans.yml 文件中 menu 下增加中文描述 1links: 友链 做完这些工作，接下来就是要增加友链页面的样式了 2.3 友链页面样式效果图： 2.3.1新增 links.swig 页 在 /themes/next/layout/ 新建 links.swig，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 &#123;% block content %&#125; &#123;######################&#125; &#123;### LINKS BLOCK ###&#125; &#123;######################&#125; &lt;div id=&quot;links&quot;&gt; &lt;style&gt; #links&#123; margin-top: 5rem; &#125; .links-content&#123; margin-top:1rem; &#125; .link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both; &#125; .card &#123; width: 300px; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; &#125; .card:nth-child(odd) &#123; float: left; &#125; .card:nth-child(even) &#123; float: right; &#125; .card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); &#125; .card a &#123; border:none; &#125; .card .ava &#123; width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; &#125; .card .card-header &#123; font-style: italic; overflow: hidden; width: 236px; &#125; .card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; &#125; .card .card-header a:hover &#123; color: #d480aa; text-decoration: none; &#125; .card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; &lt;/style&gt; &lt;div class=&quot;links-content&quot;&gt; &lt;div class=&quot;link-navigation&quot;&gt; &#123;% for link in theme.mylinks %&#125; &lt;div class=&quot;card&quot;&gt; &lt;img class=&quot;ava&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;关注&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;&#123; page.content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;##########################&#125; &#123;### END LINKS BLOCK ###&#125; &#123;##########################&#125;&#123;% endblock %&#125; 2.3.2 修改 page.swig 修改 /themes/next/layout/page.swig 文件，在开头的 block title 内部 12#&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;# 这个位置下添加代码： 123&lt;!-- 友情链接--&gt;#&#125;&#123;% elif page.type === &apos;links&apos; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.links&apos;) + page_title_suffix &#125;&#125;&#123;# 效果如下： 2.3.3引入 links.swig 接着在 /themes/next/layout/page.swig 中 PAGE BODY 内部，引入刚才新建的 page.swig : 123&lt;!-- 友情链接--&gt;&#123;% elif page.type === &apos;links&apos; %&#125; &#123;% include &apos;links.swig&apos; %&#125; 比如我是在 1&#123;% elif page.type === &apos;categories&apos; %&#125; 这个if下追加的： 到这里就完成页面样式的配置了。 2.4 配置友链 接下来，在 /themes/next/_config.yml 文件中配置友链，末尾处新增 mylinks ，如下 12345678910111213141516171819202122232425262728mylinks:# 友链交换 已经添加贵站# 名称：AnFrank# 地址：https://enfangzhong.github.io/# 描述：既可以早九晚五又可以浪迹天涯。# 头像：https://enfangzhong.github.io/images/avatar.jpg- nickname: AnFrank #友链名称 site: https://enfangzhong.github.io/ #友链地址 info: 既可以早九晚五又可以浪迹天涯。 #友链说明 avatar: https://enfangzhong.github.io/images/avatar.jpg #友链头像- nickname: 博采众长 #友链名称 site: https://lruihao.cn/ #友链地址 info: 分享一些有趣程序、干货、技巧、开发教程、心情和学习记录等等。 #友链说明 avatar: https://lruihao.cn/images/avatar.png #友链头像- nickname: Yremp site: https://yremp.live info: 流年，谁给过的倾城 avatar: https://cdn.jsdelivr.net/gh/yremp/resource@2.0/img/custom/head.jpg - nickname: Leaf&apos;s Blog avatar: https://leafjame.github.io/images/beichen.png site: https://leafjame.github.io info: Java狮 北漂男 摄影 旅行 赚钱 这里是配置了四个友链，多个的配置方式相同。 hexo 部署命令三连，看看效果吧~ 1hexo c &amp;&amp; hexo g -d]]></content>
      <categories>
        <category>Hexo个人博客</category>
        <category>自定义友链页面</category>
        <category>友链</category>
      </categories>
      <tags>
        <tag>Hexo个人博客</tag>
        <tag>自定义友链页面</tag>
        <tag>友链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客添加标签云及效果展示]]></title>
    <url>%2F2019%2F12%2F08%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E4%BA%91%E5%8F%8A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[[TOC] Hexo个人博客添加标签云及效果展示一、hexo-tag-cloud插件介绍hexo-tag-cloud插件是作者写的一个Hexo博客的标签云插件，旨在直观的展示标签的种类，美观大方且非常优雅。 1.1 插件下载地址：插件的GitHub地址： https://github.com/MikeCoder/hexo-tag-cloud 1.2 插件说明：说明地址： https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md 1.3 标签云效果展示： 我的博客主页： https://enfangzhong.github.io/ 二、安装插件进入到 hexo 的根目录，在 package.json 中添加依赖: &quot;hexo-tag-cloud&quot;: &quot;2.0.*&quot; 操作如下： 2.1 使用命令行进行安装复制 1npm install hexo-tag-cloud@^2.0.* --save 2.2 Git clone 下载使用命令行安装插件包的过程中可能会出现问题，安装失败，安装不完全。可以直接克隆插件到博客的插件文件夹blog/node_modules里。或者克隆到桌面，复制到博客的插件文件夹blog/node_modules里。 三、配置插件插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。 1、swig 用户 (Next主题在列)在主题文件夹找到文件 theme/next/layout/_macro/sidebar.swig, 然后添加如下代码： 123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 代码添加到后面即可，添加示意图如下: 2、对于ejs的用户 (默认主题landscape在列)在主题文件夹找到文件hexo/themes/landscape/layout/_widget/tagcloud.ejs,将这个文件修改如下： 复制 12345678910111213&lt;% if (site.tags.length) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 3、对于jade用户 (Apollo主题在列)找到 apollo/layout/archive.jade 文件，并且把 container 代码块修改为如下内容: 复制 123456789101112block container include mixins/post .archive h2(class=&apos;archive-year&apos;)= &apos;Tag Cloud&apos; script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcloud.js&apos;) script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcanvas.js&apos;) #myCanvasContainer.widget.tagcloud(align=&apos;center&apos;) canvas#resCanvas(width=&apos;500&apos;, height=&apos;500&apos;, style=&apos;width=100%&apos;) !=tagcloud() !=tagcloud() +postList() 四、主题配置 在next主题根目录，找到 _config.yml配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮: 1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: &apos;#333&apos; textHeight: 25 outlineColor: &apos;#E2E1D1&apos; maxSpeed: 0.1 textColor: ‘#333’ 字体颜色textHeight: 25 字体高度，根据部署的效果调整maxSpeed: 0.1 文字滚动速度，根据自己喜好调整 五、部署5.1 本地部署预览效果1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 5.2 博客部署到github或者码云1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 推荐使用 &amp;&amp; 作为组合命令的串联符号 注：一定要严格清理缓存，这样不容易出现问题，即需要执行hexo clean]]></content>
      <categories>
        <category>hexo博客</category>
        <category>标签云</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>标签云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客添加APlayer音乐播放器功能]]></title>
    <url>%2F2019%2F12%2F08%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0APlayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[[TOC] 为什么会写hexo添加音乐播放器呢？初衷是有粉丝私信总是问我的博客中音乐播放器是怎么添加的。所以还是写一下，毕竟不是一两句话可以描述清楚。 Hexo个人博客添加APlayer音乐播放器功能一、效果图音乐播放器效果地址： https://enfangzhong.github.io/ 二、引入APlayer音乐播放器2.1 下载APlayer源码APlayer源码下载地址：https://github.com/MoePlayer/APlayer 2.2 将源码放到next主题的source文件夹中 下载到APlayer源码压缩包，解压后把dist文件夹复制到\themes\next\source目录中。 2.3 放入自己喜欢的音乐 在dist目录里，新建music.js文件，并把如下代码粘贴进去。 12345678910111213141516171819202122232425262728293031323334353637const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;平凡之路&quot;, artist: &apos;朴树&apos;, url: &apos;http://www.ytmp3.cn/down/59211.mp3&apos;, cover: &apos;http://p1.music.126.net/W_5XiCv3rGS1-J7EXpHSCQ==/18885211718782327.jpg?param=130y130&apos;, &#125;, &#123; name: &apos;这些民谣 - 一次听个够&apos;, artist: &apos;翁大涵&apos;, url: &apos;http://www.ytmp3.cn/down/60222.mp3&apos;, cover: &apos;http://p2.music.126.net/Wx5GNJEpay2JbfVUJc4Aew==/109951163094853876.jpg?param=130y130&apos;, &#125;, &#123; name: &apos;你的酒馆对我打了烊&apos;, artist: &apos;陈雪凝&apos;, url: &apos;http://www.ytmp3.cn/down/59770.mp3&apos;, cover: &apos;http://p1.music.126.net/LiRR__0pJHSivqBHZzbMUw==/109951163816225567.jpg?param=130y130&apos;, &#125;, &#123; name: &apos;Something Just Like This&apos;, artist: &apos;The Chainsmokers&apos;, url: &apos;http://www.ytmp3.cn/down/50463.mp3&apos;, cover: &apos;http://p2.music.126.net/ggnyubDdMxrhpqYvpZbhEQ==/3302932937412681.jpg?param=130y130&apos;, &#125;, &#123; name: &apos;Good Time&apos;, artist: &apos;Owl City&amp;Carly Rae Jepsen&apos;, url: &apos;http://www.ytmp3.cn/down/34148.mp3&apos;, cover: &apos;http://p1.music.126.net/c5NVKUIAUcyN4BQUDbGnEg==/109951163221157827.jpg?param=130y130&apos;, &#125; ]&#125;); 2.4在next主题下的layout中引入APlayer音乐播放器源码在\themes\next\layout_layout.swig文件中，里新增如下代码： 12345&lt;!-- 加入APlayer音乐播放器 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 2.5 重新部署在blog目录下开启重新部署命令： 1hexo c &amp;&amp; hexo g -d]]></content>
      <categories>
        <category>hexo博客</category>
        <category>音乐播放器</category>
        <category>APlayer音乐播放器</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>音乐播放器</tag>
        <tag>APlayer音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句面试经典50题]]></title>
    <url>%2F2019%2F12%2F03%2FSQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B850%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SQL语句面试经典50题 2019/12/03 19:36 今天更新到这 2019/12/04 22:05 项目中完成了表单中的上传下载接口与前端对接。今天加班到八点，话说加班可以调休。希望过年调几天。 2019/12/05 01:43 今天研究了一下Flowable 工作流框架，明天继续。夜深了，休息。 2019/12/06 13:23 刚才在b站看了一个程序员老哥被裁的纪念品上面写着：感谢有你，一路同行，怀念我们一起奋斗的时光。 0.学习目标 了解SQL的作用 掌握SQL语句的编写 1. 为什么要练习sql语句？做为一个后端开发人员，sql语句的编写是至关重要的。在实习的第一天到公司，我的leader戴哥就是让我练习sql语句。尽管用mybatis plus，但是sql语句可以处理复杂的逻辑。 会写sql的程序员，才是真的的crud boy。 练习sql语句，主要看了猴子和小番茄的知乎博文分析。 这里有sql面试的50题，帮助大家更进一步的熟悉SQL. SQL是数据分析师的必备基础技能，希望大家跟我一起来打怪升级，最后成为某一领域的数据科学家。 常见的SQL面试题： 经典50题 - 知乎 https://zhuanlan.zhihu.com/p/38354000 SQL面试必会50题 - 知乎 https://zhuanlan.zhihu.com/p/43289968 2.练习题分析阶段 已知有如下4张表： 学生表：student(学号,学生姓名,出生年月,性别) 成绩表：score(学号,课程号,成绩) 课程表：course(课程号,课程名称,教师号) 教师表：teacher(教师号,教师姓名) 1.学生表Student(s_id,s_name,s_birth,s_sex) —学生编号,学生姓名, 出生年月,学生性别2.课程表Course(c_id,c_name,t_id) – —课程编号, 课程名称, 教师编号3.教师表Teacher(t_id,t_name) —教师编号,教师姓名4.成绩表Score(s_id,c_id,s_score) —学生编号,课程编号,分数 根据以上信息按照下面要求写出对应的SQL语句。 ps：这些题考察SQL的编写能力，对于这类型的题目，需要你先把4张表之间的关联关系搞清楚了，最好的办法是自己在草稿纸上画出关联图，然后再编写对应的SQL语句就比较容易了。下图是我画的这4张表的关系图，可以看出它们之间是通过哪些外键关联起来的： 3.准备阶段3.1.创建数据库和表为了演示题目的运行过程，我们先按下面语句在客户端navicat中创建数据库和表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 建表-- 学生表CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;, `s_birth` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;, `s_sex` VARCHAR(10) NOT NULL DEFAULT &apos;&apos;, PRIMARY KEY(`s_id`));-- 课程表CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;, `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`));-- 教师表CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;, PRIMARY KEY(`t_id`));-- 成绩表CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`));-- 插入学生表测试数据insert into Student values(&apos;01&apos; , &apos;赵雷&apos; , &apos;1990-01-01&apos; , &apos;男&apos;);insert into Student values(&apos;02&apos; , &apos;钱电&apos; , &apos;1990-12-21&apos; , &apos;男&apos;);insert into Student values(&apos;03&apos; , &apos;孙风&apos; , &apos;1990-05-20&apos; , &apos;男&apos;);insert into Student values(&apos;04&apos; , &apos;李云&apos; , &apos;1990-08-06&apos; , &apos;男&apos;);insert into Student values(&apos;05&apos; , &apos;周梅&apos; , &apos;1991-12-01&apos; , &apos;女&apos;);insert into Student values(&apos;06&apos; , &apos;吴兰&apos; , &apos;1992-03-01&apos; , &apos;女&apos;);insert into Student values(&apos;07&apos; , &apos;郑竹&apos; , &apos;1989-07-01&apos; , &apos;女&apos;);insert into Student values(&apos;08&apos; , &apos;王菊&apos; , &apos;1990-01-20&apos; , &apos;女&apos;);-- 课程表测试数据insert into Course values(&apos;01&apos; , &apos;语文&apos; , &apos;02&apos;);insert into Course values(&apos;02&apos; , &apos;数学&apos; , &apos;01&apos;);insert into Course values(&apos;03&apos; , &apos;英语&apos; , &apos;03&apos;);-- 教师表测试数据insert into Teacher values(&apos;01&apos; , &apos;张三&apos;);insert into Teacher values(&apos;02&apos; , &apos;李四&apos;);insert into Teacher values(&apos;03&apos; , &apos;王五&apos;);-- 成绩表测试数据insert into Score values(&apos;01&apos; , &apos;01&apos; , 80);insert into Score values(&apos;01&apos; , &apos;02&apos; , 90);insert into Score values(&apos;01&apos; , &apos;03&apos; , 99);insert into Score values(&apos;02&apos; , &apos;01&apos; , 70);insert into Score values(&apos;02&apos; , &apos;02&apos; , 60);insert into Score values(&apos;02&apos; , &apos;03&apos; , 80);insert into Score values(&apos;03&apos; , &apos;01&apos; , 80);insert into Score values(&apos;03&apos; , &apos;02&apos; , 80);insert into Score values(&apos;03&apos; , &apos;03&apos; , 80);insert into Score values(&apos;04&apos; , &apos;01&apos; , 50);insert into Score values(&apos;04&apos; , &apos;02&apos; , 30);insert into Score values(&apos;04&apos; , &apos;03&apos; , 20);insert into Score values(&apos;05&apos; , &apos;01&apos; , 76);insert into Score values(&apos;05&apos; , &apos;02&apos; , 87);insert into Score values(&apos;06&apos; , &apos;01&apos; , 31);insert into Score values(&apos;06&apos; , &apos;03&apos; , 34);insert into Score values(&apos;07&apos; , &apos;02&apos; , 89);insert into Score values(&apos;07&apos; , &apos;03&apos; , 98); Student表： Course表： Teacher表： Score表： 4.面试题为了方便学习，我将50道面试题进行了分类练习 4.1.练习：简单查询 1.查询姓“猴”的学生名单 2.查询姓“孟”老师的个数123SELECT COUNT(*) AS 姓“孟”老师的个数FROM teacherWHERE t_name LIKE &apos;孟%&apos; 4.2.练习：汇总、分组、分组条件查询4.2.1.练习：汇总 3. 面试题：查询课程编号为“0002”的总成绩1234567891011/*分析思路select 查询结果 [总成绩:汇总函数sum]from 从哪张表中查找数据[成绩表score]where 查询条件 [课程号是0002]*/SELECT sum(s_score)FROM scoreWHERE c_id =&apos;0002&apos; 4. 查询选了课程的学生人数12345678/*这个题目翻译成大白话就是：查询有多少人选了课程select 学号，成绩表里学号有重复值需要去掉from 从课程表查找score;*/SELECT COUNT(DISTINCT c_id) AS 学生人数FROM score 4.2.2 练习：分组 5.查询各科成绩最高和最低的分以如下的形式显示：课程号，最高分，最低分 12345678910111213141516171819/*分析思路select 查询结果 [课程ID：是课程号的别名,最高分：max(成绩) ,最低分：min(成绩)]from 从哪张表中查找数据 [成绩表score]where 查询条件 [没有]group by 分组 [各科成绩：也就是每门课程的成绩，需要按课程号分组];*//*上述题的拆分：课程id为0002的最高分与最低分SELECT MAX(s_score) AS 最高分, MIN(s_score) AS 最低分FROM scoreWHERE c_id = &apos;0002&apos;*/SELECT c_id,MAX(s_score) AS 最高分,MIN(s_score) AS 最低分FROM scoreGROUP BY c_id 6.查询每门课程被选修的学生数— 通过对成绩表的课程id进行分组，然后对该学号进行计数 1234567891011/*分析思路select 查询结果 [课程号，选修该课程的学生数：汇总函数count]from 从哪张表中查找数据 [成绩表score]where 查询条件 [没有]group by 分组 [每门课程：按课程号分组];*/SELECT c_id,COUNT(c_id)FROMscoreGROUP BY c_id 7.查询男生、女生人数 在学生表中对性别进行分组 计数 1234567891011121314/*分析思路select 查询结果 [性别，对应性别的人数：汇总函数count]from 从哪张表中查找数据 [性别在学生表中，所以查找的是学生表student]where 查询条件 [没有]group by 分组 [男生、女生人数：按性别分组]having 对分组结果指定条件 [没有]order by 对查询结果排序[没有];*/SELECT s_sex,COUNT(s_sex) AS 个数FROM studentGROUP BY s_sex 4.2.3 分组结果的条件 8.查询平均成绩大于60分学生的学号和平均成绩1234567891011121314151617181920/* 题目翻译成大白话：平均成绩：展开来说就是计算每个学生的平均成绩这里涉及到“每个”就是要分组了平均成绩大于60分，就是对分组结果指定条件分析思路select 查询结果 [学号，平均成绩：汇总函数avg(成绩)]from 从哪张表中查找数据 [成绩在成绩表中，所以查找的是成绩表score]where 查询条件 [没有]group by 分组 [平均成绩：先按学号分组，再计算平均成绩]having 对分组结果指定条件 [平均成绩大于60分]*/-- 在成绩表中对学号进行分组求平均成绩 having条件是平均成绩&gt;60分select s_id,AVG(s_score)FROM scoreGROUP BY s_idHAVING AVG(s_score)&gt;60ORDER BY AVG(s_score) DESC 9.查询至少选修两门课程的学生学号1234567891011121314151617/* 翻译成大白话：第1步，需要先计算出每个学生选修的课程数据，需要按学号分组第2步，至少选修两门课程：也就是每个学生选修课程数目&gt;=2，对分组结果指定条件分析思路select 查询结果 [学号,每个学生选修课程数目：汇总函数count]from 从哪张表中查找数据 [课程的学生学号：课程表score]where 查询条件 [至少选修两门课程：需要先计算出每个学生选修了多少门课，需要用分组，所以这里没有where子句]group by 分组 [每个学生选修课程数目：按课程号分组，然后用汇总函数count计算出选修了多少门课]having 对分组结果指定条件 [至少选修两门课程：每个学生选修课程数目&gt;=2]*/SELECT s_id,COUNT(c_id) as 选修课程数目FROM scoreGROUP BY c_idHAVING COUNT(c_id)&gt;=2 10.查询同名同性学生名单并统计同名人数123456789101112131415161718/* 翻译成大白话，问题解析：1）查找出姓名相同的学生有谁，每个姓名相同学生的人数查询结果：姓名,人数条件：怎么算姓名相同？按姓名分组后人数大于等于2，因为同名的人数大于等于2分析思路select 查询结果 [姓名,人数：汇总函数count(*)]from 从哪张表中查找数据 [学生表student]where 查询条件 [没有]group by 分组 [姓名相同：按姓名分组]having 对分组结果指定条件 [姓名相同：count(*)&gt;=2]order by 对查询结果排序[没有];*/SELECT s_name,COUNT(s_name)FROM studentGROUP BY s_nameHAVING COUNT(s_name)&gt;=2 11.查询不及格的课程并按课程号从大到小排列123456789101112131415/* 分析思路select 查询结果 [课程号]from 从哪张表中查找数据 [成绩表score]where 查询条件 [不及格：成绩 &lt;60]group by 分组 [没有]having 对分组结果指定条件 [没有]order by 对查询结果排序[课程号从大到小排列：降序desc];*/SELECT c_idFROM scoreWHERE s_score&lt;60GROUP BY c_idORDER BY c_id 12.查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列1234567891011121314/* 分析思路select 查询结果 [课程号,平均成绩：汇总函数avg(成绩)]from 从哪张表中查找数据 [成绩表score]where 查询条件 [没有]group by 分组 [每门课程：按课程号分组]having 对分组结果指定条件 [没有]order by 对查询结果排序[按平均成绩升序排序:asc，平均成绩相同时，按课程号降序排列:desc];*/SELECT c_id,AVG(s_score) as 平均成绩FROM scoreGROUP BY c_idORDER BY AVG(s_score) ASC,c_id DESC 13.检索课程编号为“0004”且分数小于60的学生学号，结果按按分数降序排列12345678910111213/* 分析思路select 查询结果 []from 从哪张表中查找数据 [成绩表score]where 查询条件 [课程编号为“04”且分数小于60]group by 分组 [没有]having 对分组结果指定条件 []order by 对查询结果排序[查询结果按按分数降序排列];*/select s_id,s_scoreFROM scoreWHERE c_id = &quot;0004&quot; AND s_score &gt;=60ORDER BY s_score DESC 14.统计每门课程的学生选修人数(超过2人的课程才统计)要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序 123456789101112131415/* 分析思路select 查询结果 [要求输出课程号和选修人数]from 从哪张表中查找数据 []where 查询条件 []group by 分组 [每门课程：按课程号分组]having 对分组结果指定条件 [学生选修人数(超过2人的课程才统计)：每门课程学生人数&gt;2]order by 对查询结果排序[查询结果按人数降序排序，若人数相同，按课程号升序排序];*/SELECT c_id,COUNT(score.s_id) as &apos;选修人数&apos;FROM scoreGROUP BY c_idHAVING COUNT(score.s_id) &gt; 2ORDER BY COUNT(score.s_id) DESC,c_id ASC 15.查询两门以上不及格课程的同学的学号及其平均成绩1234567891011121314151617181920212223242526272829303132333435363738394041424344/*分析思路先分解题目：1）[两门以上][不及格课程]限制条件2）[同学的学号及其平均成绩]，也就是每个学生的平均成绩，显示学号，平均成绩分析过程：第1步：得到每个学生的平均成绩，显示学号，平均成绩第2步：再加上限制条件：1）不及格课程2）两门以上[不及格课程]：课程数目&gt;2/* 第1步：得到每个学生的平均成绩，显示学号，平均成绩select 查询结果 [学号,平均成绩：汇总函数avg(成绩)]from 从哪张表中查找数据 [涉及到成绩：成绩表score]where 查询条件 [没有]group by 分组 [每个学生的平均：按学号分组]having 对分组结果指定条件 [没有]order by 对查询结果排序[没有];*/select 学号, avg(成绩) as 平均成绩from scoregroup by 学号;/* 第2步：再加上限制条件：1）不及格课程2）两门以上[不及格课程]select 查询结果 [学号,平均成绩：汇总函数avg(成绩)]from 从哪张表中查找数据 [涉及到成绩：成绩表score]where 查询条件 [限制条件：不及格课程，平均成绩&lt;60]group by 分组 [每个学生的平均：按学号分组]having 对分组结果指定条件 [限制条件：课程数目&gt;2,汇总函数count(课程号)&gt;2]order by 对查询结果排序[没有];*/SELECT s_id,COUNT(s_score),avg(s_score) AS 平均成绩FROM scoreWHERE s_score&lt;60GROUP BY s_idHAVING COUNT(s_score)&gt;=2 4.3.复杂查询16.查询所有课程成绩小于60分学生的学号、姓名这道题目知乎猴子解法是存在问题的。我这边提供我的理解吧。 第一种做法：将学号分组 在每个学号组 找成绩最高值&lt;60的学号 1234567SELECT score.s_id,student.s_nameFROM scoreINNER JOIN studentON score.s_id = student.s_idGROUP BY s_idHAVING MAX(s_score) &lt;60 第二种解法： step1: 查询出学生课程数的统计量 step2: 查询出学生课程成绩&lt;60分对应课程数的统计量 1234567891011121314151617181920SELECT A.s_id,S.s_nameFROM(SELECT s_id,COUNT(c_id) AS cntFROM scoreGROUP BY score.s_id) AS AINNER JOIN(SELECT s_id,COUNT(c_id) AS cntFROM scoreWHERE s_score&lt;60GROUP BY s_id) AS BON A.s_id = B.s_idINNER JOIN student AS SON A.s_id = S.s_idWHERE A.cnt = B.cnt 17、查询没有学全所有课的学生的学号、姓名查询出只选修了两门课程的全部学生的学号和姓名1990年出生的学生名单查询各科成绩前两名的记录分组取每组最大值、最小值，每组最大的N条（top N）记录。4.4 sql面试题：topN问题4.5 多表查询 查询所有学生的学号、姓名、选课数、总成绩查询平均成绩大于85的所有学生的学号、姓名和平均成绩查询学生的选课情况：学号，姓名，课程号，课程名称查询出每门课程的及格人数和不及格人数使用分段[100-85],[85-70],[70-60],[&lt;60]来统计各科成绩，分别统计：各分数段人数，课程号和课程名称查询课程编号为0003且课程成绩在80分以上的学生的学号和姓名|4.6 sql面试题：行列如何互换？下面是学生的成绩表（表名score，列名：学号、课程号、成绩） 使用sql实现将该表行转列为下面的表结构 【面试题类型总结】这类题目属于行列如何互换，解题思路如下：]]></content>
      <categories>
        <category>SQL语句</category>
        <category>CRUD</category>
      </categories>
      <tags>
        <tag>SQL语句</tag>
        <tag>CRUD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招的那些事]]></title>
    <url>%2F2019%2F11%2F11%2F%E7%A7%8B%E6%8B%9B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 秋招的那些事一、秋招1.1 提前批博主在秋招之前参与了提前批的神仙打架。根据记忆提前批就面了字节跳动、京东、浦发银行，当时投递的是推荐算法，没有准备好就上战场了。 1.2 秋招每年秋招是9-11月这个阶段，一般互联网公司都集中在9月。10月还存在一些公司鞭尸。毕竟offer收割机都是手握多个offer。 二、实习 2.1 博主研二下期间（3-5月）还在写小paper。花了时间准备一篇专利，只是~~~~~。错过了实习的金三银四。 2.2 搞完论文大概是5月份了吧，当时全身心的投入到了算法与大数据的知识海洋中了，没有参与实习。 2.3 我实习在武汉最湿冷的时候。出不出太阳，全看心情。偶尔昨天气温20度，今天就5度。平时下下小雨。 2.4 南湖大道与雄庄路的十字路口总是那么的拥挤。每天早上循环播放着下一站茶山刘by房东的猫度过。 ​ 北京朋友的朋友圈全是雪雪雪。雪花儿，武汉期待你的到来。 ​ 听说今天北京下雪了。雪花儿，我在武汉等你的到来。 ——————————————————2019/11/30 夜深了，今天暂且写到这咯。]]></content>
      <categories>
        <category>秋招</category>
        <category>实习</category>
        <category>毕业季</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>实习</tag>
        <tag>毕业季</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第12章本课程回顾与总结]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC12%E7%AB%A0%E6%9C%AC%E8%AF%BE%E7%A8%8B%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第12章本课程回顾与总结 推荐算法实战课程，课程是有问答专区，如果你有问题可以在问答专区提问，我会在每天固定时间解答课程，结合问答专区能够让你更快的掌握知识。 开始本章节的内容之前我们首先来回顾一下上一章节的内容，上一章节我们对之前所讲述过的排序部分的内容进行了总结与回顾。 本章节我们对课程所讲述过的全部内容进行总结与回顾，下面一起来看一下本章节的内容大纲。 一、个性化推荐算法离线架构 个性化推荐算法离线架构，无论是在个性化召回部分还是在个性化排序部分，我们都有一套离线处理，得到我们模型的流程，我们将这套流程的抽象一下给大家解析一下。 二、个性化推荐算法在线架构 无论是在个性化召回部分还是在个性化排序不分，我们都曾经将在线部分的架构呢，给大家讲解过，这里我们一起回顾一下。 三、本课程所讲述过的算法模型的内容回顾 一、个性化推荐算法离线架构下面一起来看一下离线架构。 我们原始的日志呢，包含以下四个部分。 ①用户的点击与用户的展示日志。 ②我们记录用户信息的日志，这里包含用户的静态信息和统计的一些动态的信息，包括用户喜欢什么样的类型的内容等等。 ③item的信息 ④实时流式信息（Streaming）。这里的流式是指包含用户的一些实时行为。比如说用户订阅某个频道、用户将某些物品加入到购物车等等等等。 基于以上的日志，我们首先进行样本的筛选，我们将测试样本有噪声的样本的剔除掉得到我们的样本，得到样本之后呢，我们再进行特征选择。 在个性化召回部分，可能我们只是更多的需要我们的点击与展示数据。但是在我们的个性化排序部分，可能我们还需要用户的信息（user info），项目的信息（item info）以及上下文信息等等的一些信息。 基于我们的特征选择与样本选择之后呢，我们得到了我们的训练数据集以及测试数据，接下来无论是在召回部分还是在排序部分，我们都使用的训练数据集去训练模型，使用我们的测试数据去评估我们模型的表现。如果我们模型的表现达到了我们的要求，我们就将我们得到的模型文件的导出。 这里在个性化召回部分呢，可能是导出的直接用户的推荐结果，也可能是item相似度的列表亦或是我们的深度学习的模型文件。 在排序部分我们得到的模型文件的基本都是模型的实例化本身。像逻辑回归部分呢，其实我们只需要得到不同特征对应的参数即可。 二、个性化推荐算法在线架构1、Recall在线架构 说完了离线架构，下面我们来一起回顾一下在线架构的召回部分，大部分情况下我们召回部分得到的结果呢，是直接写入到KV存储当中了。用户访问我们的Server的时候呢，直接召回到自己对应的推荐结果，我们拿到推荐结果对应的id呢，从我们的Detail Server当中的获取Detail 传给我们的排序部分，但是呢在一些复杂场景情况下，我们比如训练了一些深度学习的模型，那么我们在用户访问我们的Server的时候呢，我们首先得需要拼接一下用户侧（user info）的特征，然后呢访问我们的Server得到用户的向量表示然后再进行召回。 2、Rank在线架构说完了个性化召回的在线架构的，下面我们来一起看一下排序部分在线架构。排序部分在线架构根据我们模型的不同的分为以下几种。 1、如果是像逻辑回归或者是GBDT这种浅层模型。我们这里的Rank Server可以直接将模型加载到内存当中，与我们的推荐引擎的进行服务的交互。用户访问我们的Server的时候，我们首先召回得到我们的候选集列表，对于每一个候选集列表，那我们去KV当中的拼一下我们的特征，就是获得我们用户侧（user info）的特征以及项目侧（item info）的特征包括一些上下文特征等等。我们将拼接的特征的传递给让给Rank Server。Rank Server用模型来进行下预测，将预测的结果呢再传递给我们的推荐引擎。推荐引擎的依据我们每一个item预测的得分的进行一下排序，这个顺序呢就是展示给用户的顺序。 2、如果我们这里采用像WD这样的深度学习模型的话，我们这里的Rank Server需要与我们的TF Server进行交互，这里的Rank Server相当于我们这里的请求的透传，并且返回的结果呢，也透传给我们的推荐引擎。 三、本课程所讲述过的算法模型的内容回顾回顾完了在线架构，我们来一起看一下本课程具体讲解了哪些算法与模型？ 首先来看个性化召回部分，这里我们介绍了基于领域的CF、LFM、Person Rank 、Item2Vec、ContentBased。我们CF是在个性化推荐算法实战入门必修课里介绍的，入门必修课是一门免费的课程大家都可以看到。还有我们基于内容的推荐以及呢，我们这里基于深度学习的推荐Item2Vec。 我们在排序部分的介绍了浅层模型Rank LR（逻辑回归）,浅层模型组合GBDT。介绍了浅层模型不同模型的组合：LR+GBDT的混合模型。最后我们介绍了深度学习模型WD。以上的每一个算法或者模型呢，我们都是从物理意义数学公式推导，代码实战等几个方面来给大家介绍的，那么好了，本章节的内容到这里就全部结束了。本章节重点回顾了我们本次课程所讲述的全部内容。到这里本次个性化推荐算法实战课程的全部内容就结束了，非常感谢大家对于本课程的认真学习。祝大家在本次课程中学习一切顺利。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>个性化推荐算法实践总结</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>个性化推荐算法实践总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第11章排序模型总结与回顾]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC11%E7%AB%A0%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第11章排序模型总结与回顾 model在测试数据集效果回顾1、逻辑回归模型、gbdt模型、gbdt模型与逻辑回归混合模型以及wd模型在测试数据集上的效果进行一下简单的回顾 LTR中特征维度浅析 2、我们会对工业界实际项目中建立排序模型所使用的特征进行一下简单的浅析。 工业界Rank技术展望3、对工业界的排序技术进行一下展望 一、model在测试数据集效果回顾1、效果回顾 下面首先来回顾一下各模型在测试数据集上的表现。由于我们各Rank模型在线上实际使用时呢是对item进行打分，然后呢不同的item按照这个得分的展现给用户，所以呢我们这里更加关心的是模型对于我们item预测得分序的关系，所以呢也就是AUC我们这里从我们模型交叉验证得到的AUC以及模型在测试数据集表现的AUC两点的进行一下回顾。 我们在排序部分的重点介绍了四种模型分别是逻辑回归、GBDT、GBDT与逻辑回归的混合模型以及我们基于深度学习的WD模型。 首先呢从我们的模型交叉验证的效果来看一下GBDT与逻辑回归的混合模型的表现要好于GBDT。GBDT要好于我们的逻辑回归模型，由于我们的WD并没有采用我行交叉验证的方式呢，去评估，所以这里没有数据。好了，我们再来看一下训练好的模型呢，在测试数据集上的表现也就是看一下模型的泛化能力。这里同样的GBDT与逻辑回归的混合模型的是要好GBDT，GBDT是要比逻辑回归好，这里要注意一下，在实际的我们的项目中WD模型实际上是表现的最好，但是在这里限于我们的样本的数量了只有3万等等的一些限制。WD表现的要略低于GBDT。不过没有关系，如果大家有机会在实际项目海量的数据集当中了去实践一下，不同的Rank模型的话，大家一定能得到下面的结论，WD模型的表现是要好于GBDT与逻辑回归的混合模型。混合模型是要好于GBDT模型。GBDT是要好于我们的逻辑回归模型。但我实际工作中零一搭建个性化排序系统时得到的结论也是这样的。 2、离线评估模型交叉验证(model cv)在我们训练不同的排序模型，将不同的模型放到线上时，我们如何来评价离线的准入以及在线的收益呢？下面来看一下排序模型的评估，首先来看一下离线评估，第一点的，我们需要看一下模型交叉验证得到的指标，这些指标的，包括我们课上重点提到的AUC，以及准确召回等等的一些指标，这些指标我们需要明确它的物理意义，这样才能够帮助我们清晰地判断模型的效果。 model test data performance最终的我们还需要判断一下模型的泛化能力，也就是模型在测试数据集上的表现，比如模型在测试数据集上得到的AUC,得到的准确率等等，我们结合着不同的业务场景的也会有一些独自的评判标准，比如我们在信息流场景当中呢，我们可能更关注的是session的平均点击位置，这里简单的解释一下。我们每一个session展示了，比如说三条数据。 在我们的测试数据上的原有的情况下，比如我们点击了这3条，经过我们训练模型对于这三个数据得重新打分之后呢，我们能否将已经击的这个第二条呢？学习到第一的位置，这样我们的平均点击位置的就更靠前了，这样的效果也就说明了是更好的。当然了，不同的业务场景还有一些其他的指标。 3、在线评估业务指标下面我们来看一下在线指标，首先呢是业务指标。比如说点击率，购买率，平均阅读时长，总的交易额度等等，我们根据不同的业务场景的制订了评价的指标，最终的结果呢也已在线AB测试得到的业务指标的生效为准。 平均点击位置离线的评价指标的只是我们能否准入的一个衡量的标准，并不能决定我们在线实际效果的好坏，当然了这里还有一些辅助的评价指标，比如像之前我们介绍的平均点击位置。当然呢在线评估时，我们首先来看一下业务指标，其次呢是我们的辅助评价指标。好啦，在线离线的评估呢，我们已经说完了。 二、LTR中特征维度浅析1、特征维度 特征维度 下面来看一下特征了有哪一些？我们的构建排序模型是常用的特征的有以下几个方面，我们来简单的介绍一下，用户侧的特征包含了用户的静态的属性，比如说年龄，性别，地域，还有一些简单的统计特征，比如该用户在我们平台上浏览过多少个商品？点击过多少个商品的购买过多少个商品的，购买过多少个商品啊？近30天浏览了多少商品的这种长短时的统计，最后还有一些用户侧的高维的特征，我们基于它的浏览点击购买历史的给他打上一些标签，比如说呢，她就喜欢某某品牌的香水某某品牌的鞋子等等。刚刚介绍用户特征侧时是以电商场景举例。对于其他的产品道理也是一样的，比如说信息流。我们只需要统计一下用户发现喜欢财经呢，还是喜欢体育，是喜欢娱乐呢？还是喜欢科技，甚至呢我们还可以给他打上标签儿，是科比的标签的还是鹿晗的标签等等？道理都是一样的。 商品侧的特征基础的特征包含商品的名称，商品的上线日期啊等等统计的特征的包含商品被购买的次数。商品的点击率呀，商品的购买率啊等等。一些高维的标签，那比如说这个商品的，他是深受90后欢迎啊，深受年轻女性的欢迎啊，我们的上下文的特征的有，当前是星期几呀？现在是几点呀？用户请求我们服务时所处的地理位置信息等等。用户和item的关系。比如说这个商品呢，是该用户两个月之前加入到购物车里头，一个月之前点击过的呀，半年之前购买过呀，等等的一些信息，还有我们的统计登录信息，比如说呢商品的上架的时间呢与购买率间的关系，比如说近一个月之内上架的商品打开的购买率是多少？近两个月等等我们统计出来显然的又增加了一维特征。好了我们曾经无数次说过特征与样本是决定我们最终这个整体表现的天花板，而我们采用不同的模型的只能去逼近这个天花板。像我刚才介绍这些不同维度特征时呢，我们是用电商场景举例的，但是呢实际的项目中呢，假如没有做过电商的场景，可以根据特征的大体由这五个维度来想到一些电商场景下应该有哪些特征？大家在自己的项目当中呢，或者自己解决实际问题过程中的，也一定要结合的实际去构造我们需要的特征。 2、特征的数目 特征的数目 我们说过为了防止过拟合，那我们尽量要将特征与样本的数目来维持在1：100。举例，比如说我们这里有1000个训练样本，那么这里我选择了十个特征，这是没有问题的，但是呢，有的同学说我没有找到十个特征，我只找到了八个那也是没有问题的。 可能最终我们学习出来的效果不会很好。但是有的同学说我找到了50个特征，那么显然呢，这个模型呢就会过拟合。他在测试数据集上的表现的就会比较差，就是说它的泛化能力就不会很强。 三、工业界Rank技术展望1、多目标学习我们知道了在信息流场景中的我们既想用户拿多点击，也就是点击率预估模型也想用户停留的阅读时长的要长一点。这样呢就是两个目标。之前的可能有很多方式呢，比如说训练两个模型，一个呢是点击率预估模型，一个是平均阅读时长预估模型，然后乘起来，比如说那像电商场景中的我们既想用户呢，他得购买率也就是说最终的转化率呢要高又想拿我们懂得交易额度也能高。有人呢对这种多目标问题的提出了一种将不同的目标的融合到一个网络里进行学习的方法。 2、强化学习我们知道强化学习的是成功保证历史最大回报率的一种办法，现在呢这种算法呢，在游戏里应用的比较广泛也比较成熟，但排序的领域也有一些落地与尝试。希望大家的能够对这些较新的技术进行不断的追求，不断的学习。不断的探究，不断的尝试。那么本章节的内容到这里就全部结束了，本章节的重点是对之前多讲述过的排序部分的内容进行了总结回顾，下一章节我们将会对个性化推荐算法课程的内容来进行一下总结。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>排序模型总结</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>排序模型总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第10章基于深度学习的排序模型WideAndDeep]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC10%E7%AB%A0%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8BWideAndDeep%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第10章基于深度学习的排序模型WideAndDeep欢迎来到本次个性化推荐算法实战课程，本课程是有问答专区，如果你有问题可以在问答专区提问，我会在每天固定时间解答，课程结合问答专区能够让您更快的掌握知识。 开始本章节的课程之前，我们首先来回顾一下上一章节的内容，上一章节我们重点讲述了树模型GBDT的数学原理，以及在测试数据集上代码实战了GBDT模型的训练，并且介绍了GBDT与逻辑回归的混合模型，那么本章节我们将重点介绍深度学习，在点击率预估方面的实战，分别介绍WD模型的数学原理，以及在测试数据集上代码实战WD模型的训练。 背景介绍之深度学习 DNN网络结构与数学原理 WD(wide and deep)网络结构与数学原理 下面我们首先来看一下本章节的内容大纲。1、背景知识介绍之深度学习，由于本章节所介绍的内容与之前我们所学习的浅层模型有较大的不同，所以我们首先介绍一下背景知识，什么是深度学习？2、DNN网络结构与数学原理，介绍完什么是深度学习，我们便选取一种具有代表性的网络DNN，来从它的数学原理如何进行参数学习来详解一下。3、WD网络结构与数学原理，WD模型便是我们所说的，使用深度学习来完成点击率预估实战所采用的模型，wd模型实际上是DNN与逻辑回归的混合模型，但是与之前我们所介绍过的GBDT与逻辑回归的混合模型不同，WD呢是联合训练的，所以我们要学习一下它的网络结构，并且详细的了解一下它的数学原理是如何做到联合训练的。 一、背景介绍之什么是深度学习1.1什么是神经元?下面开始本小节的内容，本小节将重点介绍背景知识，什么是深度学习？深度学习，实际上是利用神经网络学习出一种非线性函数，该函数的输入是我们从训练数据中提取的特征，该函数的输出是训练数据所对应的label，那么说到这里，问题的核心就变成了什么是神经网络，在介绍神经网络之前，我们首先介绍一下它的组成成分，神经元，什么是神经元呢？下面来看一下，这里所说的神经元呢，实际上是指的是人工神经元，与我们生物上神经元的概念呢有所不同。但是呢，我们通过这个网络结构呢，实际上能够联想一下我们生物上的神经元，与该结构有极大的相似性。 下面我们来看一下该结构，这里有几路输入，每一路输入了对应的输入的参数。也就是说我们最终的加权和是什么呢？我这里简单的写一下，加权和=$w_1x_1+w_2x_2+w_3x_3+…+w_nx_n$。加权和之后呢，还要做一下激活函数，这里的激活函数呢，主要是去线性化。常用的激活函数呢，我们在介绍逻辑回归模型的时候，也曾介绍过一种阶跃函数，大家应该还记得。这里的整体的网络结构呢与我们的逻辑回归模型的有一定的相似性。 1.2激活函数那么下面我们来看一下常用的激活函数有哪一些呢？ 1.2.1阶跃函数 sigmod第1种呢是我们比较熟悉的阶跃函数，该函数我们曾在逻辑回归里介绍过，该函数的取值范围呢是[0~1]，在x等于0时的函数值是0.5，他有一个特点那便是在x大于0的时候，很快函数值就趋向于1。x小于0的时候，函数值非常快的就趋向于0。 1.2.2双曲正切第2种呢，是双曲正切，该函数的图像呢与阶跃函数几乎是一样的，只不过呢，它的取值范围呢是[-1,+1]，而且呢，该函数在取值为中间值变为最大值，以及取值为中间值变为最小值的速度呢，要比阶跃函数要快一些。 1.2.3修正线性单元第3种，修正线性单元，当输入大于零时，该函数的输出的是输入的本身，当输入小于零时，该函数的输出呢是0。在神经网络的参数学习中呢，如果我们采用之前讲述过的随机梯度下降的方法，修正线性单元函数能够更快的达到收敛。 1.3 什么是神经网络？ 好了介绍完了激活函数，下面我们来学习一下什么是神经网络。神经网络呢是由许多神经元组成的，我们先来简单的看一下网络结构，网络结构呢分为输入层，隐层以及输出层。 输出层呢，可以是一个也可以是多个。像我们做点击率预估呢，那便是一个。如果我们做分类呢是多分类的话，显然就是多个。有几个分类呢，也就有几个输出。输入指的是什么呢？输入指的是我们提取的特征，输入层呢，与隐层之间的采用的是全连接，也就是说我这里的隐层1与我输入层的每一个输入，都有参数相连。这里的隐层2呢，对于输入层的每一个输入呢，也都是有参数相连的。这里参数相连去加权求和之后呢，同样需要有激活函数来去线性化。 我们发现如果输入层与隐层不是全连接的话，而是一一连接的话，那么该网络也便回退到了我们之前讲述过的逻辑回归模型。为什么呢？很好理解，如果是一一连接的话，很像我们之前讲述过的w1与x1相乘，w2与x2相乘。 这样全连接呢，实际上相当于我们在逻辑回归模型里所做的特征交叉，但是呢，这里交叉的力度呢，会更强一点。 举个例子，如果我们这里只有三个输入特征，且并非全连接。对该隐层的第1个节点，我们让三个输入特征的前两个与它连接，实际上这就相当于完成了我们之前所做的两维特征的特征交叉。 而这里呢，由于每一个节点与之输入层都是全连接的，所以参数的规模呢要比之前大了非常多。我们来看一下一共有多少个参数呢？比如说我们的输入层一共有三个节点，隐层也是有三个节点，那么隐层的每一个节点，显然啦，与输入层之间的都是全连接，也就是都是三个参数，以及每一个隐层的节点呢，都需要一个偏执，所以这里总的参数呢，是3×3+3=12。而相同情景下逻辑回归的参数呢，只有三个，所以从参数量级上呢，神经网络还是要大很多的。 如果按当时我们训练逻辑回归模型所举的例子，输入特征100多维这里就按100维来算的话，隐层的节点如果有n个。那么这里的总参数便是（100n+n）也就是101n，而我们知道逻辑回归当中的这种情形下只有100个参数，所以呢，总体来讲参数的量级上呢，差了n倍，这个n呢是隐层的节点数目，也就是说隐藏的节点数目越多的话，参数的量级差距越大，神经网络能够学习到的隐含特征的也就越丰富。 1.3深度学习与传统的机器学习有哪些流程的异同呢？DL DIFFS ML 介绍完了神经网络，下面我们来看一下深度学习与传统的机器学习有哪些流程的异同呢？首先呢，我们来看一下传统的机器学习。这里以我们所学习过的逻辑回归模型的训练为例，我们拿到训练数据之后呢，需要做特征工程，这里的特征工程呢，是指我们要挑选相应的特征，我们要做特征的离散化。归一化甚至呢，我们要区分连续特征以及离散特征不同的处理，最终呢，我们还要做特征的交叉等等，我们把特征工程处理好了之后呢，我们便得到了训练样本，训练样本呢，在传入的模型当中呢，去进行权重的学习，也就是参数的学习，最终呢，我们得到模型来完成结果的预测。 但是在深入学习中呢，我们只需要对输入的训练样本呢进行基础特征的抽取，而不再需要做繁琐的特征工程，繁琐的特征工程呢，相当于交由我们模型当中的多维参数来帮我们学习，这里呢，神经网络呢，就学习了这些复杂特征，进而呢在隐层之间呢，我们学习模型的参数，得到模型之后呢，我们便用来预测结果。好了本小节就全部结束了，本小节重点介绍了背景知识之什么是深度学习，下一小节我们将选取一种经典的深度神经网络DNN来介绍它的网络结构与数学原理。 二、DNN网络结构与反向传播算法2.1DNN网络结构开始本小节的课程之前，我们首先来回顾一下上一小节的内容，上一小节我们重点介绍的背景知识，什么是深度学习，那么本小节我们叫重点介绍，DNN网络结构以及DNN网络结构参数学习的数学原理，下面开始本小节的内容，下面我们来看一下DNN网络结构，DNN呢，实际上是深度神经网络与我们之前介绍过的，神经网络的结构呢，有相似性，也有不同的地方相似的地方呢。 相似的地方就是这里也分为三个大部分，第1大部分呢便是输入层，这是我们特征。多了的地方，第2大部分呢是隐层是我们基础特征的抽象到高阶特征，然后高阶特征之间参数不停的学习的过程。第3部分呢便是输出层，这里可以是一个节点，像我们在点击率预估问题中呢，便是一个输出，也可以是多个输出，像我们在多分类问题当中呢，便是多个输出。 但是这里与我们之前讲过的神经网络有不同的地方呢，便是我们的隐层呢，这里可以是多层，每一层的节点呢可以变得不同，好了这便是DNN网络结构。当然这里输入层与隐层，隐层与隐层，隐层与输出层之间的也都是全连接。 2.2 DNN模型参数2.2.1 隐层的层数，每个隐层神经元的个数，以及激活函数好了，下面让我们来看一下DNN模型当中有哪些重要的参数是值得我们注意的。首先呢，便是隐层的层数，每个隐层神经元的个数，以及激活函数。隐层的层数以及每个隐层神经元的个数呢，决定了网络的参数的量级，这里上一小节呢，我们曾经简单的举例过，三个维度特征的输入以及单隐层，三个隐层节点的话，它的参数呢是3×3+3，那么很明显我们这里可以以此类推，如果隐层与隐层之间的计算方式呢，也是这么计算，模型的参数的量级呢，是由隐层的层数以及每个隐层神经元的个数来决定的。当然了，还与我们输入特征的维度有直接的关系。激活函数的上一小节我们曾经介绍过三种，这里我们说过激活函数呢是决定我们参数收敛的快慢的。 2.2.2 输入输出层的向量维度输入输出层的向量维度，如果是单维度的输出的话，像我们点击率预估这种问题就需要单维度的输出。如果是多维度的输出，像多分类问题呢，就需要多维度的输出。输入层的向量呢，是我们选定好基础特征之后呢，在完成，像字符串的哈希，然后做一个简单的Embedding或者说是我们这里将连续值呢进行分段离散等等的操作之后呢，我们得到的一个输入层的向量。 2.2.3 不同层之间神经元的连接权重与偏移值B我们需要学习的参数是什么呢？就是不同层之间神经元的连接权重，这里可能是输入层与隐层，隐层与隐层，隐层与输出层之间的连接权重，以及呢每一个节点上的偏移值，这是我们模型需要学习的参数。 2.3 前向传播 下面我们来了解一下DNN模型的函数表达式，我们只要了解了网络的任何一个节点的输出值也便得到了模型的输出，因为模型的输出实际上就是输出层节点的输出值。 $a_{j}^{t}=f\left(\sum_{k} w_{j k}^{t} a_{k}^{t-1}+b_{j}^{t}\right)$$z_{j}^{t}=\sum_{k} w_{j k}^{t} a_{k}^{t-1}+b_{j}^{t}$ 下面我们来一起看一下公式，下面来解释一下公式，借助于一个简单的网络。t是指的这里的网络中的第t层，t-1呢是t层前面的一层。比如这一层，我们定义为第t层，那么这一层的前一层显然就是t-1层。 如果大家不好理解的话，可以想象一下，当t为0时也便是输入层。当t为1时，便是第一个隐层，当t为大T，便是输出层，这样也许就会好理解一点。a是指的每一个节点的激活值，这里的j表示的是第t个层上我们的这个第j个节点的激活值，这里我们可以把j想象成为1 2…..的节点。如果是1的话，那么便表示第t层上第1个节点的激活值，如果是2的话，并表示第t层上第2个节点的激活值。这里的w是指的第（t-1）层上第k个的节点指向第t层上j这个节点。这里的a同样是激活值，它表示的是第（t-1）层上第k个节点的激活值，b表示第t层上第j个节点的偏移值。如果这里我们求的是第1个节点的激活值的话，那么显然这里也便是第1个节点的偏移值好了。 下面我们以第t层上第1个节点的激活值求值来举例说明一下这个公式。这里呢，如果我们要求第t层上第1个节点的激活值，那么显然我们要依赖于第（t-1）层上，每一个节点的激活值。那么公式应该如下$w_{11}^{t}a_{1}^{t-1}+w_{12}^{t}a_{2}^{t-1}+w_{13}^{t}*a_{3}^{t-1}+b_{1}^t$，最终呢，我们还要加一个$b_{1}^t$偏执，这个偏执得到的加权求和呢。我们再过一下激活函数f，也便得到了我们的激活值。我们把加权求和没有经过激活函数的部分呢定义为$z_{j}^t$。$a_{j}^t$实际上也就是f(z)。 好了，经过我们的讲述呢，我们发现当模型的w与b，也就是所有的参数固定之后呢，我们输入层的特征输入之后，我们第1层的激活值是由我们的输入与w、d参数得到的。第2层呢是由我们第一隐层的激活值呢，与w、b参数达到的，我们这个过程呢是逐步向前去传播。我们把模型根据输入得到输出的过程呢，叫做前向传播。 2.4 反向传播下面我们来学习一下DNN模型是如何学习我们的参数w与b的。 2.4.1 Our Target$\frac{\partial L}{\partial w_{j k}^{t}} \quad \frac{\partial L}{\partial b_{j}^{t}}$ 我们的目标是什么呢？我们的目标很简单，目标是求得损失函数，对模型中任意两层上两个节点连接的偏导，以及求得损失函数，对任意层上节点的偏置的偏导，如果我们得到了这两个偏导的话，我们发现我们就能将模型中的任意一个参数呢进行梯度下降，这样呢，经过数次迭代，我们最终就能将模型完成收敛，也便学习到了我们需要学的w与b。 2.4.2 What We Have$\frac{\partial L}{\partial a_{j}^{T}} \quad \frac{\partial L}{\partial z_{j}^{T}}$ 我们现在已知的是什么呢？我们现在已经知道了，是损失函数对于输出层节点激活值的偏导，这里的T表示的是输出层，为什么说我们已知道了，我们来详细的写一下公式，假使我们这里的loss函数呢是平方损失函数$(y-a_{j}^{T})^2$。对于每一个样本，我们的损失函数呢是这样的。我们发现以loss函数对于我们这里的输出层的输出激活值，去取偏导的话，很明显的，我们是能够得到答案的，也便是$-2（y-a_{j}^{T}）$。同样的这里我们知道了，loss函数对于最后一层节点输出激活值的偏导，也便知道了，我们这里的loss函数对于$z_{j}^T$的偏导，我们来推导一下。用一个链导法则。 $\frac{\partial L}{\partial a_{j}^{T}} \quad \frac{\partial a}{\partial z_{j}^{T}}$ a = f(z) 前一部分呢，是我们已经得到答案的，而后一部分呢，我们又曾经说过a呢，实际上等于我们的f（z）, 这里的f是激活函数，所以这一部分呢也很容易求的，所以我们说了我们知道了loss函数，对于最后一层节点激活值的偏导也便知道了loss函数对于z的偏导。 2.4.3反向传播的推导 \frac{\partial L}{\partial b_{j}^{t} } = \frac{\partial L}{\partial z_{j}^{t} } * \frac{\partial z_{j}^{t} }{\partial b_{j}^{t} }=\frac{\partial L}{\partial z_{j}^{t} }$z_{j}^{t}=\sum_{k} \mathcal{W}_{j k}^{t} a_{k}^{t-1}+b_{j}^{t}$ $\frac{\partial L}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} \frac{\partial z_{j}^{t}}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} a_{k}^{t-1}$ 下面我们来看一下是如何一步一步，通过我们已知的这些东西去进行推导的来看推导，这里我们的目标之一呢是求的loss函数，对于任意节点的偏移，它的偏导，好了这里我们应用一下链导法则，首先呢，我们对loss函数呢，求z值的偏导，既然呢对z值呢，求我们偏移的偏导。 大家应该对这个公式有印象，这个公式是前面我们说的前项传播的公式，所以这里我们看到z值对于b值的偏导呢，实际上是1，因为呢，在z对b偏转的过程中呢，前面这一部分呢相当于是常数。 $\frac{\partial L}{\partial b_{j}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} * \frac{\partial z_{j}^{t}}{\partial b_{j}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} $ $\frac{\partial L}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} \frac{\partial z_{j}^{t}}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} a_{k}^{t-1}$好了我们再来看一下，loss函数对于任意的网络中的w值，求偏导的整体过程，同样这里我们也采用链导法则，首先呢是loss函数对于z的偏导。z对于w的偏导。 $z_{j}^{t}=\sum_{k} \mathcal{W}_{j k}^{t} a_{k}^{t-1}+b_{j}^{t}$ 我们看到z对于任意的w的偏导呢，显然呢，是这里的上一层k节点的激活值$a_{k}^{t-1}$，所以我们看到经过我们的推导呢，我们这里只需要知道loss函数对于任意节点的z值，它的的偏导我们也便得到了最终想要的答案，但是我们这里已知的是我们的loss函数对于我们输出节点的z值，所以说如果我们可以利用倒数第2层节点z值与输出层节点z值之间的关系，逐渐的将loss函数对于输入层节点的z值的偏导，传递的倒数第2层，进而呢由倒数第2层传递到倒数第3层，这样逐一的反向传播，我们便可以得到loss函数对于任意节点z值的偏导，继而我们便得到了loss函数，对于模型参数的偏导，也便完成了我们这里的学习。 2.4.4 反向传播的核心部分$\frac{\partial L}{\partial z_{j}^{t-1}}=\sum_{k} \frac{\partial L}{\partial z_{k}^{t}} \frac{\partial z_{k}^{t}}{\partial z_{j}^{t-1}}$$z_{k}^{t}=\sum_{j} w_{k j}^{t} a_{j}^{t-1}+b_{k}^{t}$ $\frac{\partial z_{k}^{t}}{\partial z_{j}^{t-1}}=\frac{\partial z_{k}^{t}}{\partial a_{j}^{t-1}} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}=w_{k j}^{t} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}$ 好了下面我们来看推导的最核心的部分，我们说过现在问题的核心呢，变成了如何由损失函数对于输出层节点的。向前传播到倒数第2层，进而传播到倒数第3层，那么这里我们用一个普遍的公式，便是我们知道了第t层的z值的偏导，怎么由第t层z值的偏导呢去推导出第（t-1）层z值的偏导，如果我们知道了这个式子，问题也便解决了，普遍情况下的链导法的是损失函数对$z_k^t$求导，$z_k^t$对$z_j^{t-1}$求导即可。 为什么这里还有一个累加呢？我们借助于简单的网络来说明一下，我们看到这里上一层的任意节点，对下一层的每一个节点都有贡献，都有函数关系，所以我们在$z_k^t$对$z_j^{t-1}$，求偏导时，我们需要每一个节点都算一下偏导，所以这里出现了累加，好了我们将前向传播的式子呢，jk对调一下，我们之前讲前向传播时是求的第t层上第j个节点的a值或者z值。这里呢，我们是求第t层上第k个节点的z值，实际上我们只是把jk对调了一下即可。好了，我们这里呢，损失函数对第t层的z的偏导我们是知道的，因为呢，我们是从最后的T也就是输出层。往前传播的这里只需要求后一部分即可，我们采用链导法的，借助于激活值，我们看到呢后一部分是直接能够得到答案的，因为我们说过a等于f(z)，这里的f是激活函数。 同样呢，我们根据这个式子$\frac{\partial z_{k}^{t}}{\partial z_{j}^{t-1}}=\frac{\partial z_{k}^{t}}{\partial a_{j}^{t-1}} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}=w_{k j}^{t} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}$。前一部分呢，也是能够得到答案的，是这里的$w_{kj}^{t}$，既然这样的话，我们的整体流程也便窜了起来，由于我们这里损失函数对于z值偏等的过程中呢，是从后向前求的，所以我们这里的整体流程呢被称为反向传播。 2.4.5方向传播的流程 对应输入x，设置合理的输入向量 前向传播逐层逐个神经元求解加权和与激活值 对于输出层求解输出层损失函数对于z值的偏导 反向传播逐层求解损失函数对z值的偏导 得到损失函数对于任意节点z值的偏导，也变得到了w与b的梯度 好了，下面我们来看一下整体的反向传播流程是怎么样的，第1步对于从样本中获取的输入呢，我们经过哈希或Embedding等过程呢，设置好合理的输入向量维度，我们根据初始化的模型的参数w与b，逐层的前向传播，这样我们就得到了任意节点的加权和、z值与激活值a值。 然后我们对于输出层求解输出层损失函数对于z值的偏导，这我们是能够得到的，继而反向传播逐层求解损失函数对z值的偏导，这里我们是根据损失函数对$z^t$的偏导与损失函数对于$z^{t-1}$偏导之间的关系反向传播逐层得到的。最终呢，我们得到了损失函数，对于任意节点z值的偏导，也变得到了w与b的梯度，这里我们在推导的时候曾经详细的讲述过。 好了，我们得到了梯度之后呢，便完成了第1轮的迭代，之后呢，我们再逐次将反向传播的过程呢，不停的去进行，直到我们的参数收敛，模型也变训练好了。好了，本小节就到这里，本小节主要讲述了dnn的网络结构以及DNN模型求解的数学原理，下一小节我们将介绍wd模型的网络结构与数学原理。 三、wide and deep的网络结构以及数学原理介绍 开始本小节的课程之前，我们首先来回顾一下上一小节的内容，上一小节我们重点介绍了dnn的网络结构以及数学原理，那么本小节我们将重点介绍wd的网络结构以及数学原理下面开始本小节的内容，下面来看一下本小节的内容会从哪几个方面展开。 1、wd的物理意义，首先会给大家介绍一下wd为什么会优于我们之前单独介绍过的逻辑回归模型，以及上一小节介绍过的深度神经网络。 2、wd的网络结构，会向大家展示一下wd模型是如果构造的。 3、wd的数学原理，我们会一起看一下反向传播算法在wd上是如何进行的。 3.1 wd的物理意义论文：wide &amp; deep learning for recommender systems好了下面我们来看一下wd的物理意义。wd出自于谷歌的论文，这篇论文我会在附件中提供给大家，如果大家需要可以读一下这篇论文呢，详述了wd的优点以及wd的网络结构，包括5个在wd上做的一些实验的结果好了下面我们来介绍一下wd为什么会优于我们之前单独介绍过的逻辑回归模型以及深度神经网络模型。 Generalization and memorization 泛化与记忆首先呢，我们推荐系统当中呢有两个概念，泛化以及记忆，这里的泛化是指的我们推荐的多样性。记忆就比如说某人啊来到我们的推荐系统，一直点击宫斗类型的电视剧，那么这是我们的推荐系统也会一直给他推荐宫斗类型的电视剧，此过程我们称之为记忆，但是呢，这个人也有可能会喜欢历史类型的电视剧的多样性为泛化。我们如何将历史类型的电视剧的特征与该用户的特征在排序时呢，给他学到一个较高的参数呢，如果我们单纯的用逻辑回归的话，我们就需要组合特征，但是组合特征也有一个问题，如果我们的训练数据中没有该用户行为过历史题材电视剧的样本的话，我们的模型也是学不到组合特征对应的参数的，但是呢，深度神经网络DNN是可以的，我们曾经说过，深度神经网络呢可以将我们传入的基础特征进行高维的组合，在隐层当中呢，学出一些高维的特征，但是单独的深度神经网络也有一个问题，如果某用户的行为数据呢并不是十分的充分，那么我们学习的深度神经网络呢，可能会对该用户进行过于的泛化。推荐的结果呢，大多数是他不喜欢的好了，wd的便是能够结合逻辑回归的记忆能力，以及我们深度神经网络的泛化能力，很好的平衡了这两点。 3.2 wd网络结构 下面我们来一起看一下wd的网络结构，wd的网络结构呢分为两大部分，一部分的是wide部分，这一部分和我们之前介绍过的逻辑回归模型呢，有极大的相似性，比如我们这里输入三个特征，那么它同样呢是将这三个特征呢与对应的参数组合$w1x1+w2x2+w3*x3$，第2部分呢是deep部分，deep部分与我们曾经介绍过的深度神经网络呢，几乎是一样的，这里也分为输入层以及隐藏，当然了，我们这里也是全连接的。 这里唯一与之前所介绍过的有所不同的是，wd模型的输出呢是将(wide侧的参数与特征的加权和)与(deep侧最后一个隐层的输出)，做相加在一起经过激活函数，最终得到我们模型的输出。 这样的结构呢，能够保证我们在每一次反向传播的过程中呢，不仅更新地deep侧的参数，同时呢也会更新wide侧的参数，这样也就保证了我们所说的联合训练。通常情况下，我们将离散特征以及离散特征的组合特征放入到wide侧，而我们将连续特征的放入到我们的深度神经网络侧，对于一些字符型的特征，我们通常是先做一下哈希，再做一下Embedding，然后传入到deep侧。 3.3 模型的输出好了，下面我们来一起看一下模型的输出。模型的输出，包含两部分。 第1部分的是我们的wide侧的输出，这里的x便是我们wide输入的特征，这里的cross便是特征的组合。 第2部分同样的我们这里的deep侧。倒数第2层节点的激活值也就是最后一个隐层的激活值，与我们输出节点与deep侧相连的w的乘积，再加上偏执。 最终2部分的加和呢，要过一下我们的激活函数，这里的激活函数呢是阶跃函数，但是在deep侧的隐层之间的参数学习是我们采用的激活函数是修正线性单元。 3.4 WD model的反向传播大家一定要注意一下，好了下面我们来看一下反向传播是如何在wd上进行的。 wide参数的学习过程$\frac{\partial L}{\partial w_{w i d e j}}=\frac{\partial L}{\partial a^{T}} \frac{\partial a^{T}}{\partial z^{T}} \frac{\partial z^{T}}{\partial w_{w i d e j}}=\frac{\partial L}{\partial a^{T}} \sigma^{\prime}\left(z^{T}\right) x_{w i d e j}$ 首先呢，我们先来看一下wide参数的学习过程，我们这里采用梯度下降的学习方法，所以呢，我们这里只需要求得，损失函数对于w和任意参数的偏导，也便能够进行参数学习，我们来看一下公式推导，这里采用链导法则。损失函数对w偏导，实际上也就是损失函数对输出层激活值的偏导在乘以激活值，对z值的偏导，在乘z值对参数w的偏大。 损失函数对输出层激活值的偏导，无论我们是采用平方分式函数，还是我们采用对数损失函数，我们曾经都详细的讲过，这一部分的值应该是多少，这里不太赘述。 激活函数的导数计算：我们知道a等于f（z），这里的f就是激活函数，所以呢，这一部分也便是激活函数的导数。我们把$\sigma^{\prime}\left(z^{T}\right) $放进去即可， 最后一部分的，由于我们输出层的输出。实际上我们说过是有两部分的由wide侧以及deep侧，显然呢，我们这里对于wide侧的参数的偏导与deep侧没有关系，也便是我们这里deep侧参数对应的特征。好了，该部分的推导那就讲到这里。 WD model的反向传播$\frac{\partial L}{\partial z_{j}^{t-1}}=\sum_{k} \frac{\partial L}{\partial z_{k}^{t}} \frac{\partial z_{k}^{t}}{\partial a_{j}^{t-1}} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}=\sum_{k} \frac{\partial L}{\partial z_{k}^{t}} w_{d e e p kj}^{t} \frac{\partial a_{j}^{t-1}}{\partial z_{j}^{t-1}}$$z_{k}^{t}=\sum_{j} w_{d e e p k j}^{t} a_{j}^{t-1}+b_{k}^{t} \rightarrow t \neq T \quad z_{k}^{t}=\left(\sum_{j} w_{d e e p kj}^{t} a_{j}^{t-1}+b_{k}^{t}\right)+w_{\text {wide}} * X \rightarrow t=T$ 下面我们来看一下deep侧参数的学习过程，与我们之前讲述过的dnn网络的反向传播是一样的，我们这里的核心呢都是损失函数，对于输出层z值的偏导，逐渐的前向传播，我们逐渐的得到，损失函数对倒数第2层z值的偏导逐次向前，这里唯一不同的是什么呢？ 不同的是我们这里的前向传播的过程呢，如果当我们是最后一层时，我们这里会多出了一些wide侧的特征。 下面来看一下公式推导，这里我们在求上一层损失函数，对z值的偏导时，为什么这里会有一个累加呢？我们在上一小节曾经介绍过，这是因为（t+1）层上任意节点的激活值，都曾经被t层上第j节点贡献过，所以呢，我们需要累加。 好了，我们看到这3部分。 第1部分的，损失函数对于上一层节点的z值的偏导，这里我们是知道的，因为在最开始的时候呢，我们是知道，对输出层z值的偏导逐渐的向前传播，也便知道了t层。 第2部分，中间这一部分呢，根据下面我们两个式子，这两个式子我们分别发现的，虽然带我们的输出层的，我们有wide侧的特征，但是呢，并不影响我们这里求偏导，因为对于我们这里的偏导，wide侧的部分相当于常数，所以我们还是得到了相同的答案。 第3部分，最后一部分呢也是我们刚才说过的，a=f(z)。相当于呢，我们是激活函数的导数，也没有问题。我们得到了损失函数，对于任意层结点的z值的偏导。 $\frac{\partial L}{\partial b_{j}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} * \frac{\partial z_{j}^{t}}{\partial b_{j}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} $ $ \frac{\partial L}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} \frac{\partial z_{j}^{t}}{\partial w_{j k}^{t}}=\frac{\partial L}{\partial z_{j}^{t}} a_{k}^{t-1}$ 根据上一小节我们讲过的，此时我们便得到了损失函数，对于deep侧对于每一个偏执以及每一个w的偏导，这样我们便能够进行我们的梯度下降，进行参数学习了。好了，这就是wd模型的反向传播。 3.5server架构 下面我们来看一下，我们得到了最终的模型之后呢，我们是如何与推荐引擎呢进行交互的，这里由于我们采用的是TensorFlow呢，实现我们的wd模型，这里我们必须搭一个TensorFlow serving来提供我们的深度学习的rank服务。 此时呢，推荐引擎呢，需要发动请求到rank server，rank server与TensorFlow serving呢，进行一次交互，将请求呢透传的TensorFlow serving，TensorFlow serving得到的结果呢，返回给我们这里的rank server。rank server再将结果呢透回给我们这里的推荐引擎，来完成每一个item对该user的得分，进而完成排序，我们之前讲述过的浅层模型是rank server可以直接将我们得到的模型文件的load的内存当中，然后利用API呢，去提供打分。 好了，本小节的内容就到这里，本小节重点介绍了wd的网络结构以及数学原理，那么下一小节我们将代码实在wd模型。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>WideAndDeep</category>
        <category>逻辑回归</category>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>逻辑回归</tag>
        <tag>WideAndDeep</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第09章浅层排序模型gbdt]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC09%E7%AB%A0%E6%B5%85%E5%B1%82%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8Bgbdt%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第09章浅层排序模型gbdt本章节重点介绍排序模型gbdt。分别介绍梯度提升树以及xgboost的数学原理。并介绍gbdt与LR模型的混合模型网络。最合结合公开数据集，代码实战训练gbdt模型以及gbdt与LR混合模型。 gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的残差基础上进行训练。对弱分类器的要求一般是足够简单，并且是低方差和高偏差的。因为训练的过程是通过降低偏差来不断提高最终分类器的精度，（此处是可以证明的）。 GBDT(Gradient Boosting Tree)背景知识介绍： 由于GBDT(Gradient Boosting Tree)是由Boosting Tree，也就是很多个树模型的组合，首先了解什么是决策树，决策树是如果构建的。 GBDT数学原理与构建方法： 我们需要这个GBDT模型是如何将很多个树模型组合在一起，并且发挥了比一颗树更大威力的。 XGBoost数学原理与构建方法: XGBoost是陈天奇提出的GBDT一种改进与落地方法，由于其高性能以及优良的表现，在工业界广泛使用。 从头了解Gradient Boosting算法 ：https://blog.csdn.net/qq_36510261/article/details/78875278 GBDT(Gradient Boosting Decision Tree)入门（一）：https://blog.csdn.net/qq_38150441/article/details/80343626 一、GBDT(Gradient Boosting Tree)背景知识介绍介绍什么是决策树，并且向大家展示分类与回归树是如何构建的（决策树是如果构建的）。 1、什么是决策树树的数据结构大家都应该了解，树有根节点，左右子树，叶子节点等等组成。 什么是决策树呢？在决策树中我们可以这样认为，叶子节点对应的是模型的输出，其余节点每一个节点对应特征。而决策树呢，就是样本在该节点对应的特征由于取值的不同划分到左右两颗子树里面。同时呢，在左右两颗子树里面再利用对应的节点，将数据划分，最终呢会划分到某一叶子节点，便完成了模型的输出。 大体的流程就是这个样子，如下图。我们以上一小节的曾经举过的实例来简单讲解一下。 比如说这里根节点对应的特征呢，是给没给女朋友买礼物，如果给了的话，那么该样本数据呢就会落到右子树当中，如果没有没有给啊，那么显然呢，要么会落到左子树当中。那么再依据新的节点，这个节点对应的特征可能是说陪没陪女朋友是没有吃饭，如果是陪了的话那么继续往下，没有陪的话那么继续往下到左子树，这样呢，我们一直到叶的节点，叶子节点呢表示模型的输出，由于该实力呢是2分类问题，所以拿叶子结点的输出呢，便是0或1表示呢女朋友是否开心，当然了，树模型也可以是回归树，比如呢，我们在预测某人的身高这个问题上，那么最终的叶子节点可能会输出180、175cm, 相信经过上面的介绍，大家已经对决策处有了一个初步的了解。 下面我们以一组具体的样本来给大家详述一下决策树的构建过程。我们这里有一组训练样本，这个样本呢，有5条数据，然后呢有两个特征，是否在水下生活以及是否有脚蹼，当然了它的label呢是是否鱼类，是一个二分类问题，我们看到这里5组数据呢特征的取值都是0、1，一表示带水下生活，一表示有脚趾，好了，那么我们构建出的决策树应该是什么样呢？是这样的，根节点对应的特征是是否在水下生活？如果不是的话，我们发现没在水下生活的那么很明显对应的label，全都不是鱼类，那么这里也就直接到了叶子节点，也就不是。好了，如果是在水下生活的话，我们看到在水下生活，但是呢，有是鱼类也有不是鱼类的。所以我们这里需要再借助一个特征，也就是有没有脚蹼。我们发现在水下生活，并且有脚蹼的话，图片很明显都是鱼类。如果在水下生活，并且没有脚蹼的话便不是鱼类。这就是我们基于这五条训练数据得到的模型，那么这个模型是如何工作的呢？在新的样本输入进来的时候，比如说不在水下生活也没有脚蹼，那么我们的模型是如何给出预测的呢？首先呢，不在水下生活，直接就会预测不是鱼类，这便是决策书的工作流程，我们已经了解了什么是决策处，但是哪一个特征应该是优先特征帮我们把样本到左右两颗子树，以及整体的决策树构建的流程，我们还不是很清晰，下面来一起了解一下。 2、决策树构造原理 1、CART生成 2、回归树：平方误差最小化原则（CART生成算法构造回归树） 3、分类树：基尼指数（CART生成算法构造分类树） 决策树生成 生成算法 划分标准 ID3 信息增益 C4.5 信息增益率 CART 基尼指数 2.1、CART生成CART算法原理及实现： https://blog.csdn.net/hewei0241/article/details/8280490https://blog.csdn.net/gzj_1101/article/details/78355234 这里介绍的决策树生成树的算法是CART算法，分类回归树算法：CART(Classification And Regression Tree)算法。CART中的“C”表示分类，CART中的“R”呢表示回归，当然了，我们决策树生成的算法呢，还有很多，比如说ID3、C45等等等等，这里为了与后面的知识介绍，GBDT其实相连，所以这里我们选用了CART生成算法进行介绍。 CART生成算法，既可以构造回归树。当然了构造回归树我们采用的原则是平方误差最小化。CART生成算法，也可以去构建分类树。构造分类树时，我们采用基尼指数作为选取最优划分特征的依据。 下面我们分别来看一下回归数与分类数的构造。 2.2、回归树：平方误差最小化原则（CART生成算法构造回归树）2.2.1 回归树的函数表示首先呢，我们来一起看一下回归树的函数表示： f(x)=\sum_{m=1}^{M} c_{m} I\left(x \in R_{m}\right)这里的M表示一共有M个叶子节点，$R_{m}$表示m叶子节点对应的区域，如果我们输入的样本属于这个区域的话，这里公式中的I便为1。如果不属于，公式中的I便为0。也就是说我们的样本是属于这个区域的话，这里公式中的I便为1。如果不属于，公式中的I便为0。也就是说如果我们的样本是m区域，那么对应的输出为$c_{m}$。 {\sum_{x_{i} \in \mathcal{R}_{m}}\left(y_{i}-f\left(x_{i}\right)\right)^{2}} {c_{m}=\operatorname{ave}\left(y_{i} | x_{i} \in R_{m}\right)}$c_{m}$的定义需要满足在m区域的所有样本对应的模型的输出，与自己label差的平方和是最小的。显然$c_{m}$应该等于在m区域所有样本的label的平均值。 下面介绍回归树如何选取最优划分特征。也就是说哪一个特征应该放到根节点，哪一个特征应该放在第二层的节点。 2.2.2 最优划分特征j表示的是特征，s表示的是特征取值的一个临界分隔值。 如果这个特征取值$x^j$比这个临界分隔值s小的话，我们便划分到第一部分 如果这个特征取值$x^j$比这个临界分隔值s大的话，我们便划分到第二部分 对应第一部分和第二部分，有一个常数值，就是常数c，这个c是怎么定义的呢？c是属于区域所有样本的平均值。 倾向性得分。 区域的lable做差。 可以以18做划分 也可以 最优化的划分。 2.2.3 树的构建流程 遍历所有的特征，特征的最佳划分对应的得分，选取最小的得分的特征 遍历所有的特征，特征的最佳划分对应的得分，选取最小的得分的特征为最优特征，会将其放在根节点。 将数据依据此选取的特征划分分成两部分 基于此特征我们将数据分为两部分，也就是树的左右子树。 继续在左右两部分遍历变量找到划分特征直到满足停止条件 在左右子树里，我们再继续进行上面的操作，继续寻找最优划分特征。当然呢，在左右子树里，根节点特征被拿掉了，我们继续这一个流程，直到满足停止条件。在回归树当中呢，停止条件有两个。一是子树中只剩下一个特征。二是达到了我们之前设定的树的深度。 对应分类树来说呢，同样，如果说子树中label只剩下一种分类或者说特征只剩下一个，也是要进行停止的。 分类树与回归树的构建流程是一致的。但是分类树的最佳划分特征选取的是基尼指数。 2.3、分类树：基尼指数（CART生成算法构造分类树）基尼指数公式 {\operatorname{Gini}(D)=1-\sum_{k=1}^{K}\left(\frac{\left|C_{k}\right|}{|D|}\right)^{2}} {D_{1}=\{(x, y) \in D | A(x) \geq a\}, D_{2}=D-D_{1}} {\operatorname{Gini}(D, A)=\frac{\left|D_{1}\right|}{|D|} \operatorname{Gini}\left(D_{1}\right)+\frac{\left|D_{2}\right|}{|D|} \operatorname{Gini}\left(D_{2}\right)}对于某样本D的基尼系数是由上述公式求解的。公式中的$C_k$表示样本中的第k个分类它的样本数。分母表示总的样本数。如果这个样本只有一个分类，我们发现这个样本的基尼系数为0。这也是我们希望看到的。 如果我们将样本中的某特征以a为临界值进行划分，我们便得到了$D_1$,$D_2$两个部分。对于特征A以a为邻近值划分下的基尼指数了，也便是我们的第一的基尼系数加上第二的基尼系数，当然了这里都是带权的，这个权重呢，也便是我们划分的第一的样本除以总的样本的数目第二。第2个样本除以总的样本的数目。 下面我们以一个具体的例子来解释一下这个公式，这个实例呢，是我们之前介绍什么是二叉树的时候曾经用。 好了下面我们来看一下水下生活这个特征，它的基尼指数是多少呢？这里显然呢，水下生活这个特征只能以01为划分。这样呢，我们划分水下生活这个特征成的第一呢是占了3/5，然后这里面呢有2/3的呢，是1是鱼类这个分类，也就是1减去2/3的平方，再减去哪1/3的平方也就得到了4/9【1-（2/3）^2 - (1/3)^2 = 4/9】。我们看到零它占了2/5，但是呢，零对应的所有的内部呢都是一样的，也就是说呢，1减去1的平方也就成了0【1-(2/2)^2=0】，所以呢，对于水下生活这一个特征，它的基尼指数呢是12/45，≈0.26667。 我们再来。看一下是否有脚趾这样一个特征，它的基尼指数，我们看到呢，它将样本划分成了两部分，一部分呢占据4/5，然后呢，这里面呢它应该是呢，1-1/2的平方再减去1/2的平方也就得到了2/4【1-（1/2）^2 - (1/2)^2 = 1/2】，也就是1/2，然后呢，另一部分呢是1/5，然后呢乘以呢，是什么呢？1-1的平方也就是0【1-(1/1)^2】，最终呢他得到的是4/10。 显然呢水下生活它的基尼指数更低一点，它是零点二几，是否有脚趾的基尼指数是0.4。所以说呢，我们的根节点呢，应该用是否在水下生活。本小节的内容到这里就全部结束了，本小节重点讲述了GDP的背景知识决策数，讲述的决策处是什么以及决策处如何构建。 防止回归树过拟合：回归树剪枝（预剪枝和后剪枝），控制树的生长（如控制树深），在树每次生长的时候对一些特征进行采样，甚至可以加一些限制条件比如说在叶子节点上最少要多少个样本。叶子节点少于10个样本是不可以的。必须要在阈值样本数量才可以进行学习。 二、梯度提升树的数学原理与构建流程集成学习Ensemble Learning ：Bagging 和 Boosting相关的博文 Bagging和Boosting 概念及区别：https://www.cnblogs.com/liuwu265/p/4690486.html Bagging与随机森林算法原理小结 ：https://www.cnblogs.com/pinard/p/6156009.html Bagging（Bootstrap aggregating）、随机森林（random forests）、AdaBoost ：https://blog.csdn.net/xlinsist/article/details/51475345 bagging和boosting 总结，较全：https://blog.csdn.net/u014114990/article/details/50948079 集成学习Ensemble Learning与树模型、Bagging 和 Boosting、模型融合：https://blog.csdn.net/sinat_26917383/article/details/54667077 Boosting与Bagging主要的不同是：Boosting的base分类器是按顺序训练的（in sequence），训练每个base分类器时所使用的训练集是加权重的，而训练集中的每个样本的权重系数取决于前一个base分类器的性能。如果前一个base分类器错误分类地样本点，那么这个样本点在下一个base分类器训练时会有一个更大的权重。一旦训练完所有的base分类器，我们组合所有的分类器给出最终的预测结果。 本次的个性化推荐算法实战课程主要从boosting来进行梯度提示树的学习。 2.1 boosting 什么是boosting 大家好，欢迎来到本次的个性化推荐算法实战课程，开始本小节的课程之前，我们首先来回顾一下上一小节的内容，上一个小节我们重点讲述了决策处的构建过程，那么本小节我们将重点介绍梯度提升数的构建过程，下面开始本小节的内容，我们首先来看一下什么是提升方法，其实我反而有这么一种基本的思想，对于一些复杂的任务，无论是回归问题还是分类问题，如果许多专家得出的结论会比其中某一专家得出来的结论更加靠谱，这就是我们俗语说的三个臭皮匠顶一个诸葛亮的道理，那么问题来了，我们在实际的任务中呢学习一个非常非常良好的模型是比较费力的，而学习很多弱的模型呢是比较简单的，如果我们能将这学习到的许多热的模型组合起来，也就完成了我们提升方法的思想，也就通过群体决策来战胜了一个强大的模型，那么无论是对于分类问题还是回归问题，实际上呢提升方法呢，就是从弱学习模型开始出发，反复的学习，得到一系列的弱分类器或回归器将它们组合的，里面构成了强大的模型，大多数提升方法都是通过改变训练数据的权重或者说改变训练数据的值，来完成对于弱模型的学习，这样对于提升方法来说呢，有两个问题需要考虑。 1、第一个问题是每一个弱模型的学习过程中呢，我们怎么改变训练样本的值？或者说是训练样本权重的分布？2、第二个问题呢是如何将这些弱模型的组合成一个强模型？ 如何改变训练数据的权重 我们来分别看一下第一个问题如何改变训练数据的权重和值。我们以分类问题来举例，对于刚开始学习到的弱分类器，我们在下一轮学习做分类器的过程中呢，我们会减弱那些被上一轮分类器正确分类的样本，而去增加那些上一轮弱分类器分类错误的样本的权重，这样一来便可以对那些没有被正确分类的样本重点照顾，只有这样才能再将多个弱分类器组合的过程中呢，有希望战胜一个强大的分类器， 如何组合多个基础model第2个问题如何组合多个基础的模型，我们在训练得到了多个弱模型之后呢，不同的提升方法的处理是有所不同的，比如像业界比较著名的ada提升方法的便采用了加权表决的方法，具体的在分类问题呢，它会加大分类误差率较小的弱分类器的权重，使其在表决中呢起到更大的作用，那么对于梯度提升术呢，这里显然呢，它采用的是等权的加和也就是每一棵树呢，它起到的作用都是相同的，对于回归问题呢也是如此，下面我们来看一下提升树的具体的数学原理。 2.2 Boosting Tree 提升树模型函数 {f_{M}(x)=\sum_{m=1}^{M} T\left(x ; \boldsymbol{\theta}_{m}\right)}首先呢，我们看一下提升数的函数表示，这里呢，我来解释一下公式，这是每一棵树它的函数表示，那么这里的提升树呢，由M棵树来构成，每一棵树呢，大家都可以把它想象成上一节我们讲过的决策树，$\theta$是这一棵树的参数，好了，我们看到呢，每一棵树呢都是等权相加的，那么这样的一个提升树模型，我们是怎么样来进行学习的呢？ {f_{m}(x)=f_{m-1}(x)+T\left(x ; \theta_{m}\right)}这里呢，我们采用前项分布的算法，这是一种启发式的学习方法，他能够保证了在每一轮的学习当中呢，只学习一棵树的参数，这样有什么好处呢？我们以一个简单的例子来说明一下，如果提升树一共有十棵树，那么我们在学习第一棵树的时候也就是$f_1$,那么嘛，他显然就等于$t_1$，但是$f_2$他等于$f_1$加上$t_2$，这里呢，由于$f_1$已经变成了已知了，那么此时我们只需要学习$t_2$，它保证了我们每一轮的迭代都是可学习的。 {\boldsymbol{\theta}_{m}=\arg \min _{\theta_{m}} \sum_{i}^{N} L\left(y_{i}, f_{m-1}\left(x_{i}\right)+T\left(x_{i} ; \boldsymbol{\theta}_{m}\right)\right)}这样我们如何去学习$t_2$呢？只需要按照我们的损失函数。在损失函数上的我们只需要最小化这个公式就可以，$y_{i}$是样本对应的label,$f_{m-1}\left(x_{i}\right)$这是我们上一轮已经学习到的函数，这是$T\left(x ; \theta_{m}\right)$我们这一轮待学习的函数 这样启发式的方法保证了我们的可学习性，如果我们不采用启发式的方法，大家看一下这里我们的LOSS函数${f_{M}(x)=\sum_{m=1}^{M} T\left(x ; \boldsymbol{\theta}_{m}\right)}$应该是$f_{M}$，$f_{M}$的话这里相当于每一轮不是有一棵树的参数需要学习，而是有M颗树需要学习。那是根本没法学习的。 2.3 迭代损失函数$L(y, f(x))=(y-f(x))^{2}$$L\left(y, f_{m}(x)\right)=\left[y-f_{m-1}(x)-T\left(x ; \theta_{m}\right)\right]^{2}$ 下面我们来一起看一下迭代过程中的损失函数，如果我们的损失函数呢，采用我们之前经常讲的平方损失函数的话，那么第m颗树的学习就变成了下面这个公式，我来解释一下，这里的y是label，这里的$f_{m-1}(x)$是上一轮迭代迭代完成之后，我们的函数变成的样子，也就是说我们第m颗树的学习，只需要去拟合上一轮我们迭代完成$f_{m-1}(x)$之后这个模型对于最终样本的偏差度我们把这个称为残差。 举一个例子比如说我们要预测某人身高，那么在上一轮迭代的过程中呢，我们已经预测出了一米75，而这个label是1米80，那下一次我们第m个树的学习呢，只需要去拟合这5cm的差距，也就是说样本的label变成了5。而不是一米80。上面介绍了一个回归的例子，实际上对于我们的应用场景点击率过来也可以看成是一个回归问题。因为我们这里可以预估出他的点击倾向性，我们设定一个阈值，比如说点击倾向性大于等于了我们这个阈值，那么我们就认为是会点击，如果小于了我们设定的阈值我们就认为是不会点击。所以呢，同样可以让它去拟合这个label与这个点击倾向性之间的差，也就是残差。 2.4 提示树的算法流程初始化$f_0(x)=0$ 对m=1,2…M计算残差$r_m$,拟合$r_m$,得到$T_m$ 更新$f_m = f_{m-1} + T_m$ 下面我们来看一下提示树的算法流程。第一步初始化$f_0(x)=0$，对于第一颗树第二颗树直到第M个颗树，我们依次计算残差，并且用这颗树去拟合这个残差，并且得到相应这颗树。 比如说，我们第1轮的时候$f_0(x)=0$，所以说呢，残差还是label本身我们便得到了$T_1$，那么对于第2个树呢，我们首先计算残差，也就是label的减去$f_1$的值，我们去拟合这一个值得到$T_2$，以此类推，我们今天能够得到每一棵树，直到得到了M。那么我们每一轮训练完一棵树之后呢我们便更新这个公式。也就是说呢，$f_2$等于$f_1$加上$T_2$，这个时候呢，我们得到了f2，对于我们训练$T_3$的时候呢，首先呢，计算残差也就是label减去$f_2$，那么$T_3$的也便去拟合这个label得到了$T_3$，以此类推呢，我们这里f3也就得到了，最终呢，我们得到$f_M$，也便完成了整个提升树的训练，下面我们以一组具体的训练样本为例来详述一下提升树的构建流程。 首先来看一下训练样本，这里的训练样本呢，只有一个特征x，只有一个输出的y，x的分布呢是1~10，label是一些浮点数，我们首先来回想一下决策处的构建过程，我们首先要找到最佳划分的特征，由于这里只有一个特征的，我们只需要找到x的最佳划分，也便是我们第1棵树的根节点特征，这样的训练数据就会被分为左右两颗子树，我们只需要分别计算左子树的label的平均值和右子树label的平均值。也便得到了$T_1$。 我们首先来看一下，怎么来寻找最佳特征的划分？这里我们首先呢以1为划分点，我们看到了小于等于1的是一区域，大于1的是二区域，这里呢，将两个区域呢，分别变成了一区域[1]，二区域[2-10]，c1呢就是一区域所对应的label的平均值，也就是5.56，同样的c2是什么呢？C2是二区域[2-10]对应label的平均值，这里的是7.5，我们会得到一个倾向性的得分，这个倾向性的得分呢便是，一区域里所有的数据label与c1的差的平方和我们看到的只有一个数据，差的平方和是0。 然后呢2区里所有的数据label与我们c2的差的平方的和也就得到了15.72。这样的，我们遍历了所有的分割点我们看到的123一直到9，我们都是可以分割的，这样呢，我们得到了对优的分割的应该是6，也就是说小于等于6的一组，大于6的是另外一组，那么可是我们得到了$T_1$，$T_1$是什么呢？在特征小于等于6的时候呢，它的值呢是6.24，也就是说，所有label的平均值，在特征大于6的时候呢，它的输出呢是8.91，也是这个区域所有label的平均值，这里呢，我们的呢，f1就等于f0+T1，由于我们初始化f0=0。所以呢，我们得到了f1，这个时候呢，我们只需要计算一下残差，也就是说，此时呢变成了label减去f1，我们看到呢上面讲过的，label是5.56，减去6.24等于-0.68。, 以此类推这里我们得到的残差。 我们继续再找到队友划分，再完成这一棵树的学习也就达到了72 t2呢，这里它是以单为最佳划分的，它的输出分别是哪？负的0.52以及呢0.22，这时呢，我们便得到了f2，f2=什么呢？等于f1+t2，f1呢是这里的t1，所以呢，我们的f2呢也就变成了一个单段的分段函数，分别是特征小于等于3，此时呢输出了便是6.24与负的0.52的和以及特征大于3到特征小于等于6，此时的输出是6.24与0.22的和以及第3部分也面试，特征的大于6，此时输出了也是八年级。9一与0.22的和，那么我们继续整个流程，直到我们训练完大m棵树，页面结束了，我们提升速度的学习好了，了解了提升术的学习方法，我们来一起了解一下梯度提升术的学习方法，当我们的损失函数是平方损失或者指数损失的时候，每一步的优化呢是不那么困难的，但对于一般的损失函数而言呢，每一步的优化并不是特别容易，所以呢，梯度提升数呢，只是将我们的盘差变为了什么呢？变为了损失函数的负7度，在当前模型的曲子，那么我们下一棵树呢，只要去拟合这个值便得到了t小m好了，本小节的内容到这里就全部结束了，本小姐。人员予以构建流程，那么下一小节我们将给大家介绍插队故事的数学原理与构建流程。 2.5 梯度提示树残差的数值改变 r_{m}=-\left[\frac{\partial L\left(y, f\left(x_{i}\right)\right)}{\partial f\left(x_{i}\right)}\right]_{f(x)-f_{m-1}(x)}三、xgboost数学原理介绍开始本小节的课堂之前，我们首先来回顾一下，上一小节的内容，上一小节我们重点讲述了梯度提升数的数学原理与构建过程，那么本小节我们将带大家一起学习一下XGBOST的数学原理与构建流程，XGBOST的数学原理，陈天琪博士曾经公开过一份PPT，我也会在附录里提供给大家方便大家的学习。 下面开始本小节的内容，我们首先来看一下XGBOST的函数表示。 3.1 XGBoost模型函数$f_{M}(x)=\sum_{m=1}^{M} T\left(x ; \boldsymbol{\theta}_{m}\right)$$f_{m}(x)=f_{m-1}(x)+T\left(x ; \theta_{m}\right)$$\arg \min _{\theta_{m}} \sum_{i=1}^{N} L\left(y_{i}, f_{m-1}\left(x_{i}\right)+T\left(x_{i} ; \theta_{m}\right)\right)+\Omega\left(T_{m}\right)$ 同样呢，这里呢，也是有多棵树构成，我们知道多棵树构成的这种学习方法呢，也是使用我们前面讲述过的前项分布，同样呢，既然是前项分布算法，我们就需要优化出这个目标函数，这样呢，我们在每一次学习的过程中呢，就能够学习到一棵树，将这一棵树的参数学习好之后呢，我们再累加起来逐次迭代，这样呢，就能够学习到最终的M棵树。 这里与我们前面讲述的不同的是呢，对于每一棵树都有一个正则化项，也就是说当我们学习第小m棵树的时候呢，会设定一个小m这棵树的正则化，它表示小m这棵树，它的参数的复杂程度，具体的公式后面我们会详细介绍。 如果大家还记得上一节课我们在讲提升树时，对于小m这棵树，我们只需要你和label与$f_{m-1}$的残差即可构建出小m这个树，如果是梯度提升树的话，我们也只需要去拟合损失函数的负梯度，在当前的函数值，当前呢，指的是$f_{m-1}$。 3.2 优化目标的泰勒展开目标函数：$\arg \min _{\theta_{m}} \sum_{i=1}^{N} L\left(y_{i}, f_{m-1}\left(x_{i}\right)+T\left(x_{i} ; \theta_{m}\right)\right)+\Omega\left(T_{m}\right)$ 泰勒展开公式：$f(x+\Delta x) \approx f(x)+f^{\prime}(x) \Delta x+1 / 2 f^{\prime \prime}(x) \Delta x^{2}$ 根据泰勒展开公式优化的目标函数：$\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\Omega\left(T_{m}\right)$ $g_{i}=\frac{\partial L\left(y_{i}, f_{m-1}\right)}{\partial f_{m-1}}, h_{i}=\frac{\partial^{2} L\left(y_{i}, f_{m-1}\right)}{\partial f_{m-1}}$ 但是呢XGBoost采用了另一种思路，我们来看一下，首先呢，我们先介绍一下泰勒公式，相信呢，大家对这个公式呢，都不是很陌生，泰勒公式的二阶段展开是这样的$f(x+\Delta x) \approx f(x)+f^{\prime}(x) \Delta x+1 / 2 f^{\prime \prime}(x) \Delta x^{2}$。我们的优化目标，可以把这一部分($y_{i}, f_{m-1}\left(x_{i}\right)$)看成x，加号后面的部分$T\left(x_{i} ; \theta_{m}\right)$看成$\Delta x$，那么我们便可以按照泰勒公式进行展开。展开之后呢，我们的目标函数得到的是什么呢？ $\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\Omega\left(T_{m}\right)$ 第1部分显然呢是loss，在$f_{m-1}$, 这个函数下的loss，对于我们的优化目标来说呢，我们此时构建小m这棵树，那么log在$f_{m-1}$这个地方，它就变成了常数，常数呢对于我们的优化目标是不需要的，我们需要的是损失函数的导数在当前模型的值，以及损失函数的二阶导在当前模型的字，分别对应上面的函数的导数与函数的二阶导数，我们前面说过$\Delta x$呢，看成了这里的$T_{m}$。所以呢，我们便得到了优化目标。 3.3 定义模型复杂度$f(x)=\sum_{j=1}^{Q} c_{j} I\left(x \in R_{j}\right)$$\Omega\left(T_{m}\right)=\partial Q+0.5 \beta \sum_{j=1}^{Q} c_{j}^{2}$ 下面我们来看一下正则化项部分是如何定义模型参数的复杂度。XGBoost里，所有的树呢，都是回归树，我们在讲决策树的时候曾经讲过回归树的模型呢，可以这样$f(x)=\sum_{j=1}^{Q} c_{j} I\left(x \in R_{j}\right)$进行表示，这里呢一共有Q个区域，每一个区域的输出值呢是c，我们讲过c呢，实际上是在该区域所有的样本对应的label的平均值。 好了，我们把复杂度$\Omega\left(T_{m}\right)=\partial Q+0.5 \beta \sum_{j=1}^{Q} c_{j}^{2}$定义为所有的叶子结点的数目，以及呢，每一个叶子结点对应的输出的平方，当然了这里有两个正则化的系数。 这种定义方式的让我们联想到了曾经讲述过的逻辑回归的正则化，非常像我们曾经讲过的，l1正则化与l2正则化，这里的0.5呢与我们前面的泰勒展开呢，相对应我们来看一下，泰勒展开里呢，也有一个0.5，所以呢，我们后面呢，把0.5呢从我们的智能化系数当中的提取出来，我们看到这里的优化目标呢，是从每一个训练样本的角度去进行考虑的，为了接下来我们在构建树的过程中呢，好展开我们的思路，这里呢，我们将优化目标进行一下转化。看一下是如何转化的。 3.4 目标转化 {\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\Omega\left(T_{m}\right)} {\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\partial Q+0.5 \beta \sum_{j=1}^{Q} c_{j}^{2}} {\min _{\theta_{m}} \sum_{j=1}^{Q}\left[\left(\sum_{i \in R_{j}} g_{i}\right) c_{j}+0.5\left(\sum_{i \in R_{j}} h_{i}+\beta\right) c_{j}^{2}\right]+\alpha Q}1、本来优化目标函数： ${\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\Omega\left(T_{m}\right)}$ 这是我们本来的优化目标，它是按照样本的维度N 。我们首先呢把正则化项$\Omega\left(T_{m}\right)$写入进来。 2、目标函数： ${\min _{\theta_{m}} \sum_{i=1}^{N}\left[g_{i} T_{m}+0.5 * h_{i} T_{m}^{2}\right]+\partial Q+0.5 \beta \sum_{j=1}^{Q} c_{j}^{2}}$ 3、被转化后的目标函数：${\min _{\theta_{m}} \sum_{j=1}^{Q}\left[\left(\sum_{i \in R_{j}} g_{i}\right) c_{j}+0.5\left(\sum_{i \in R_{j}} h_{i}+\beta\right) c_{j}^{2}\right]+\alpha Q}$。 我来解释一下公式，之前的我们说过$T_m$每一个样本的输出呢，实际上也就是对应的区域$c_j$的输出，也就是这里的$c_j$。 每一个样本都会对应到每一个叶子节点，这里假使我们小m这棵树呢，一共有10个叶子结点，那么很明显，我们所有样本的输出都会归结到这10个叶子结点。 这里需要重点考虑一下损失函数的一阶导与二阶导。 ​ 只需要将样本是属于这一个叶子节点的一阶导，放到这一个区域$c_j$的前面，比如说c1在一个区域，我们的一阶导呢是说我这个样本如果它属于c1这个区域。那么，我的这个样本呢，它对应的一阶导便是其中的一个系数，我们将这个系数累加起来也就是这一部分。 ​ 同样的如果呢，如果这个样本是属于c1这个区域，我们将它的二阶导也累加起来当做它的区域。这里呢，合并了一下同类项，把我们的智能化系数呢也合并进来了。就变成了下面这个式子。 ​ 就是说遍历所有的样本，变成了遍历所有的叶子节点，相信大家也应该能够理解了。 可能这里大家对本次函数的一阶导二阶导的概念不是很清晰，我们以一个简单的例子来说一下，我们就以这个损失函数呢，是我们长距离的平方根式函数。那么它对于这个FM减1的一阶导应该是什么呢？应该就等于呢，也很简单，就等于那二位的WiFi，减去哪，FM点c，那前面还有一个符号，二跌倒是什么呢？二跌倒就是在这个的基础上呢，再对FM减1求一次等，很明显的就得到2，下面我们来一起看一下目标函数的最优解，我们这里定义了一下大j与大h，那么目标函数呢，就变成了如下这个样子，显然呢，这是一种ax的平方加bx的行驶。我们知道，但是这种形势下呢，如果a是大于0的话，他便是开口向上的抛物线，他的最小值的取代x=负的分母是二倍的a分子呢，是b的情况下，那么好了，这里同样是当我们的c呢取代，负两倍的这一部分，然后呢分子呢是大j的情况下，显然也就是当c等于这一部分的时候，整体的，我们的优化目标函数呢，将会取得最小值，最小值也变是这个式子，我们来一起看一下我们是如何使用目标函数的最小值，去选取我们的最优划分特征的。这是我们获得的目标函数的最小值。我们在cc布什里是依据如下这个公式来选取我们的最优化分特征的，这里呢，我简单解释一下，比如呢，我们这里以年龄这个特征为例，依据年龄呢以18岁痕迹，大于18岁的呢，挖到了左边，小于等于18岁的呢，挖掉了右边，那么这时呢，我们只需要将整体的目标函数的最小值分别减去左半部分目标函数的最小值，再减去右半部分目标函数的最小值，这里的鱿鱼多了一次化身的，会使燕子节点的数目增加1，所以呢，还需要减去一下郑德华的系数，我们遍历完所有的划分，比如说18岁为划分25岁为划分等等等等，得到的最大的收益便是该特征下最佳划分，那么我们遍历所有的特征。每个课堂对应的收益的最大值，也便是我们首先要放到根节点上的特征，进而呢不停的去构建我们的树，直到满足我们前面讲述过的停滞条件，我们来看一下caccabc，第1步呢，也是初始化f0，进而呢对于第1棵树以及之后的每一棵树呢，都应用我们刚才讲述过的，选择最优划分特征的方法呢，去构造树，对于构造完成的数量，我们将它并不是100%的放入到模型当中的，这里会有一个不长，这个不长的，在程序中的默认值是0.3，主要是为了防止过拟合，好了，这就是xz boss的模型的总体流程，那么本小节的内容到这里就全部结束了，本小节重点介绍了xx模型。与总体流程，那么下一小节我们将给大家介绍gbdt模型与逻辑回归模型的混合模型。 四、gbdt模型与逻辑回归LR模型的混合模型个性化推荐算法实战课程开始本小节的课程之前，我们首先来回顾一下上一小节的内容，三位小姐我们重点介绍了差距boss的模型，数学原理与构建流程，那么本小节，我们将重点介绍GB dt与lr的混合模型，下面开始本小节的课程，下面来看一下背景知识，本小节所讲述的GDP与lr模型的混合模型，是出自于当年Facebook所发表的一篇论文，他的题目呢？我贴在你这里，他的paper呢我也会付给大家，如果大家感兴趣的话可以读一下关于GDP与l2模型混合模型的构建思路，主要的原因是什么呢？是因为我们知道我们在构建逻辑，回归模型是需要繁琐的特征处理，如果大家还记得我们在讲逻辑回归模型的构建过程中的时候，我们。与特征的处理，要对特征进行分类，将特征呢分为连续特征与离散特征，对于连续特征，我们首先要统计它的分布，然后呢，按照区间段进行特征的离散化对于离散特征，我们需要统计它的值域，然后呢，进行我们的特征离散化，当然呢，这些特征处理完之后呢，我们还要进行组合特征的筛选，这个过程呢将非常的繁琐，而且呢组合特征需要手动来执行，那么我们并不能完全的发挥出组合特征的威力，所以呢，逻辑回归模型的训练呢是非常非常的繁复，而恰巧我们的树模型呢在连续特征处理时，是不需要进行这么繁琐的处理，我们只需要把连续特征输给数，然后呢数倍基于我们前面讲述的一系列的最优划分特征。去将最优的划分点给选取出来，也就相当于呢，进行了一系列的规则转化，最终呢，将所有的输出的落到某一叶子节点上，那么对于一旦特征呢，我们也是需要刚开始呢，将它进行零一编码，也就是弯号的编码编程，我们可以识别的零一特征，然后呢，在进行我们刚才说过的这一系列的操作，最终呢也是将某一样本的收入呢落到具体的某个燕子节点上，而我们的GDP模型呢，有很多棵树，每一棵树呢都是一样特征，转化到了某一个业主节点上进行输出，那么我们看到实际上在不同的数的输出当中的我们相当于把特征的变换成了一种新的特征，这一新的特征呢是经过我们数内部的结构去进行不断的筛选转化的。高危特征呢，我们再把它放到逻辑回归模型里去训练，得到我们的参数，这时呢，两者模型便能有效的结合，下面我们来一起看一下模型的结构，我们首先来看一下GB dt模型的第1棵树的结构，这里的树的深度呢是2，我们看到呢，他有四个燕子结顶，大家来看一下第2棵树的结构，同样呢，它的深度呢也是2也有4个叶子结点，但是呢，要么对于在数一当中的输出呢是落到了第2个一的节点，要么对于数2的输出呢是落到了第4个电子结点，此时呢，我们便可以进行高为特征的编码，第1个数的编码也就是0 100, 第2个书的编码也就是0001，大家这里对电的节点有概念吗？可以联想一下我们前面讲。绝色素的模型的输出输出的函数是你的小c，如果大家不进的话，我简单的写一下。这里的c也便是我们这里所说的燕子姐姐，由于这里的树的深度是2了，所以一共有4个区域，如果我们样本最终呢属于哪个区域，也就是我们这里我说的，你也没别的，所以呢，我们便将它对应的，落到第几个月的节点，这一位的编码程序，其余的编码成0，这样呢，我们便得到了高为特征，由于这里的我们一共有两棵树，所以呢，这里它都能围住，是吧，如果我们GB dt模型里数的数占多一点数的深度呢，也算深一点，那么懂得特征的维度呢，也会变得更高，这里我们得到了高危的转化特征之后呢，便可以用来训练我们的逻辑回归模型，这里需要训练的是w1到w8这8个参数好了，这边是我们的GDP。LI混合模型的网络结构，但是大家这里一定要注意一下这里的训练呢，不是联合训练，是我们的样本，首先训练得到数之后再将样本呢，通过数呢进行编码，得到我们的高为特征，用高为特征呢再去训练我们的lr模型，最终呢，我们在线上预测的时候呢，也是需要我们首先呢将数模型保存，然后呢，将lr模型的参数呢也保存样本过来之后呢，先通过数模型进行特征的转换，然后呢，再将转化完成的特征呢，与我们训练得到的参数呢，去得到我们最终的结果，下面我们来看一下gpdt模型与l2模型，混合模型的优缺点分析，首先来看一下优点，优点呢便是利用数模型的做特征转化，这样呢既可以节省了我们。为逻辑回归模型去手动构造特征的繁琐工程量，同样呢，又利用了数模型能够将特征的较好的处理，而不需要大量的手动工作量的特点，可谓是强强联合，但是呢，它同样也有缺点，它的缺点呢是两个模型的是分别训练的，并不是联合训练，并不是联合训练的，就没有统一的目标函数，没有统一的目标函数呢，理论的可解释性就不强，但是无论如何呢，这种尝试呢也是有创新性的，在我实际的工作经验中呢，发现l2与GDP的混合模型的效果是要比GB dt单独的模型以及l2单独的模型效果要更加好的，本小节的内容到这里就全部结束了，本小节重点讲述了GB dt与lr混合模型的相关制度。那么下一小节我们将带大家一起代码实战GDP模型的训练。 九、boosted Tree学习笔记Introduction to Boosted Trees：https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf boosted Tree中文学习笔记：https://zhuanlan.zhihu.com/p/26214650 面试重点： 支持向量机通俗导论（理解SVM的三层境界）SVM:https://blog.csdn.net/v_JULY_v/article/details/7624837 XGBoost 手推（重点，逢场必问） 通俗理解kaggle比赛大杀器xgboost https://blog.csdn.net/v_JULY_v/article/details/81410574 xgboost原理:https://www.cnblogs.com/harvey888/p/7203256.html 手推记录-XGboost:https://blog.csdn.net/u014472643/article/details/80658009 30分钟看懂xgboost的基本原理：https://zhuanlan.zhihu.com/p/73725993 机器学习竞赛大杀器XGBoost—原理篇：https://zhuanlan.zhihu.com/p/31654000 面试记录-蚂蚁金服-算法工程师（共四面）通过:https://blog.csdn.net/u014472643/article/details/81979749 ​ 机器学习算法中 GBDT 和 XGBOOST 的区别有哪些？https://www.zhihu.com/question/41354392/answer/98658997 线性回归正则化 —— 岭回归与Lasso回归： https://www.cnblogs.com/Belter/p/8536939.html 逻辑回归(logistics regression)： https://blog.csdn.net/jk123vip/article/details/80591619 https://blog.csdn.net/weixin_39445556/article/details/83930186 树集成优点： 1、不需要做数据归一化featureNormalize、幅度缩放scaling 2、同一条路径下是不同条件的组合，可以完成非线性的切分（同一条路径下可以组合不同的feature） 3、在工程上来说，树模型是可扩展的。假如加计算资源，可以加速他的计算。 树模型的最优划分属性是可以并行去计算的，那么可以加速他的计算。 FM模型 XdeepFM模型]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>GBDT</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>GBDT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第08章浅层排序模型逻辑回归]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC08%E7%AB%A0%E6%B5%85%E5%B1%82%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第08章浅层排序模型逻辑回归本章节重点介绍点击率预估模型，逻辑回归模型，以及选取实例数据集，从特征选择到模型训练、模型评估等几个方面来代码实战逻辑回归模型。 本章节重点介绍一种排序模型，逻辑回归模型。从逻辑回归模型的背景知识与数学原理进行介绍。并介绍样本选择与特征选择相关知识。最后结合公开数据集。代码实战训练可用的逻辑回归模型。 逻辑回归模型的背景介绍一、LR（logistic regression逻辑回归）背景知识介绍将会介绍什么是点击率预估、什么是分类模型以及LR模型的基本使用流程、LR模型的基本训练流程，从这几个方面介绍LR的背景知识。 1. 点击率预估与分类模型什么是点击率预估呢？ 相信点击率的概念大家都知道，在系统中，点击率 = 点击的数目 / 总展现的数目，而点击率预估就是针对特定的用户在当前上下文结合用户当前的特征给出的item可能被点击的概率，预估方法可以是一些简单的规则也可以是使用模型，目的就是得到不同的item在此时应该被展现的顺序关系。 点击率预估在推荐、搜索、广告领域都被广泛使用。 那么什么是分类模型呢？ 用一个简单的例子进行讲解：假如去菜市场买牛肉，这个牛肉可以称之为新鲜或者不新鲜，我们之前的判断就是根据这个肉的时间。假如有一个模型可以再牛肉到来的时候就给出标签，是新鲜或者不新鲜，那么这样的一个模型就是一个分类模型，而且是一个二分类，因为这里的label只有新鲜或者不新鲜。 当然，这个分类模型也可以是多分类，如果说这个label有很多个，那么便是多分类。我们这里讲的点击率预估实际也是一个二分类问题，因为，点了样本就是1，没点就是0。就在这两类之间，我们会给出每一个样本预估出它倾向1的概率，基于次概率的大小决定了此item的展现顺序。 2. 什么是LR？假设二维空间中有一些数据点，我们想用一条直线来拟合这些数据点经过的路径，这便是回归。但是，LR是一个分类模型，需要在样本进入模型之后给出分类标签。 所以LR对于回归得到的数值会进行一个处理，使之变成0,1这样的标签。这个梳理就是将得到的数值输入到一个函数中，这个函数就是单位阶跃函数，后面会详细讲解这个函数。 这里说的二维空间是只有一个特征的，用在之前讲解的牛肉是不是新鲜这个案例里，这个特征就是时间。那么如果扩展到三维空间中，可以再加入一个特征，比如说这个牛肉的含水量。那么这个时候，可能就不是用一条直线，而是用一个面来拟合整体样本经过的路径。 3. sigmoid函数：单位阶跃函数这个函数有一个特点，那就是输入为0的时候，值为0.5，但是输入&gt;0 的部分，很快便逼近于1，输入 &lt; 0 的部分，很快便逼近于0，所以称之为阶跃函数。 这样的函数，很少有在中间的部分，所以可以很容易的分辨出是1还是0，正好符合0、1分类模型的要求。 4. LR模型的工作流程前面介绍过LR模型的主体流程是：首先对数据进行一个拟合，不管是二维空间里 y = k x + b 这样的直线，还是三维空间里y = a1 x1 + b2 x2 + c 这样的平面，亦或是更高维度我们需要学习更多的参数。像y = k x + b 中的k、b，像三维空间里我们用平面 y = a1 x1 + b2 x2 + c 这里面的a1、b2、c这样的参数都是我们需要学习的。学习完这些参数之后，也就得到了模型。得到模型之后，用参数与输入的特征进行相乘，同时将得到的数值放入前面介绍过的单位阶跃函数中得到类别。 下面用具体的例子，详细介绍一下具体的工作流程： 这里是三个训练数据，训练数据的label就是女朋友是不是开心。我们看到这是一个二分类问题，女朋友开心，label就是1；女朋友不开心，那么label就是0。同时这里每一个训练样本都有三个特征，分别是买礼物、说早安、陪吃饭。 样本1 是买了礼物，说了早安，陪了吃饭，那么女朋友是开心的。 样本2 是没有买礼物，没有说早安，陪了吃饭，女朋友是不开心的。 样本3 是买了礼物，说了早安，，没有陪吃饭，女朋友是开心的。 这里的目标是通过这三个样本，学习出一个LR的模型，然后能够通过这个模型，帮助我们预测女朋友是否开心。我们需要学习的参数是什么呢？很明显就是 a x1 + b x2 + c * x3，这里的a、b、c这三个参数，在得到了这三个参数之后，在接下来的某一天，我们将买没买礼物，说没说早安，有没有陪吃饭带入到这个公式中，也便能够自己知道女朋友是否开心。 以上就是LR模型的工作流程 5. LR模型的整体训练流程（1）从log中获取训练样本与特征 在工业界中，样本与特征都不会是处理好的，我们需要自己从日志中，根据需要去提取。比如在推荐系统中，我们可能有展示日志，有点击日志，有基于点击统计User Profile,也有入库时就获得的item info信息。首先，我们需要判断，哪些展现，哪些点击是需要的，也就是样本选择。因为，有很多样本含有脏数据，我们需要去除掉。 其次，我们需要判断我们需要的是用户的哪些特征。比如说用户的年龄、性别，或者是item的哪些特征，比如item的种类、item的title、item的时长等等。这就是特征选择。 （2）模型的参数学习 获取了样本与特征之后，需要决定模型学习的学习率，是否正则化，以及选用哪一种正则化的方式，同样还有学习的方法等等参数设定。 得到了模型之后，同样需要进行离线评估。 这里面包含了模型本身的指标，还有模型应用到测试集中的指标，来看一下我们的模型是否可用。如果模型可用，需要将模型实例化。 （3）模型预测 这里的预测包含可能是将已经实例化的模型录入到内存中提供服务，也可能是基于已经实例化好的模型再搭建一个模型的服务。 预测部分需要将待预测的数据集带入到训练格式去抽取特征，抽取完特征的待预测的样本放入到模型中便能得到预测的结果。 6. LR模型的优缺点优点：易于理解，计算代价小 这个易于理解是指，我们在建模过程中我们把则认为对结果又影响的特征罗列出来就可以，比如说我们认为哪些因素会影响女朋友开心或不开心呢，那就是买没买礼物，说没说早安，有没有陪吃饭，有没有送回寝室…然后学习这些因素的权重就可以。 在推荐系统中，我们预估这个item能不能被user点击。同样也可以选取一些关键的特征，比如说item的历史点击率，item所属的类型，然后用户喜欢看的类型，这个item的长度等等。 由于LR模型是一个浅层模型，而且需要学习的参数的数目与特征的维度是一一对应的，比如说有100维的特征，那么就需要学习100个参数，所以计算代价是比较小的。 缺点：容易欠拟合，需要特征工程来补足模型容易欠拟合的缺点 欠拟合是一个专业术语，解释一下： 欠拟合表示模型没有从训练数据中学习到所有的规律。我们以女朋友是否开心为例，比如说陪吃饭，以及买礼物都不能单独的影响女朋友是否开心，也许这里需要一个交叉特征，比如陪吃饭和买礼物放在一起的一个特征。当这两样同时做了，女朋友才会开心，如果没做或者是只做了一样，女朋友都是不会开心的。 那么在这种情况下，我们发现，由于LR不能主动的去想学习这些交叉特征，所以需要我们大量的构造特征。这也就是说，特征工程来补足模型容易欠拟合的缺点。 二、LR算法数学原理解析将会介绍LR模型的函数表达式、损失函数以及梯度，并且介绍什么是正则化。（LR模型参数迭代的数学原理） 逻辑回归模型的数学原理 1、单位阶跃函数（sigmoid）单位阶跃函数及其导数 单位阶跃函数的函数表达式： f(x)=\frac{1}{1+\exp (-x)}当 x = 0 时，f(x) = 0.5 ; 当 x = 10 时，f(x) 接近于1 ，这也就是之前说过的，当x &gt; 0 的时候，会非常快速的接近于1 ；当x &lt; 0 的时候，会非常快速的接近于0 。这完全符合LR模型，对0-1分类时的要求。 下面再来看一下单位阶跃函数的导数： f^{\prime}(x)=\frac{\exp (-x)}{(1+\exp (-x))^{2}}经过简单转换，上述式子转换为： f^{\prime}(x)=\frac{1}{1+\exp (-x)} * \frac{1+\exp (-x)-1}{1+\exp (-x)}也就是 f(x) 的导数 = f(x) * (1 - f(x)) 2、LR模型的函数表达式LR模型分为两个步骤： 拟合数据点； 公式： w=w_{1} \times x_{1}+w_{2} \times x_{2}+\ldots+w_{n} \times x_{n}这里的w1，w2…是需要学习的参数，这里的x1，x2…是选取的特征。 用上一部分中的例子来分析，x1可能是陪吃饭，x2可能是送礼物等。 将第一步回归得到的数值带入到阶跃函数中，进而得到分类。 y=\operatorname{sigmoid}(w)也就是女朋友是否开心的倾向性，或者说item是否被用户点击的倾向性。 LR模型的函数表达式就介绍到这里，之前介绍个性化召回算法LFM的时候，曾经介绍过一种最优化的方法来学习参数—梯度下降。 梯度下降需要首先设定损失函数，进而得到梯度，完成参数的迭代。 下面看一下LR模型的损失函数。 3、LR模型的损失函数 \operatorname{loss}=\log \prod_{i=1}^{n} p\left(y_{i} | x_{i}\right)这个损失函数采用的是log损失函数，与之前介绍word2vec算法的损失函数是一致的。 这里没有用平方损失函数的原因是：这里LR模型需要两个步骤，第二步是将第一步拟合的值带入到单位阶跃函数中，如果此时使用平方损失函数的话，损失函数并不是下凸的，而且有很多个波谷，我们在梯度下降的过程中，很容易学习到并不是最低点的波谷，也就是不能学习到最小化的loss function。所以这里采用log 损失函数。 下面解释一下公式： i ：样本的数目。也就是说这里有n个样本。那么对于第1个样本呢，该模型下希望预测的概率最准。 p：概率，也就是本来是1的label，希望也是1；如果是0，预测成0 为了统一得到最大化的概率，当label是0的时候，我们就预测（1-这个条件概率），那么整体对于这个损失函数，我们直接最大化这个损失函数，便能够将参数学习到。 下面看一下条件概率： p\left(y_{i} | x_{i}\right)=h_{w}\left(x_{i}\right)^{y_{i}}\left(1-h_{w}\left(x_{i}\right)\right)^{1-y_{i}}这个条件概率就是刚才解释过的，如果这里y = 0，我们看到是后面这一部分起作用，那么也就是我们说的来预测（1-这个概率）。这里的w就是上一篇文章介绍的LR函数表达式的第一部分，也就是所有的参数与特征相乘得到的结果。 下面看一下，将条件概率带入到损失函数中，得到的： \operatorname{loss}=-\left(y_{i} \log h_{w}\left(x_{i}\right)+\left(1-y_{i}\right) \log \left(1-h_{w}\left(x_{i}\right)\right)\right)来看单一样本，这里不再关心 n 个样本。 我们来看单一样本，单一样本这里我们知道$h_{w}\left(x_{i}\right)^{y_{i}}$被log一下，$y^i$是可以提到前面去的；同时，相乘被log一下就变成了相加，就得到了上面式子。 之前说过，loss函数需要最大化，那么这里加了一个负号，所以上面式子中的 loss 需要最小化，也就是使用梯度下降法就可以。 这里再次重申，这里$x_i$表示，第 i 个样本对应的所有特征；这里$y_i$ 是第 i 个样本对应的label。如果想表示第 i 个样本的第一个特征，会在$x_i$的右上角标明$x_{i}^1$,以示区分。 4、梯度下面看一下loss损失函数对于参数w的梯度： 首先，这里选取参数的某一个，这里选择特征$x_j$对应的参数$w_j$来进行演示求偏导，这里应用链导法则（也便等于loss函数对于LR模型输出的偏导）： \frac{\partial \operatorname{loss}}{\partial w_{j}}=\frac{\partial \operatorname{loss}}{\partial h_{w}\left(x_{i}\right)} \frac{\partial h_{w}\left(x_{i}\right)}{\partial w} \frac{\partial w}{\partial w_{j}}这里$h_{w}\left(x_{i}\right)$表示：第 i 个样本的输入到 LR 模型中，我们给出的输出。它的公式是$f(x)=\frac{1}{1+\exp (-w)}$。这里的W表示为$w=w_{1} \times x_{1}+w_{2} \times x_{2}+\ldots+w_{n} \times x_{n}$，那么这里$\frac{\partial w}{\partial w_{j}}$就是$x_j$。也就是第i个样本的第j维度的特征。 损失函数 \operatorname{loss}=-\left(y_{i} \log h_{w}\left(x_{i}\right)+\left(1-y_{i}\right) \log \left(1-h_{w}\left(x_{i}\right)\right)\right)损失函数求导 看一下第一部分： \frac{\partial \operatorname{loss} }{\partial h_{w}\left(x_{i}\right)}=-\left(\frac{y_{i}}{h_{w}\left(x_{i}\right)}+\frac{y_{i}-1}{1-h_{w}\left(x_{i}\right)}\right)看一下剩余部分： 根据sigmod阶跃函数f(x) 的导数 = f(x) * (1 - f(x))。$\frac{\partial w}{\partial w_{j}}$就是$x_{i}^j$。 \frac{\partial h_{w}\left(x_{i}\right)}{\partial w} \frac{\partial w}{\partial w_{j}}=h_{w}\left(x_{i}\right)\left(1-h_{w}\left(x_{i}\right)\right) x_{i}^{j}带入梯度公式，得到： \frac{\partial l o s s}{\partial w_{j}}=\left(h_{w}\left(x_{i}\right)-y_{i}\right) x_{i}^{j}那么 i 样本对应的梯度已经得到了，如果这里有n个样本的话。同理，对每一个样本求得梯度，然后去 1/n ，就得到了平均梯度。 得到平均梯度之后，用梯度下降对这一维度的特征进行更新： w_{j}=w_{j}-\alpha \frac{\partial loss}{\partial w_{j}}当然，要对所有维度的特征都进行更新，即w1, w2…同样也是按照这种方式来进行更新迭代的，这里$\alpha$是指学习率。 四、正则化 什么是过拟合？ 过拟合就是模型对于训练数据过分的学习，对训练数据完美的适配。有时候训练数据并不能反应事情的本质。 eg.也许女朋友不开心是因为考试挂科了，假如给与我们的训练数据中，全都没有挂科，那么我们后面如何买礼物，如何陪吃饭，我们都会发现，女朋友都会不开心。我们便无法学习到真正事物的本质。也就是我们所说的泛化能力减弱。 完全为防止过拟合，就提出了正则化的概念。 常用的正则化方法有两种：L1、L2 首先看一下L1正则化的公式： \operatorname{loss}_{-} n e w=\operatorname{loss} +\alpha \sum_{i=1}^{n}\left|w_{i}\right|L1正则化的公式，是在原来的损失函数的基础上，将所有权值的绝对值求和，这种方式下，使模型的参数变得稀疏，会产生一部分为0的参数。物理意义上说，就是起作用的特征变少了，模型变得简单了。这样也就不容易过拟合了。 下面看一下L2正则化的公式： \operatorname{loss}_{-} n e w=\operatorname{loss}+\alpha|w|^{2}是在原来损失函数的基础上，加上每一个权重的平方和。因为要最小化损失函数，所以这里倾向于将每一个权重学的比较小。试想一下，如果某一个权重比较大的话，面对数据分布变化的特质数据会产生结果上的非常大的扰动。这也不利于模型的泛化能力。$\alpha$是指正则化参数。 三、样本选择与特征构建将会介绍模型训练中非常重要的一步，那就是样本的选择、特征的选择与处理。我们知道样本与特征决定了模型表现的天花板，而选择什么样的模型只是来逼近这个天花板。 回忆一下，8-1中给出的实例，当时用了3个样本，3个特征来演示LR模型的工作原理。但是，可能会有疑问，为什么只有3个样本？在实际的项目中，可能会有非常多的样本，其中有些样本是可以用的，有些样本是不可以用的，到底哪些可以用，哪些不可以用。包括我们有很多的特征，依据什么规则来判断是否对最终的结果有效都是下面要介绍的内容。 3.1、样本选择下面首先看一下样本方面的知识。 在点击率预估过程中，需要的样本是带有label的，也就是点击或者未点击，这是大前提。也就是说，每个用户的每次刷新，我们都能对应上item是否被点击。这么多的样本都是我们训练时候的有效样本么？ 当然不是！ 下面首先看一下样本的选择规则。 1、样本选择规则这里面主要包含两个因素，1. 采样比例； 2. 采样率。 ①采样比例 正负样本需要维持一个正常的比例，正常的比例需要符合产品的实际形式。比如说某个产品，用户三次到来就会产生一次购买，那么我们的正负样本就是1:2的比例。 当然，模型训练还有很多的采样规则，比如说在某些模型训练的时候，我们需要确保userid的样本达到平均水平，比如说最少要20个。这个时候，就需要做样本增强。对于该userid下的样本，我们需要给他一个特定的权重，来确保它虽然样本少，但是也能达到最低要求。 ②采样率 当模型没有办法用所有的训练数据的时候，必须设定一定的采样率。常用的随机采样的方法就是其中的一种。 2、样本过滤规则样本过滤规则有两个大方面： 结合业务情况 比如在样本选取时，需要去除爬虫带来的虚假请求，测试人员构造的测试 id 数据，作弊数据等等。还需要根据特定场景下模型的目标来保证样本选取的有效性。 异常点的过滤 常用的方法有基于统计的方法。举个例子，比如说，某个特征，就以某item被评论的数目这个特征为例，99%的评论数目都均匀的分布在0-5000之间，而top 1% 有几十万、几百万这种数量级的评分。对于这种数据，我们选取一个阈值，大于这个阈值的直接去掉，为什么呢？因为这会给我们在特征归一化的过程中，造成极大的样本分布不均。 还有就是基于距离的方法。比如说，某一样本数据与其余样本点的之间的距离，有80%都超过了我们所设定的阈值，这个样本就需要被过滤掉。 3.例子 下面以具体的实例来说明如何选取有效的数据来保证模型训练的目标。 这是某个推荐系统展现给用户的推荐列表，用户依次看到的是itemid1 、itemid2 ….itemid5，同时用户对着5个item分别做了不同的处理，用户点击了itemid1和itemid4，并没有点击itemid2、itemid3、itemid5。这时，我们在构建训练样本的时候，是不是这5个样本都需要呢？ 答案是否定的。 这里我们只需要前四个。为什么不要第5个呢？下面解释一下原因呢： 我们模型的最终学习目的是希望用户能够在最开始的位置发生点击，而不用下拉。所以，目标是将最终的推荐列表学习成1,1,0,0,0的形式。在这里我们发现，逆序对是0,0,然后1。对于最后的这个0，我们有两方面的原因不选择它作为训练样本，第一方面，我们不能确定用户是否真的看到了这个数据，对于以上的4条，我们可以确定用户真的看到了，因为最后的点击发生在第四条，用户想要点击到第4条，就需要下拉看到第4条数据；第二个原因，是因为这个数据对我们学习的目标是没有帮助的，如果选取还会增加负样本所占的比例。 结合刚才的分析，最终在这一次展现当中，我们得到了4条样本。 他们分别是位于位置1、位置2、位置3、位置4的样本，我们对每一条样本选取了一些特征，打上label。同时并没有选取位置5的数据。 3.2、特征方面首先对特征进行一个概述，特征如果按照数值类型可以分为连续值类型和离散值类型。举个例子，连续值类型，像item的平均观看时长可能是3.75分钟，4.28分钟等等。所以说，是不可穷举的。而离散值类型是可以穷举的，比如说某人的学历，就是小学、初中、高中、大学、研究生、博士等。 同样，按照统计的力度同样可以分为低纬度和高纬度，低纬度的特征包含像人的年龄、性别，高纬度的特征像这个人他过去30天喜欢什么样的电影，这个人历史上喜欢什么类型的电影等等。 根据数值变化的幅度，可以将特征分为稳定特征和动态特征，稳定特征就想item的历史点击率，而动态特征就想item的天级别的点击率。 特征的概述就概述到这里。 下面看一下如何做特征选择。 1. 特征的统计和分析首先需要知道特征的获取难度，比如说，我们想使用用户的年龄和性别这两个特征，我们发现用户画像中并没有这两个维度。如果需要的话，我们需要根据用户的行为建立一个模型，预估这两个特征。显然成本是较大的，就需要放弃。 第二个是需要看一下覆盖率，同样是用户的年龄和性别这两个特征进行举例。如果说发现能够获取到，但是在整体的覆盖率上不足1%，我们也是不能够用的。 下一个就是特征的准确率，我们发现视频的平均播放时长都只有几毫秒，显然这是违背常识的，那么这个特征也是不能够使用的。 在我们初步分析了哪些特征可以使用之后，我们到底选取什么样的特征来完成训练呢？ 2. 特征的选择主要分为两个大方面： （1）根据自己的建模常识，也就是说我们想预估一个目标的话，我们知道哪些特征与这个目标是紧密相连的。比如我们想预估这个item的点击率，那么很明显这个item的类别与这个用户喜欢观看的类别是强相关的特征。还有一些强相关的特征，比如这个item的历史点击率，在我们初步根据自己的常识选取了这么多的特征之后，我们训练出了第一版的模型。 （2）那么剩下的特征选择第二步就是基于模型的表现。我们训练完了基线版的模型之后，如果不能够满足我们对于目标的需要的话，我们应该不停的增减特征来发现增减特征对模型指标的影响。如果说减掉某个特征，反而指标变好的话，那么很明显这个特征就不应该是我们需要的。 实际上，在我们选定了特征之后，想要让模型能够识别这些特征，我们需要将特征变成数字。这也就是特征的预处理。 3. 特征的预处理特征的预处理往往包含三大步骤： （1）缺省值的填充 缺省值是指某些样本里的某些特征是缺失的，我们应该用什么样的规则来填充呢？ 业界常用的规则有：使用这个特征的众数，或者是平均数来填充。 （2）归一化 归一化是指将不同维度的数值特征都转化到0,1之间，这样有利于减少由于不同特征绝对数值的影响，对模型权重的影响。举个例子：比如说有一个特征是收入，这个收入可能是几千几万的大数据；还有一个特征是工作的时长，这个工作的时长可能每周都在40-60小时之间，这样可以发现数量值是不一样的。我们需要将他们归一化，这个归一化可以使用排序归一化，以及最大值归一化等等。 排序归一化是指：这一维度的特征按数字进行排序，排序最大的数字将变成1，排序最小的数字变成0。那么举一个例子：如果说一共有10个样本，那么这10个样本之间进行了排序，按照数字的大小，显然最小的对应0.1，第二小的对应0.2，依次类推，最大的变成了1，这样就归一化了0-1之间。如果样本的数目更大，就依此类推。 最大值归一化是指：我们统计出这一维度特征的最大值，然后让所有数字都除以这个最大值，显然这一维度的特征就会被归一化到0-1之间。 （3）离散化 特征的离散化并不是所有模型都需要的，但是逻辑回归LR模型是需要的。 下面以具体的例子讲解什么是离散化： 首先以一个连续值举例，这个值表示人平均每周工作的时长，这个人每周工作23小时，我们怎么离散化呢？ 首先需要统计一下，我们样本当中这一维度特征的分布，比如我们想四段离散化，这里我们就需要统计一下四分之一分位点。这里就是0-18小时是一个区间，18-25小时是一个区间，25-40小时是一个区间，40-无穷大是另一个区间。那么我们总共有4个区间，这4个区间我们发现23是位于18-25这个区间，那么就离散化成了 [0,1,0,0]。如果这个值不是23，而是60，显然特征就会被离散化成[0,0,0,1]。当然，这里也可以不被4段化，而是5段，我们只需要按相应的去统计就可以了。 下面再以一个离散值来举例，如果说一个人的国家是中国，系统中只有三个国家，那中国对应的实例化特征就是[1,0,0]，美国便是[0,1,0]。 四、代码实战LR之样本选择12]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>逻辑回归</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第07章综述学习排序]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC07%E7%AB%A0%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第07章综述学习排序综述学习排序的思路，并介绍工业界排序架构以及本课程重点讲解的学习排序模型。 一、什么是学习排序（Learn To Rank）？说起学习排序，首先介绍一下排序，排序是在搜索场景以及推荐场景中应用的最为广泛的。 传统的排序方法是基于构造相关度函数，使相关度函数对于每一个文档进行打分，得分较高的文档，排的位置就靠前。但是，随着相关度函数中特征的增多，使调参变得极其的困难。所以后来便将排序这一过程引入机器学习的概念，也就变成这里介绍的学习排序。 那么这里介绍的排序都是学习排序中的Pointwise，指对于单独的文档进行预估点击率，将预估点击率最大的文档排到前面。 所以特征的选择与模型的训练是至关重要的。 那么什么是学习排序呢？ 学习排序：将个性化召回的物品候选集根据物品本身的属性结合用户的属性，上下文等信息给出展现优先级的过程便是学习排序。 下面用一个例子进行展示： 假设这里有一个用户A，基于他的历史行为给出了召回，可能是很多种召回算法，经过合并之后得到的6个item[a,b,c,d,e,f]。经过排序，最终将这6个item的优先级固定为c、a、f、d、b、e。 得到优先级的过程就是由排序得到的。分别根据item本身的属性，以及user当前的一些上下文和user固定的一些属性，得到此时最佳的顺序应该是将c给展示，这样以保证最后的点击率最高。 二、排序在个性化推荐系统中的重要作用之前介绍过，在个性化的算法中后端的主要流程是：召回—&gt;排序—&gt;策略调整。 我们说过，召回决定了推荐效果的天花板，那么排序就决定了逼近天花板的程度。 1、排序决定了最终的推荐效果 用户看到的顺序基本就是由排序这一步骤所决定的，如果用户在前面的位置就能够看到自己感兴趣的物品，那么用户就会在推荐系统总停留较长的时间；反之，如果需要用户几次刷新之后，才能得到自己想要的物品，那么用户下一次将不会在信任推荐效果，导致在推荐系统中停留的时间较短。 在工业界中，排序这一部分分为三个步骤： （1）prerank（预排序） 也就是排序之前的部分，由于排序的模型由浅层模型切换到深层模型的时候，耗时在不停的增加。比如之前召回可以允许有5000个物品去做浅层模型，比如说逻辑回归，就是训练出一组参数，那么整体的打分过程耗时很短。但是，如果当排序模型切换到深层模型，比如说DNN，那么整体需要请求一次新的深度学习的服务，那么这5000个item去请求的时间显然是不能承受的。所以要先有一个粗排。这个粗排会将这5000个召回的物品进行第一次排序，将候选集缩小到一定范围之内。这样使排序模型的总处理时间满足系统的性能要求。粗排往往以一些简单的规则为主，比如说使用后验CTR或者说对于新的物品使用入库时的预估CTR等等。 （2）Rank（主排序） 主排序部分就是重点部分，现在业界比较流行的还有一次重排（ReRank）。 主排序模型的分类： a. 单一的浅层模型：浅层模型是相较于深度模型而言的，浅层模型的代表有LR(逻辑回归)、FM。 这一类模型在学习排序初期是非常受欢迎的，因为模型线上处理时间较短，所以它支持特征的维度就会非常的高。但是也存在很多问题：比如像LR模型，需要研发者具有很强的样本筛选以及特征处理能力，这个包含像特征的归一化、离散化、特征的组合等等。 所以，后期发展了浅层模型的组合。 b. 浅层模型的组合 这里比较著名的树模型的组合：GBDT组合，LR+GBDT等等。这一类模型不需要特征的归一化、离散化，能够较强的发现特征之间的规律，所以相较于单一的浅层模型具有一定的优势。 c. 深度学习模型 随着深度学习在工业界应用的不断成熟，以及像tensorflow等深度学习框架的开源，现在工业界大部分的主排序模型都已经切换到了深度学习模型。 （3）Rerank（重排序） 这个重排是将主排序的结果再放入一个类似于session model或者说是强化学习的一个模型里面去进行一个重排序，这种主要是突出了用户最近几次行为的session特征，将与最近几次session内用户行为相近的item给优先的展示，以便获取用户行为的连续性。 KDD2018 | 电商搜索场景中的强化排序学习：形式化、理论分析以及应用http://www.sohu.com/a/244970525_129720 由于单一item在重排模型的耗时要比主模型长很多，所以重排部分只是会影响主排序头部的一些结果，比如说top 50 的结果去进行一个重排。那么既然是这样的话，可以看到，最能影响结果的还是主排序模型。 三、工业界推荐系统中排序架构解析工业界中排序是如何落地的。 算法的后端主流程是：召回之后排序。 召回完item之后，我们将item集合传给排序部分，排序部分会调用打分框架，得到每一个item在当前上下文下，对当前user的一个得分，进而根据得分决定展现顺序。 下面看一下打分框架内部的构成： 首先会将每一个item以及user去提取特征，注意这里提取的特征要与离线训练模型的特征保持一致。提取完特征之后，我们向排序服务发出请求，排序服务会返回给我们一个得分，推荐引擎会基于此得分完成排序。经过简单的策略调整之后，展现给用户。 这里需要特别注意的是，排序服务与离线训练好的排序模型之间的通信。 如果是单一的浅层模型，像LR，那么可以直接将训练好的模型参数存入内存。当排序服务需要对外提供服务的时候，直接加载内存中模型的参数即可。像FM以及GBDT等等，我们只需要离线训练好模型，将模型实例化到硬盘当中。在在线服务当中，由于这些模型都有相应的库函数，他们提供了模型的加载以及模型对外预测等一系列接口，所以便可以完成打分。 但是，对于像深度学习的话，我们在训练完成之后，我们还需要提供一个深度学习的服务供排序服务调用。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>Learn To Rank</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>Learn To Rank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第06章个性化召回算法总结与评估方法的介绍]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC06%E7%AB%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第06章个性化召回算法总结与评估方法的介绍本章节重点总结前面几章节介绍过的个性化召回算法。并介绍如何从离线与在线两个大方面评估新增一种个性化召回算法时的收益。 一、个性化召回算法的总结这里会将之前介绍过的几种算法进行归类，并简短介绍每一种个性化召回算法的核心原理；同时演示工业界中多种召回算法共存的架构。 下面看一下之前讲过的个性化召回算法的分类： 基于邻域的：CF、LFM、基于图的推荐personal rank item-CF是item根据user的贡献，得到item的相似度矩阵，用户根据用户点击过的item的相似item来完成推荐。 user-CF是user根据item的贡献，得到user的相似度矩阵，用户将根据相似用户点击过的物品完成自己的推荐。 LFM是根据user-item矩阵，将矩阵分解，从而得到user与item的隐向量，将两个向量点乘得到的数值取top k 便完成了推荐。 psersonal rank是根据user与item的二分图，在这个二分图之间随机游走，便得到物品对固定用户的倾向度，把这个倾向度得分叫做PR值。那么取PR值的top k也就完成了用户的推荐。 基于内容的：content-based算法 content-base算法的主要流程是： 首先将item进行刻画，然后将user进行刻画，然后将user的刻画与item的刻画在线上推荐的时候串联起来。 基于神经网络(Neural network)的：item2vec item2vec首先根据用户的行为得到由item得到的句柄，根据训练语料得到item embedding的向量，得到这个向量之后就能得到item的相似度矩阵。从而根据用户的历史点击推荐相似的item给用户，也就完成了推荐。 下面看一下工业界中推荐系统中多种召回并存的架构： 后端算法的核心逻辑： 首先是召回，召回之后是排序，排序之后是策略调整，然后就将结果返回给web层。 接下来看一下，具体在召回阶段是如何多种算法并存的。 比如这里的算法A，召回了两个item，分别是a、b；算法B召回了3个item，分别是a、c、d；同理算法C召回了4个item，分别是e、f、d、c。 那么每一种算法召回的数目是如何确定的呢？ 这里有两种形式： 形式一：为了满足rank阶段的性能要求，这里指定召回阶段召回的数目，比如说50个，那么各种算法根据以往的表现来平分这50个，每一个算法有一个比例，比如说算法A是0.2，算法B是0.3，算法C是0.5。这样每一个算法也就有了自己召回的上限。 形式二：rank阶段毫无性能压力，我们给算法A写了多少个推荐都能全部召回，其余算法也是相同的处理。 在召回完成之后，我们需要进行一个合并。合并完成之后，我们得到item a~f，将重复召回的进行去重，但是也会给item a标记上它同时是属于算法A和算法B召回的。召回完成之后，这些item进入排序阶段。 二、个性化召回算法的评价在现有的个性化召回体系下，如果要新增一种个性化召回算法，需要知道这种个性化召回算法会对系统造成怎样的影响，是正向收益还是负向收益。所以需要从离线和在线两个方面对个性化召回算法进行评价。 离线评价准入： 也就是说，在我们新增一种个性化召回算法的时候，我们离线选取了一部分训练文件来训练个性化召回算法的模型。我们根据这个模型得到了一些推荐结果，同时有必要保留一些测试集。在测试集上评价推荐结果的可靠程度。这个可靠程度首先是要有一个预期，这个算法会给线上带来正向还是负向的收益。 当然，最终的结果仍然需要在线上生产环境中去评价真实的受益，也就是做A/B test。 如何在离线进行评价的？ 评价方法：评测新增算法推荐结果在测试集上的表现。 这里用一个例子来具体说明： 如果新增了某种个性化召回算法，对于user A我们给出了推荐结果a、b、c。恰巧这里我们获得了user A在测试集上的展现数据，就是a、b、c、m，那么在这里我们发现有3个是重合的，也就是a、b、c，那么这3个就是分母，如果我们在得到了用户A在测试集上的点击数据，这个点击数据恰好是a、c。我们发现这里的推荐结果是a、b、c是分母，然后有两个被点击了，那么a、c就是分子，最后的点击率就是 2/3。 如果这个数据是高于基线的点击率的话，那么就可以将这种推荐算法放到线上做A/B test(A/B测试)。 当然了，我们知道线下的评价结果与线上真实环境中的结果是有差异的，但是这种方式是能够给我们一个最基础的、直观的评判，是否可以准入到线上。 这里简单解释一下什么是测试集？ 举例：如果我们要使用itemCF这种个性化召回算法，那么我们首先需要计算item的相似度矩阵，我们这里以过去一周的用户的真实的展现与点击数据为依据来训练这个相似度矩阵。我们只使用周一到周五的数据来训练，周六、周日的数据便是这里的测试集。 在线评价收益：A/B test 线上的评价分为两步： （1）定义指标： 这里需要根据不同的情况，比如说在信息流场景下，我们最关心的就是点击率，平均阅读时长等等指标；但是在电商系统中，我们可能更加关注的是转化率及总的交易额度。 总之要根据自己的产品，来找到最能够评价产品的核心指标。 （2）生产环境A/B test： 往往采用以划分user id尾号的形式，比如说分出1%的流量在原来的个性化召回体系框架上增加要实验的个性化召回算法。实验几天之后，与基线去比较核心指标的优劣。如果收益是正向的，我们就保留。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>评估指标</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>评估指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第05章基于内容的推荐方法ContentBased]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC05%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E6%96%B9%E6%B3%95ContentBased%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第05章基于内容的推荐方法Content Based本章节重点介绍一种基于内容的推荐方法content based。从content based算法的背景与主体流程进行介绍。并代码实战content based算法。 第一部分：基于内容的推荐的理论知识部分一、个性化召回算法Content based背景介绍之前博文讲到的CF、LFM、Personal Rank都同属于基于领域的推荐。item2vec属于基于深度学习的推荐。 基于内容推荐不同于之前讲过的任何一种个性化召回算法，属于独立的分支。我们有必要去了解该算法出现的背景。 思路简单，可解释性强 任何一个推荐系统的初衷，都是推荐出用户喜欢的item。 基于内容的推荐，恰恰是根据用户的喜好之后，给予用户喜欢的物品。 eg：某一个用户经常点击体育类的新闻，那么在这个用户下一次访问这个网站系统的时候，自然而然的给用户推荐体育类型的新闻。那么对于推荐结果可解释性非常的强。 用户推荐的独立性 基于内容的推荐，推荐的结果只与该用户本身的行为有关系，其余用户的行为是影响不到该用户的推荐结果的。但是，联想一下，之前提到的无论是CF还是LFM、personal rank以及item2vec，其余用户的行为都会一定程度上，或多或少的干预到最后的推荐结果。 问世较早，流行度高 由于基于内容推荐思路的极简性，可解释性，所以它出现的非常早；并且，无论是在工业界，还是研究界，都最为一种基础的算法，流行度非常的高。 但是，任何事物都是有两面性的，基于内容的推荐不是说是完美的，它同样有一些非常明显的缺点。 （1）对于推荐的扩展性较差：也就是说，如果一个用户之前经常访问体育类型的新闻，那么在之后的推荐之中，倾向于在体育范围内不断地挖掘；很难完成跨领域的物品推荐。 （2）需要积累一定量的用户的行为，才能够完成基于内容的推荐。 二、Content-based算法的主体流程介绍实际上该算法的主体流程大部分不属于个性化推荐的范畴，应该从属于NLP或者用户画像的范畴。只有极小部分属于个性化推荐算法实战的范畴。 item profile：对item的刻画 针对于基于内容的推荐下，对item的刻画大体可以分为两大类：（1）关键词刻画；（2）类别的刻画。 比如，在信息流场景下，我们需要刻画出这篇新闻属于财经还是娱乐；那么在电商场景下也是一样的，我们需要刻画出这个物品它属于图书还是说属于母婴，具体的关键词上也会有这个图书是数据机器学习的还是人文情感的，这个物品是参与满减的，还是参与包邮的等等。 第一步完成内容的物品刻画之后，第二步需要对用户进行刻画。 user profile 传统范畴的用户画像是比较宽泛的，它不仅包含了用户的动态特征，还包含了它的一些静态特征。 而我们用在基于内容推荐里的更多的是聚焦在用户的长期、短期行为，进而通过行为的分析将用户感兴趣的topic、或者用户感兴趣的类别给予刻画。 那么，有了item的刻画，有了user的刻画，第三步就是在线上完成个性化推荐的过程。 online recommendation 给用户推荐他最感兴趣的一些topic，或者说一些类别。 假设某个用户经常点击明星新闻，当用户访问系统的时候，我们应该明星最新的新闻最及时的推荐给用户，这样点击率自然很高。 那么经过这三步流程的分析，可以发现：实际上，前两步更多的同属于NLP或者说是用户画像的范畴，第三步更多的是我们个性化推荐的内容实战范畴。 下面将每一部分的技术要点进行解析： （1）item profile a. Topic finding（Topic 发现）：首先要选定特征，这里的特征是title和内容主体的分词，那么得到词语的分词之后，针对于topic的发掘采用命名实体识别的方式。这个命名实体识别的方式可以去匹配关键词词表，那么得到了关键词之后，我们需要对这些关键词进行一定的排名，那么将排名最高的top 3 或者top 5给 item 完成label。 至于这里的排名，会使用一些算法和规则，算法诸如：TF-IDF，规则是基于自己的场景总结出来的修正错误case的一些规则。 b. Genre Classify（类别的划分）：首先选定好特征，这里同样是利用一些文本信息，比如说title，分词（正文中所有的去过标点，去过停用词）得到的词向量，这里词向量在浅层模型中可以直接one-hot编码，在深层模型中，首先可以先进行一个embedding，这里使用的分类模型主要是像LR、GBDT、CNN等等。 分类器的使用，是使用多种分类器，分别占不同的权重，然后对结果进行一个线性的加权，从而得到正确的分类。 以上是针对于文档的topic 发掘或者说是类别的分类进行的叙述。那么对于短视频，实际上现在引入了一些更多的特征，比如关键帧所对应图像的分类识别，以及音频所对应的语音识别后，文字的处理等一些有意义的尝试。 （2）user profile a. Genre/Topic（类别的划分）（Topic 发现）： 一个层面是用户对哪些种类的新闻或者是物品感兴趣；另一个层面是对哪些关键词感兴趣。 现在多是基于统计的方式，业界也在做一些尝试，比如引入分类器等等。 b. Time Decay： 注意时间衰减，不同时期的行为所占权重是不同的。 最终，针对于某个用户最想想刻画得到的结果是，用户对于不同种类item的倾向性，eg,比如这个用户对于娱乐倾向性是0.7，对于财经的倾向性是0.3。 （3）线上推荐部分 a. find top k Genre/Topic ； b. get the best n item for fix genre/topic 第一步，基于用户的刻画，找到用户最感兴趣的top k个分类，由于这top k个分类都是带有权重的，那么第二步，相应给每个分类得到n个最好的分类下的item. 这里有两点说明， a. 由于权重的不同，从种类下召回的数目是不同的。比如某人对财经感兴趣，对娱乐也感兴趣，但是对娱乐感兴趣的程度更高。那么对娱乐召回的数目就要多于财经召回的数目。 b. best的理解：这里的best对于不是新item来讲，就是它的后验CTR；如果是新的item，在入库的时候，都会给出一个预估的CTR，那么就用这个预估的CTR来作为衡量的标准。 第二部分：基于内容的推荐的代码实战部分]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>基于内容的推荐</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>基于内容的推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第04章基于深度学习的个性化召回算法item2vec]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC04%E7%AB%A0%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95item2vec%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第04章基于深度学习的个性化召回算法item2vec本章节重点介绍一种基于深度学习的个性化召回算法item2vec。从item2vec的背景与物理意义以及算法的主流程进行介绍。并对该算法依赖的模型word2vec数学原理进行浅析。最后结合公开数据集代码实战item2vec算法。 本章节重点介绍基于深度学习的个性化召回算法item2vec。分为两部分：第一部分，item2vec背景和物理意义，论文依据，算法流程，以及item2vec的依据的模型word2vec的数学原理等等理论部分解析。第二部分，根据示例数据，item2vec的算法流程，编程实战，训练模型得到item对应的向量完成推荐并分析推荐结果。 一、基于深度学习的个性化召回算法item2vec1、个性化召回算法item2vec背景与物理意义个性化召回算法item2vec背景 Item2item的推荐方式效果显著： 很多场景下item2item的推荐方式要优于user2item； item2item的推荐方式：在获取item相似度矩阵之后，根据用户的最近的行为，根据行为过的item找到相似的item，完成推荐，如itemCF。 user2item：根据用户的基本属性和历史行为等基于一定的模型，算出最可能喜欢的item列表写在KV存储中；当用户访问系统的时候，将这些item列表推荐给用户，像userCF、LFM、personal rank算法等都是这种方式。 NN model（神经网络）模型的特征抽象能力 神经网络的特征抽象能力是要比浅层的模型特征抽象能力更强，主要有两方面原因： （1）输入层与隐含层，隐层与输入层之间，所有的网络都是全连接的网络； （2）激活函数的去线性化； 基于上述，基于神经网络的item2item的个性化召回算法item2vec也就在这个大背景下产生了。 3、依据的算法论文：Item2Vec: Neural Item Embedding for Collaborative Filtering 核心内容1：论文首先介绍了item2vec落地场景是类似于相关推荐的场景。也就是说用户点击了某item a APP,那么推荐一款类似的APP给用户。 核心内容2：介绍了item2vec所选的model，也就是word2vec算法原理，文中采用了负采样的训练方法进行介绍，因为我们知道word2vec还有一种也就所说的哈夫曼树的方式进行训练。那么我们后面也用负采样的方式进行介绍word2vec的算法原理。 核心内容3：论文抽象了算法的整体流程。 核心内容4：论文将给出了与之前流行的item2item算法进行结果对比。 个性化召回算法item2vec物理意义在介绍item2item之前，先介绍一下原型word2vec。 word2vec 根据所提供的语料，语料可以想象成一段一段的文字，将语料中的词embedding成词向量，embedding成词向量之间的距离远近可以表示成词与词之间的远近。（word2vec原理中详细介绍怎么样做到可以表征词与词距离的远近） item2item （1）将用户行为序列转换成item组成的句子。 解释：在系统中，无论是用户的评分系统，还是信息流场景下用户的浏览行为，或者是电商场景下用户的购买行为。在某一天内，用户会进行一系列的行为，那么将这一系列的行为抽象出来。每一个用户组成的item与item之间的这种序列的连接关系就变成了之前所说的文字组成的一段一段的句子，那么这里的每一个word相当于这里的item。 （2）模仿word2vec训练word embedding 过程，将item embedding。 word embedding的过程只需要提供语料，也就是一段一段的文字，那么训练得到的word embedding可以表征词语义的远近，那么同样希望表征item之间内涵的远近。 所以，可以将第一步构成的item语料放到word2vec中，也能够完成item embedding。embedding完成的向量同样可以表示item之间的隐语义的远近，也就是说，可以表示item之间的相似性。 以上就是item2vec的物理意义。 个性化召回算法item2vec缺陷（1）用户的行为序列时序性缺失： 在介绍物理意义的时候，说过将用户的行为转化成由item组成的句子，这里句子之间词与词之间的顺序与按照用户行为顺序进行排列和不按照用户行为顺序进行排列的结果是几乎一致的。 也就是用户的行为顺序性，模型是丢失的。 （2）用户行为序列中的item强度是无区分性的： 这里比如说，在信息流场景中，观看短视频的50%或者80%或者100%，在用item组成的句子当中，同样都是出现一次的，而不是说观看100%就会出现2次。 再如，在电商场景中，可能你购买一件商品，或者说你加了购物车，都会出现一次；而不会说，你购买了就会出现两次。加了购物车，在句子当中出现一次。在item cf算法中，item 相似度矩阵计算 ，当时引入了用户行为item的总数，用户行为item的时间这两个特征，来分别将公式进行升级。所以在item2vec算法中，是没有这个消息的。所以是item2vec的缺陷之一。 2、item2vec算法应用的主流程（1）从log中抽取用户行为序列 按照每个用户“天”级别，行为过的item，构成一个完整的句子，这里的行为根据不同的推荐系统所指的不同。比如：在信息流场景下，用户点击就可以认为是行为；那么在评分系统中，我们可能需要评分大于几分；在电商系统中，可能希望用户购买，得到用户行为序列所构成的item句子。 （2）将用户序列当做语料训练word2vec得到item embedding 在训练过程中，word2vec代码不需要书写，但是有很多参数是需要我们具体设定的。 （3）得到item sim关系用于推荐 根据第二个步骤中得到每一个item所embedding的向量，可以计算每一个item最相似的top k个，然后将相似度矩阵离线写入到KV当中，当用户访问我们的推荐系统的时候，用户点击了哪些item，推出这些item所最相似的top k个给用户，就完成了推荐。 eg： 1、首先第一步：这是我们从推荐系统log中获得的，也就是说User A行为过item a、item b、item d，User B行为过item a、item c，User C行为过item b、item e。 2、继而我们需要将这些转化成句子。句子1就是a、b、d。句子2就是a、c。句子3就是b、e。这里我们已经没有了user之间的关系，只留下item组成的句子。 3、将句子放入到放入word2vec模型，这里就是一个输入（word2vec模型是一个三层的神经网络：输入层、隐含层、输出层，具体每一层的作用，公式原理后面详细介绍。） 经过word2vec模型的训练，会得到每一个item对应的embedding层向量。这里只写了item a [0.1,0.2,0.14……..0.3] ,item b [0.4,0.6,0.14……..0.3]。item c，item d,item e也是可以得到的。 4、得到item向量之后，就得到item的sim关系。基于item sim的关系，我们便完成了用户的推荐。 3、item2vec依赖模型word2vec介绍（连续词袋模型和跳字模型(skip-gram)）item2vec依赖模型word2vec的数学原理详细介绍 word2vec model 是围绕负采样的训练方法进行介绍，因为我们知道word2vec还有一种也就所说的哈夫曼树的方式进行训练（这里就不做介绍了）。 word2vec有两种形式：连续词袋模型和跳字模型(skip-gram) CBOW（continuous bag of words）连续词袋模型 skip gram()跳字模型 二、item2vec依赖模型word2vec之CBOW数学原理介绍1、CBOW网络结构 网络分为三层：输入层、投影层、输出层。 输入层：上下文；比如说这里有五个词W(t+2)、W(t+1)、W(t)、W(t-1)、W(t-2)。这里我们需要输入的训练数据是W(t)的上下文，即是W(t+2)、W(t+1)、W(t-1)、W(t-2)。 投影层：将上下文的词输入的向量加起来；因为给每个词都初始化了一个向量。比如说我们需要让它的长度是16。那么刚开始的时候，这些词W(t+2)、W(t+1)、W(t-1)、W(t-2)，再包括了W(t)都有一个初始化的向量。把这些向量加到了投影层。 输出层：当前词； 投影层与输出层之间是全连接，如果输出的这个词是这里的W(t)的话，希望最大化的就是这个概率。而除了W(t)，词典（词典指训练语料包含的所有的词）中所有的其他的词，其余词的概率我们都希望最小那个概率。 这就引申出一个问题，如果其余词都是负样本的话，负样本太多，训练太慢。 所以，采用负采样（后面介绍）的方法。这里我们先不要关心负采样的具体是怎么做的，后面我们会详细的介绍 也就是说，有了正样本W(t)与它的上下文，负样本是通过负采样得到的，我们希望最小化负样本所对应的模型的输出。这里实际上，最后一层的输出不仅仅是只有W(t)，实际上是有字典中每一个词。因为每一个词都有一个与输出层之间的全连接，这也是模型需要训练的参数之一。 然后，模型需要得到的是每一个词，我们初始化的那个向量，让它训练，根据我们传入的训练样本，训练完成的向量，就是最后模型输出。我们就是依赖每一个词对应的向量，完成item相似度矩阵之间的运算。 与传统的监督模型有所不同，传统的模型在训练完成之后，需要将它保存，然后对外提供服务，当我们传入真实样本的时候，希望得到一个输出值；而这里不是。下面我们来看下一中形式。 2、CBOW的数学公式 问题抽象 g(w)=\prod_{u \in w \cup N E G(w)} p(u | \operatorname{Context}(w))上式是想最大化的条件概率函数。 下面我来解释一下这个公式： $\text { Context }(w)$：某一词W(t)的上下文的词，已知上下文，想预测中间词。 可能有的同学对于这个训练样本还不是很了解，下面我举一个最简单的例子，有一句话是我是中国人，那么经过分词之后呢，变成了（我 是 中国 人）这么四个字也就是w1,w2,w3,w4，如果我们选窗口是1的话，在这里第1组的训练样本变成了（我 是 中国 人），其中这个”是”就是公式这里的w，它的上下文呢，w(t+1)呢是’中国’，w（t-1）是”我”这个词。 我们知道了”中国”，”我”这个词。如果u是W的话（这个u是公式中W”是”的话），则是需要最大化条件概率；如果是W的负样本（NEG(w)）（除了”是”，以外的其他词），我们想要把这个概率最小化，最小化这个条件概率$p(u | \text { Context }(w))$，也就是最大化$1-p(u | \text { Context }(w))$条件概率。那么无论是u是w,或者u是我们选择的负采样的负样本都能统一起来了，实际上这个式子由两部分组成。 这里的条件概率是指： p(u | \text { Context }(w))=\sigma\left(X_{w}^{T} \theta^{u}\right)^{L^{w}(u)}\left(1-\sigma\left(X_{w}^{T} \theta^{u}\right)\right)^{\left(1-L^{w}(u)\right)}这个式子由两部分组成： （1）当u=w时，也就是说label $L^{w}(u)$=1，起作用的是前一部分，因为后面的指数变为零次幂（$1-L^{w}(u)$=0），零次幂的话，后面部分就等于1了。起作用的是前一部分，我们是想最大化的正样本的概率。解释一下这里的$X_{w}^{T}$和$\theta^{u}$： $X_{w}^{T}$：CBOW的时候，投影层是将w对应的上下文的词向量加和。也就是我们这里举例子的”我”和”中国”对应的向量加和，便是这里的$X_{w}^{T}$。 $\theta^{u}$：隐含层（投影层）和输出层对应的词为u的时候，它们之间的全连接。 所以，想通过模型训练，让这两个参数$X_{w}^{T}$和$\theta^{u}$相乘得到的结果为1。（按照我们的距离就是16维的横竖向量相乘应该是一个常数，这里我们希望通过训练，让他最终相乘得到的数字是1） （2）负采样部分，也就是后面那一部分，我们这里负采样选取的负样本，希望这一部分是0。也就是希望这一部分$1-\sigma\left(X_{w}^{T} \theta^{u}\right)$为1，也就是最大化$1-\sigma\left(X_{w}^{T} \theta^{u}\right)$这一部分。 损失函数 $\operatorname{Loss}=\log (g(w))$ 这里采用对数损失函数，之前LFM采用的是平方损失函数。 公式带入： \text {Loss}=\sum\left(L^{w}(u) * \log \left(\sigma\left(x_{w}^{T} \theta^{u}\right)\right)+\left(1-L^{w}(u)\right) * \log \left(1-\sigma\left(x_{w}^{T} \theta^{u}\right)\right)\right)取对数之后，简单讲解一下，之前的累乘，由于我们取对数，就变成了累加。而之前里面是两部分相乘，，由于我们取对数，就变成了两部分相加。而且对数里面的幂次，可以直接变成了这里的系数。 对$X_{w}^{T}$和$\theta^{u}$求偏导，求完偏导之后，使用梯度上升法不断迭代这里我们这里需要的参数$X_{w}^{T}$和$\theta^{u}$，继而便能够去迭代每一个词对应的词向量。 梯度： $\frac{\partial L o s s}{\partial \theta^{u}}=\left(L^{w}(u)-\delta\left(x_{w}^{T} \theta^{u}\right)\right) x_{w}$ $\theta^{u}=\theta^{u}+\alpha * \frac{\partial L o s s}{\partial \theta^{u}}$ $\frac{\partial L o s s}{\partial x_{w}}=\left(L^{w}(u)-\delta\left(x_{w}^{T} \theta^{u}\right)\right) \theta^{u}$ $v(w_{context}) = v(w_{context}) + \sum_{u \in w \cup NEG(w)}\alpha *\frac{\partial L o s s}{\partial x_{w}}$ 梯度公式1： 首先对$\theta^{u}$求偏导得到了上述的结果。我们先不在此处讲解推导过程。推导过程和排序部分的逻辑回归的部分完全一样。（推导过程也并不是很复杂，只需要记住链式求导法以及加上激活函数。sigmod函数的导数是等于他的本身乘以（1-他的本身），即是s(x)*(1-s(x))）。这两个小技巧比较容易得到。 公式中，$L^{w}(u)$是label，值是1或者0，如果当这里的词是中心词的时候就是1，如果这里的词是负采样中选取的负样本，那么就是0。$\delta\left(x_{w}^{T} \theta^{u}\right)$这个是模型的输出,实际上是投影层对应的向量$x_{w}^{T}$，并且乘以$\theta^{u}$向量得到的一个值，我们在用激活函数激活一下，也得到了一个零一之间的值。这里的$x_{w}$便是投影层上下文向量的加和。 由于我们之前看到的损失函数里$x_{w}$与$\theta^{u}$是对偶的，所以loss函数对$x_{w}$的偏导也便是与上面对偶的形式，只不过括号外面是乘以$\theta^{u}$。 梯度公式2： 既然分别都得到偏导之后呢，我们如果去更新呢。对于$\theta^{u}$我们根据学习率去对于$\theta^{u}$更新就可以了。但是对于$x_{w}$更新，我们看到由于这里损失函数对$x_{w}$求偏导呢，是与这里的$\theta^{u}$有关系的。这个u我们知道它有可能是中心词，也有可能是负采样所选出来的负样本，所以他是一系列的，我们将这一系列的词，或者说是正负样本对。学习完之后我们得到一个总的梯度。得到这个总的梯度之后呢，是$x_{w}^{T}$的梯度，也就是$x_{w}^{T}$可以去更新它自己。这里$x_{w}^{T}$是所有上下文词向量的加和。这里也采用了上下文的每一个词都共享这个梯度，来更新自己的向量。 这里就是$x_{w}^{T}$对于正负样本对他的梯度的加和。然后我们将上下文中的每一词对应的词向量都以这个梯度去更新。 3、训练的主流程 选取中心词w以及负采样出NEG(w) 根据训练的语料，选取中心词w与上下文的词构成的正样本以及负采样选取出的负样本。 分别获得损失函数对于$X_w$和的$\theta^u$梯度 $X_w$：隐含层(投影层)的向量，是上下层向量的一个累加和； $\theta^u$：正负样本的每一个词都有一个$\theta^u$； 更新$\theta^u$以及中心词对应的上下文context(w)中的每一个词的词向量。 这里更新的时候需要注意： 以一个实例来说明： 中心词所对应的负样本，假使我们选了5个，加上中心词与上下文组成的正样本，这里一共有6个样本。在$X_w$的梯度的过程当中，实际上是6个梯度的加和，构成了它自己的梯度。在每一词所需要更新的$\theta^u$以及$X_w$的1/6的时候，首先先更新$X_w$的1/6。因为$X_w$是依赖于$\theta^u$的。如果这一次我们将$\theta^u$更新呢，再更新$X_w$的话，就错了。 故需要先更新$X_w$，在更新$\theta^u$。 三、item2vec依赖模型word2vec之skip gram数学原理介绍1、skip gram网络结构我们首先来看一下它的网络结构，这里同样有三层构成(输入层、投影层、输出层)。 与CBOW网络结构不同的是，这里的投影层与输入层完成是一样的，也就是说，投影层是W(t)的输入向量。 这里的核心目标是说，当W(t)已知的情况下，去预测它的周围词，我们将这个条件概率最大化就是我们的目标。所以，这里也是有两组参数需要更新的： （1）W(t)与词典中的每一个词所对应的这种全连接网络，这个参数需要更新； （2）W(t)本身对应的初始化的向量。比如说我们想要把每个词映射成16维，这个向量也是需要更新的， 这里与之前有两点不同： （1）这里每一次更新，只能更新W(t)一个词语对应的向量；而CBOW模型一次可以更新4个（4：针对上图）。也就是对应的这个上下文，如果我们上下文的窗口选的更长一点的话，可能会更新的更多一次。 （2）在对W(t)的每一个词进行上下文训练的时候，都需要对输出的词进行一次负采样，来构成训练的负样本。 2、skip gram的数学公式 问题抽象 G=\prod_{u \in \text { Contert }(w)} \prod_{z \in {u} \cup NEG(u)} p(z | w)skip gram是已知中间词，去最大化它相邻词的概率。 举个栗子：”我 是 中国”为例子，这个w就是”是”这个词。这里的z就是”我”或者”中国”他们对应的正样本，以及通过负采样选取的负样本，最大化正样本的输出概率，并且最小化负样本的输出概率，也就是最大化(1-负样本）的输出概率。 与CBOW的不同：CBOW的时候，是选取一次负采样；而这里对于中间词的上下文的每一个词，也就是”我”或者”中国”,每一次都需要进行一个负采样。 下面看一下条件概率： p(z | w)=\left(\delta\left(v(w)^{T} \theta^{z}\right)\right)^{L^{u}(z)} *\left(1-\delta\left(v(w)^{T} \theta^{z}\right)\right)^{1-L^{u}(z)}这个条件概率与之前的CBOW大体形式一样，也就是说当label $L^{w}(u)$=1的时候，我们还是希望最大化这个条件概率。当label $L^{w}(u)$=0的时候（看后半部分），我们需要最大化$(1-\delta\left(v(w)^{T} \theta^{z}\right))$,即最大化1减去模型输出。 这个条件概率与之前的CBOW，不同之处： （1）隐含层（投影层）输出的是中间词对应的词向量；而CBOW是输出的所有中间词上下文词向量对应的和； （2）这里的$\theta^{z}$：上下文的词，或者是上下文的词选出来的负样本的词与输出层之间的全连接；目标是中间词$v(w)^{T}$对应的向量以及$\theta^{z}$进行参数学习。进而得到中间词词向量的最佳表示。 损失函数 \text {Loss}=\sum_{u \in \text {Context}(w)} \sum_{z \in {u} \cup N E G(u)} L^{u}(z) * \log \left(\delta\left(v(w)^{T} \theta^{z}\right)\right)+\left(1-L^{u}(z)\right) * \log \left(1-\delta\left(v(w)^{T} \theta^{z}\right)\right) 采用log损失函数。将上述的式子log一下，两个连乘，变成了两个连加（之前的乘变成了加）。幂次也可以放到log的前面。 但是，可以发现如果按照这个loss去对$v(w)^t$或者$\theta^z$求偏导，在每一轮迭代的时候，只能够对词向量$v(w)^t$进行一次迭代。这里需要进行上下文窗口次的负采样才能对一个词的词向量进行迭代。显然，效率有些低。 在真正的word2vec实现的时候，需要变换一下思路： \text {G}=\sum_{w^c \in \text {context}(w)} \sum_{u \in {w} \cup N E G(u)} p(u|w^c)同样也是基于像CBOW一样的思想，已知上下文$(w^c)$的情况下，最大化中间词u。但是这里上下文$(w^c)$的每一个词都是独立的，不像CBOW是对上下文中所有的词向量进行累加。 下面重新看一下损失函数： \text {Loss}=\sum_{w^c \in \text {Context}(w)} \sum_{u \in {w} \cup N E G(u)} L^{w}(u) * \log \left(\delta\left(v(w^c)^{T} \theta^{z}\right)\right)+\left(1-L^{w}(u)\right) * \log \left(1-\delta\left(v(w^c)^{T} \theta^{u}\right)\right)这个log损失函数，如果我们忽略掉前半部分的累加。我们只看后面这部分。如果把上下文中的单个的词，变成了$w^x$的话，这一部分的损失函数与上一节讲过的GBOW的损失函数就一样了。也就是说每一次不是用所有上下文的累加和向量来进行梯度的学习。而是对每一个词单独学习梯度，并进行单独更新。实际上梯度形式也比较容易。只是比上一节求出来的多了一次累加。 Skip Gram训练主流程 对于中心词上下文词context(w)中的每一个词$w^c$，都需要选取一次负采样，也就是选取词w的正负样本，构造出正负样本； 计算loss对于theta以及$w^c$的偏导；($w^c$指的是我们举例的”我 是 中国”的”我” 或者”中国”)，计算偏导也是有顺序的，像CBOW首先更新loss对于$w^c$的偏导，因为这个偏导是最后我们需要更新词向量偏导的 1/n （n=负采样的数目 + 正样本 + 1）； 更新$w^c$对应的词向量； skip gram与CBOW相比，每一次负采样skip gram只能更新一个词对应的词向量；而CBOW在一次负采样，可以更新n（n指窗口）个词。 负采样的算法 假设词典（训练样本中所有的词）中有n个词，每一个词都会计算出一个长度，这个长度是一个0-1之间的长度，有的短，有的长，所有词的长度加起来的长度=1。 1、每一词的长度计算： \operatorname{len}(\text {word})=\frac{(\text {counter }(\text {word}))^{\alpha}}{\sum_{w \in D}(\text {counter }(w))^{\alpha}}分子：该单词在所有语料中出现的次数；幂次：相当于做了一个平缓；源码中这个平缓是3/4。 分母：语料中（字典中）所有词出现的次数的累加和。 显而易见这个长度是一个0-1之间的长度。而且所有的词的长度累加便是1。这样每一个词都有自己一个值域。比如说这里的w1（词1）可能是0-0.05，w2可能是0.05-0.11。每一个词的值域都是采用前开后闭的区间。 2、然后，初始一个非常大的数，源码中采用10^8，将0-1进行等分。然后每一段都会对应一个词（w1,w2,….,wn）的值域。 eg：比如这里的m1属于了w1,m2也属于了w1,但是m4和m5属于w2。 在每次进行负采样的过程中，会随机一个0-M之间的数，随机完数字之后，也就知道了随机的哪一个词。eg：随机到了1，那么m1就对应了词1（w1），那么也就是词1。如果我们随机到了4和5，那么m4和m5对应的是w2，那么就是词2是负样本。 注意：如果随机到的词和中心词相同，那么就跳过这次，再进行一次随机。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>item2vec</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>item2vec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第03章基于图的个性化推荐召回算法PersonalRank]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC03%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95PersonalRank%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第03章基于图推荐的个性化推荐召回算法基于随机游走的Personal Rank本章节重点介绍一种基于图的个性化推荐召回算法personal rank。从personal rank算法的理论知识与数学原理进行介绍。并结合公开数据集，代码实战personal rank算法的基础版本与矩阵升级版本。 基于图的推荐—基于随机游走的personal rank算法实现 博客第一部分：理论部分主要介绍该算法的背景、物理意义、数学公式推导，以及结合在大数据量实际推荐系统开发工作中为了满足训练速度等方面的要求，对数学公式的矩阵化升级。 博客第二大部分：主要介绍结合第一大部分的数学公式与虚拟log数据为大家编程实战该算法。 1、个性化召回算法Personal Rank背景与物理意义1、首先介绍基于图的个性化召回算法—personal rank的背景。 （1）用户行为很容易表示为图 图这种数据结构有两个基本的概念—顶点和边。 在实际的个性化推荐系统中，无论是信息流场景、电商场景或者是O2O场景，用户无论是点击、购买、分享、评论等等的行为都是在user和item两个顶点之间搭起了一条连接边，构成了图的基本要素。 实际上这里user与item构成的图是二分图，后面会介绍二分图的概念以及结合具体的例子展示如何将用户行为转换为图。 （2）图推荐在个性化推荐领域效果显著 2、二分图二分图又称为二部图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集（A,B），并且图中的每条边（i,j）所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集（i in A, j in B）,则称图G为一个二分图。 （如果有一种无向图，它的定点可以分成两个独立的集合，并且互不相交，且所有的边关联顶点，都从属于这个集合。那么这样的图可以称为二分图。） 则，推荐系统中，user、item恰好满足两种独立的集合，并且用户行为总是从user顶点到item顶点集合，所以由推荐系统中user和item之间构成的图就是二分图。 接下来结合具体实例讲解如何将用户的行为转化为二分图。 假设某推荐系统中有4个用户：A B C D，以及从日志（log）中发现对如下item有过行为： 即：user A 对 item a、b、d有过行为，userB 对 item a、c有过行为，userC对 item b、e有过行为，userD 对 item c、d有过行为。 首先将user、item分成两组不相交的集合，如下： 然后，将所有user 对 item 有过行为的进行连线，就可以得到二分图，如下： 此时问题也就抽象出来了，对于userA 来说，item c 和item e哪个更值得推荐？ 这里共有5个item，其中userA 已经对item a、b、d有过行为，这里行为是指信息流产品中的点击或者电商产品中的购买等表示user对item喜欢的这种操作。 那么personal rank恰恰是这么一种算法，它能够结合用户行为构成的二分图，对于固定用户对item集合的重要程度给出排序，也就是说将user A 没有对item c 和item e有过行为，但是personal rank算法可以给出item c 和item e对于user A来说，哪个更值得推荐。 下面从物理意义的角度来分析一下，从二分图上如何分析出来item集合对user的重要程度。 3、物理意义（1）两个顶点之间连通的路径数 如果要比较两个item顶点对固定user的重要程度，只需分别看一下user到两个item顶点的路径数，路径数越多的顶点越重要。 （2）两个顶点之间连通的路径长度 同样路径数的情况下，总路径长度越短的顶点越重要。 （3）两个顶点之间连通路径经过顶点的出度 这里解释一下出度的概念：出度是指顶点对外连接边的数目。如user A对item a、b、d有过行为，即为有条连接边，则A的出度为3。如果前两项都相同，则两个item对固定user 的重要程度则比较经过顶点所有的出度和，如果出度和越小则越重要。 结合刚才所举的具体二分图的例子，给大家介绍—对于user A来说，item c 和item e哪个更值得推荐？ 2、Personal Rank算法example解析 例子分析 1.分别有几条路径连通？ 首先看A-c 之间有几条路径连通：分别是A-a-B-c，A-d-D-c 两条路径连通。 再来看A-e 之间有几条路径连通：A-b-C-e一条路径 从这一角度出发，可以知道 c 比 e 重要。 2.连通路径的长度分别是多少？ 首先看A-c 之间有几条路径连通：分别是A-a-B-c，A-d-D-c ，长度都为3 再来看A-e 之间有几条路径连通：A-b-C-e长度为3 3.连通路径的经过顶点出度分别是多少? 首先看A-a-B-c这条路径：A出度是3，a出度是2，B出度是2，c出度是2 再看A-d-D-c这条路径：A出度是3，d出度是2，D出度是2，c出度是2 再看A-b-C-e这条路劲：A出度是3，b出度是2，C出度是2，e出度是1 实例中这里我们物理意义得到的结果。接下来使用程序来完成person Rank算法的时候同样可以得到相同的结论。 虽然 e 的出度和更小，但是由于1中 c 有两条路径，且1的优先级更高，所以还是应该推荐 c。 3、Personal Rank算法公式解析personal rank是可以通过用户行为划分二分图为固定user得到item重要程度排序的一种算法。 1.算法的文字阐述 随机游走算法PersonalRank实现基于图的推荐对用户A进行个性化推荐，从用户A节点开始在用户-物品二分图random walk，以alpha的概率从A的出边中，等概率选择一条游走过去，到达该顶点后（举例顶点a），由alpha的概率继续从顶点a的出边中，等概率选择一条继续游走到下一个节点，或者（1-alpha）的概率回到顶点A，多次迭代。直到各顶点对于用户A的重要度收敛。 后续我们在实现person rank算法的时候用不同的alpha值来做实验，熟悉是Google的pageRank算法的童鞋们可以发现PageRank与person rank算法有极大的相似性。只不过PageRank算法没有固定的起点。 2.算法的数学公式 PR(v)=\left\{\begin{matrix} \alpha * \sum_{v^{\sim} \in i n(v)} \frac{P R\left(v^{\sim}\right)}{\left|o u t\left(v^{\sim}\right)\right|} \ldots\left(v !=v_{A}\right) & \\ (1-\alpha)+\alpha * \sum_{v^{\sim} \in i n(v)} \frac{P R\left(v^{\sim}\right)}{\left|o u t\left(v^{\sim}\right)\right|} \cdots\left(v=v_{A}\right) & \end{matrix}\right.把不同item对user的重要程度描述为PR值。 为了便于理解，同样适用A作为固定起点。user A的PR值初始化为1，其余节点的PR值初始化为0。 这里使用 a 节点和 A 节点阐述公式的上半部分和公式的下半部分： 首先看公式的上部分，根据person rank的算法描述，节点a只可能是节点A与节点B,以alpha概率从他们的出边中等概率的选择了与节点a相互连的这条边。 具体来看，从user A出发有3条边，以3条边中等概率的选择了节点a连接的这条边，以1/3的概率选择连接节点a；user B以1/2的概率选择了连接节点a。 结合阐述看一下公式的上半部分：对于不是A节点的PR值，也就是 a 的PR值，那么首先要找到连接该顶点节点，同时分别计算他们PR值得几分之几贡献到要求节点的PR值。那么A将自己PR值得1/3贡献给了 a ，B将自己PR值得1/2贡献给了 a，分别求和，乘alpha，得到 a 的PR值。 接下来看下半部分：如果要求A节点本身的PR值，首先知道任意节点都会以（1-alpha）的概率回到本身，那么对于一些本来就与A节点相连的节点，比如这里的 a 节点或者 b 节点，它们除了以（1-alpha）的概率直接回到A以外；还可以以alpha的概率从自己的出边中等概率的选择与A相邻的这条边，比如这里的 a 节点，可以以1/2的概率选择回到A节点，所以就构成了下半部分的前后两个部分。 经过分析可以发现，personal rank算法求item对固定user的PR值，需要每次迭代在全图范围内迭代，时间复杂度在工业界实际算法落地的时候是不能接受的，所以要让尽可能多的user并行迭代。结合之前许多其他算法训练的工业界实现，很容易想到矩阵化实现，下面看personal rank算法的矩阵化实现。 3.算法抽象—矩阵式 $r=(1-\alpha) r_{0}+\alpha M^{T} r$ $M_{i j}=\frac{1}{|o u t(i)|} j \in \operatorname{out}(i) e l s e 0$ 假设这里共有m个user，n个item。 R矩阵是m+n行，1列矩阵，表示其余顶点对该固定顶点的PR值。当然得到了这个，就得到了固定顶点下，其余所有顶点的重要程度排序，这里只需要排出m个user节点。只看n个item节点对该固定顶点的排序。也就得到了该固定顶点下推荐的item。 r0 是m+n行，1列的矩阵，负责选取某一节点是固定节点，它的数值只有1行唯一，其余行全为0。唯一的行，即为选取了该行对应的顶点为固定顶点。那么得到的就是该固定顶点下，其余节点对该固定节点的重要程度的排序。 M 是 m+n行 * m+n列的矩阵，也就是行包含了所有的节点，列也包含了所有的节点。 它是转移矩阵，数值定义如下：1.第一行第二列的数值距离，如果第一行对应的数值顶点由出边连接到了第二列的顶点，那么该值就为第一行顶点的出度的倒数；如果没有连接边，那么就是0。 我们很容易联想到，第一个式子包含了刚才所说的非矩阵化的personal rank的公式的上下两部分。 \left(E-\alpha M^{T}\right) * r=(1-\alpha) r_{0}上述公式是本部分中第一个公式，移项、合并同类项之后得到的。 r=\left(E-\alpha M^{T}\right)^{-1}(1-\alpha) r_{0}该公式是上一公式两个同时乘以$\left(E-\alpha M^{T}\right)$转置的之后得到的。 刚才说过，r0是m+n行，1列的矩阵，它能够选取固定的顶点，得到固定顶点的推荐结果。如果将r0变为（m+n）*（m+n）的矩阵，也就得到了所有顶点的推荐结果。 由于得到的推荐结果是考虑顶点之间的PR值的顺序关系，并非一个绝对数值，所以可以将$(1-\alpha) $舍去。所以$\left(E-\alpha M^{T}\right)^{-1}$即为所有顶点的推荐结果。每一列表示该顶点下，其余顶点对于该顶点的PR值。 但是，需要注意的是，每一个user能够行为的item毕竟是少数，所以这里的M矩阵是稀疏矩阵，$\left(E-\alpha M^{T}\right)^{-1}$同样也是稀疏矩阵。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>基于随机游走的Personal Rank</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>基于随机游走的Personal Rank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第02章基于邻域的个性化召回算法LFM]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC02%E7%AB%A0%E5%9F%BA%E4%BA%8E%E9%82%BB%E5%9F%9F%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95LFM%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第02章基于邻域的个性化召回算法LFM本章节重点介绍一种基于邻域的个性化召回算法，LFM。从LFM算法的理论知识与数学原理进行介绍。并结合公开数据集，代码实战LFM算法。 个性化召回算法LFM（latent factor model）算法综述 包含了LFM背景，结合LFM的实例与求解方法。 以及LFM算法的应用场景。 LFM（latent factor model）理论知识与公式推导 LFM在建模后如何定义损失函数 如何迭代到模型收敛得到模型参数 LFM（latent factor model）算法与CF算法的优缺点比较 从理论的体系的完整度，离线训练复杂度 在线推荐的可解释性 完成LFM与CF算法的优缺点比较 个性化召回算法LFM（latent factor model）算法综述对于基于邻域的机器学习算法来说，如果要给一个用户推荐商品，那么有两种方式。 一种是基于物品的，另一种是基于用户的。 基于物品的是，从该用户之前的购买商品中，推荐给他相似的商品。 基于用户的是，找出于该用户相似的用户，然后推荐给他相似用户购买的商品。 但是，推荐系统除了这两种之外，还有其他的方式。例如如果知道该用户的兴趣分类，可以给他推荐该类别的商品。 为了实现这一功能，我们需要根据用户的行为数据得到用户对于不同分类的兴趣，以及不同商品的类别归属。 LFM—隐语义模型，属于协同领域。 LFM算法的背景提到协同领域，很多人首先想到的就是item CF与user CF，那么这里说到的LFM与这两者又有什么区别呢？ 首先简单回忆一下item CF与user CF。 item CF：主体是item，首先考虑的是item层面。也就是说，可以根据目标用户喜欢的物品，寻找和这些物品相似的物品，再推荐给用户。 user CF：主体是user，首先考虑的是user层面。也就是说，可以先计算和目标用户兴趣相似的用户，之后再根据计算出来的用户喜欢的物品给目标用户推荐物品。 那么LFM呢？ LFM：先对所有的物品进行分类，再根据用户的兴趣分类给用户推荐该分类中的物品。 那LFM具体的意义是什么呢？ 为了方便大家理解，这里通过item CF再进一步说明。 item CF算法，是将item进行划分，这样一旦item贡献的次数越多，就会造成两个item越相近。举个例子来说，就是当你看你喜欢的电视节目的时候，为了不错过精彩的内容，你广告部分也会看；这时，后台就会统计，你看了电视节目，也看了广告。这样就可能分析出电视节目与广告比较接近。 然而，事实上两者并不一样，如果我们知道两者属于不同的tag，我们不会将他们放到一起，进行降权处理。但是建立大量的tag体系就需要消耗大量的人力标注打标签，人力标注不适用。继而需要机器学习完成分类。在0-1搭建个性化推荐系统算法中显然是不切实际的。那么LFM算法就应运而生。 LFM是根据用户对item的点击与否，来获取user与item之间的关系，item与item之间的关系。 我的理解就是，LFM不仅会考虑item，也会考虑item。 2、什么是LFM算法LFM算法输入：user对item的点击矩阵 LFM模型参数：每一个user的向量表示和每一个item的向量表示。 方式：用user矩阵和item矩阵的矩阵乘 拟合 user对item的点击矩阵 我们知道行向量乘以列向量是一个常数。完美情况下，user向量和item向量的相乘可以拟合点击矩阵的数值。我们可以看出本模型是从user对item的点击矩阵得到的user-item的向量。所以lfm也是矩阵分解的算法的一种。 LFM算法举例 输入：user对item的点击矩阵（1代表点击、0代表未点击） user对item的点击矩阵 item1 item2 item3 user1 1 0 1 user2 0 1 0 user3 1 1 0 输出： ​ user1:[0.123, 0.325, …, 0.623], … ​ item1:[0.214, 0.034, …, 0.241], … user和item的向量维度是自定义的，用user与item作内积即可判断user对item的偏好 图片左边是点击矩阵，user对item的行为矩阵（点击表示为1,没有点击表示为0）。图片右边是模型收敛得到的是use和item的向量。对于这个维度可以是之前设定的。维度可以理解为有哪一些特征会影响uers对item的喜好程度。特征例如：item title,是否含有图片，小清新的、吉他伴奏的、摇滚等等这些特征会影响用户的偏好。这里比如来说统计出来有7个特征。那么在模型设置的时候就可以把维度设置为7，得到的向量显然就是user1，Item1都会表示7维度的向量。那么将user1，item1的转置乘起来的话应该是一个常数。如果将每一个user和item的向量乘起来可以和点击矩阵的常数无限接近的话。那么这个模型的效果也就越好。 3、 LFM算法的应用场景举例（1）获取user的item推荐列表（计算用户toplike） 模型得到了user和item的向量，针对于用户没有被展现的item，我们可以计算出他的一个用户对item的倾向性得分。取top即toplike，后直接完成用户对item的喜爱度列表，写入离线即可完成对在线的推荐。 （2）获取item间的相似度列表（计算item的topsim） 得到item的向量可以用很多表示距离的公式包括cos等等，计算出每一个item的相似度矩阵，该矩阵可以用于线上推荐。当用户点击item之后，给其推荐与该item的topsim item。 （3）挖掘item间隐含topic挖掘（计算item的topic） 根据得到的item向量，可以用聚类的方法，如K-means，层次聚类等等，取出一些隐含的类别。也就是一些隐含的topic，能将item分成不同的簇，推荐时按簇推荐 LFM（latent factor model）理论知识与公式推导本小节主要从数学上重点介绍LFM，主要从建模方法、迭代、收敛等方面认识LFM算法 （1）LFM建模公式 p(u, i)=p_{u}^{T} q_{i}=\sum_{f=1}^{F} p_{u f} q_{i f}p(u,i)表示user-item对，如果user点击了item，那么p(u,i)=1，否则p(u,i)=0。模型的最终输出为user向量和item向量，即$p_u$和$q_i$。其中F表示维度，也就是上一小节阐述的user对item喜欢与否的影响因素的个数。 那么具体如何得到$p_u$和$q_i$呢？我们用机器学习中监督学习的思想解决。在F设定好之后，$p_{u}$和$q_{i}$可以用随机数进行初始化，初始化之后，如何进行迭代呢？ 这里采用的方法是梯度下降。分别从损失函数对user向量的偏导和损失函数对item向量的偏导，以及user向量对item向量的迭代来分别介绍。 （2）损失函数 LFM loss function l o s s=\sum_{(u, i) \in D}\left(p(u, i)-p^{L F M}(u, i)\right)^{2}解释公式：p(u,i)是训练样本的label，也就是说如果user点击了item，那么p(u,i)=1，否则p(u,i)=0。后面项是模型预估的user对item喜好程度，也就是前面所说的模型产出的参数p_{u}和q_{i}转置的乘积。这里的D是所有的训练样本的集合。 可以看到如果模型预估的数值与label越接近的话，损失函数数值越小，反之则越大。这里为了防止过拟合，增加了正则化项。如下公式，前半部分是将模型对于user-item对的喜好程度，并进行展开，是前面建模公式中讲到的，得到如下： \operatorname{loss}=\sum_{(u, i) \in D}\left(p(u, i)-\sum_{f=1}^{F} p_{u f} q_{i f}\right)^{2}+\partial\left|p_{u}\right|^{2}+\partial\left|q_{i}\right|^{2}这里$\partial$是正则化系数，是用来平衡平方损失与正则化项，这里采用的是L2正则化，正则化目的是为了让模型更加简单化，防止由于$p_{u}$和$q_{i}$过度拟合训练样本中的数据使模型的参数过度复杂，造成泛化能力减弱。 （3）LFM算法迭代 损失函数对$p_{uf}$和$q_{if}$的偏导：$\frac{\partial l o s s}{\partial p_{u f}}=-2\left(p(u, i)-p^{L E M}(u, i)\right) q_{i f}+2 \partial p_{u f}$ $\frac{\partial l o s s}{\partial q_{i f}}=-2\left(p(u, i)-p^{L F M}(u, i)\right) p_{u f}+2 \partial q_{i f}$ 损失函数对$p_{uf}$和$q_{if}$的偏导之后，我们应用梯度下降的方法可以看到： $p_{u f}=p_{u f}-\beta \frac{\partial l o s s}{\partial p_{u f}}$ $q_{i f}=q_{i f}-\beta \frac{\partial l o s s}{\partial q_{i f}}$ 其中，$\beta$是learning rate，即学习率。编程时候也会按照上述思路来实现代码。 （4）影响因素 哪些参数的设定会影响最终的模型效果？ 1.负样本的选取 比起正样本，负样本的数量是非常多的。因为，展现给用户的item比用户点击的item要多的多。我们要有一定的负采样规则，我们选取那些充分展现而用户没有点击的item作为负样本。 那么什么叫做充分展现？ 充分展现是指，这个item在所有的用户中，已经有了比较高的展现次数。 然后，我们就可以用user没有点击过的物品中，按照该item在所有用户中的展现次数做排序（来降序），取一定数目的item作为负样本。这个一定数目只要保证对该user来说，它的正负样本均衡就可以。比如，一个用户点击了100个item，那么同样也取100个负样本来保证正负样本的均衡。 2.隐特征F、正则参数$\partial$、学习率（learning rate $\beta$） 以上是对模型比较重要的三个参数。 其中正则参数$\partial$和学习率（learning rate $\beta$）通常设置为0.01-0.05，隐特征个数F通常设置为10-32之间。 当然你可以在实验过程中，根据具体数据分布来固定一些参数，对另一些参数做差异化实验。 比如说我们固定了正则参数$\partial$和学习率（learning rate $\beta$）都为0.01的情况下，我们来变隐特征F，将它从16-32-64等等取值来看最终的效果。上述的一些参数对模型的快速收敛和模型效果都是非常重要的。 LFM（latent factor model）算法与CF算法的优缺点比较对于用户比较多的系统，用item CF比user CF更加具有可行性。 1.理论基础 LFM是比较传统的监督学习的打法，根据训练样本的label设定损失函数，利用最优化的方法使损失函数最小化。只不过这里的特征是隐特征，不像其他模型中的特征那样直观。 item CF是基于公式间求解相似度矩阵，相对来说，缺少了学习的过程。 所以，从理论基础的完备性上，LFM相对更好。 2.离线计算空间、时间复杂度 空间复杂度方面：item CF需要存储item sim表，需要的空间复杂度=物品数的平方；而LFM只需要存储user向量和item向量，所以空间复杂度=物品数目隐类数+用户数目隐类数。 相比较而言，显然LFM的空间复杂度更低。 时间复杂度方面：假设有M个用户，他们的平均点击序列长度为K，那么计算item相似度矩阵的时间复杂度=MKK；假设有D个样本，迭代N次，F是隐类的个数，那么训练LFM模型所需要的时间复杂度=DFN。由于LFM需要迭代，所以在耗时上略高于item CF，但是它们的耗时处于同一数量级。 3.在线推荐与推荐解释 item CF可以将item sim矩阵写入redis或者内存，线上基于用户实时点击去推荐，可以做到较好的响应用户的实时行为。 LFM由于得到user和item向量，在计算用户的toplike物品的时候，如果推荐系统的物品总量很大，那么就需要将每一个item做向量的点乘运算，复杂度是比较高的，离线计算相对来说比较耗时。得到用户的toplike物品表之后，也是写入redis或者内存之中，线上用户访问系统的时候，直接推荐计算好的toplike列表。但是这样就不能对用户的实时行为进行感知。现在像facebook也推出了一些向量召回的引擎，可以做到在线实时召回，但是依然也不能够在用户有了新行为之后立刻重新训练LFM模型得到新的向量。 所以，这这一方面，LFM效果略差。]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>LFM（latent factor model）算法</category>
        <category>隐语义模型</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>LFM（latent factor model）算法</tag>
        <tag>隐语义模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化推荐算法实践第01章个性化推荐算法综述]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC01%E7%AB%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 个性化推荐算法实践第01章个性化推荐算法综述第01部分个性化推荐算法综述个性化推荐算法综述部分，主要介绍个性化推荐算法综述，本课程内容大纲以及本课程所需要准备的编程环境与基础知识。 个性化推荐算法综述介绍本课程的主要内容与需要准备的知识，并介绍个性化推荐在工业界的落地场景与架构 1、什么是推荐系统？在介绍推荐算法之前需要先介绍一下什么是信息过载。 信息过载就是信息的数量远超于人手工可以遍历的数量。比如，当你没有目的性的去逛超市，你不可能把所有的商品都看一遍都有什么。同样，无论是去书店看书，还是在电影网站上搜索电影，这些物品的量级对于没有目的性、需求性的用户而言都是信息过载。 那么什么是推荐系统呢？ 就是当用户的目的不明确、且该服务对于用户而言构成了信息过载；但该系统基于一定的策略规则，将物品进行了排序，并将前面的物品展示给了用户，这样的系统就可以称之为推荐系统。 举例说明，在网站购物过程中，无论是天猫或者京东这样的平台，如果我们有明确的需求去搜索框里检索。如希望买啤酒，那么检索结果就是很多种类的啤酒；如果没有明确的需求，就会有猜你喜欢等等模块，这些模块就是推荐系统基于一定的规则策略计算出来的，这些规则策略就是个性化推荐算法。 2、个性化推荐算法在系统中所起到的作用 推荐系统在工业界落地较成功的三大产品：电商、信息流、地图基于位置服务的（LBS）的推荐 推荐系统如今在工业界中落地较为成功的有三类产品，分别是电商、地图、基于LBS的推荐。电商中，用户需要面对数以十万计的新闻与短视频，地图中用户需要面对数以百万计的餐馆等等；但是用户首先看到的都不会是全部的内容，只会是几个或者几十个新闻、短视频、餐馆等等，决定从物品海洋里选择哪些展现给用户的就是个性化推荐算法。 如果推荐的精确，也就是说该推荐系统推荐的恰好是用户想要的、或者是促进了用户的需求，那么就会推动用户在该电商上进行消费、停留、阅读等等。所以，在推荐系统中最为重要的就是个性化推荐算法。 3、如何衡量个性化推荐算法在产品中起到的作用分为线上和线下两个部分。其中线下部分主要依托于模型本身的评估指标，比如个性化召回算法中模型的准确率等等；在线上，基于业务本身的核心指标，比如基于信息流产品中的平均阅读时长等等。 信息流中的点击率 ctr 与停留时长 dwell time 电商中的GMV(Gross Merchandise Volume,网站成交金额) 4、推荐算法介绍包括：个性化召回算法、个性化排序算法 5、评估指标：包括：在线评估指标和离线评估指标 个性化召回1、什么是个性化召回？ 在item全集中选取一部分作为候选集。 这里就存在一个问题，就是说为什么要选取一部分作为作为候选集，而不是全部？其原因在于：1.不同的用户不会喜欢所有类型的item；2.基于服务性能的考虑，如果选择了全部的item作为候选集，对于后续的排序就将耗费大量的时间，对于整体推荐的后端，服务响应时间将会是灾难性的。 根据用户的属性行为上下文等信息从物品全集中选取其感兴趣的物品作为候选集。 下面举例说明： 如果某个推荐系统中，物品全集是如下左图中9个item，这里有两个用户A和B，他们分别对不同的item感兴趣。这里拿信息流产品举例，如果user A对体育类新闻感兴趣，user B对娱乐类新闻感兴趣，那就按照简单的类别召回，得到结果如下右图所示。 在候选集{a,b,c,….,g,h,i}中为User A,User B选取一部分item作为候选集。 2、召回的重要作用1、召回决定了最终推荐结果的天花板 为什么这么说呢？这里先看一下推荐系统的整体架构，工业中的个性化推荐系统中的策略部分的架构主要由一下三部分构成：召回、排序、以及最后的策略调整部分，其中召回部分包括各路个性化召回之后将所有的item merge进入rank部分，rank只是调整召回完item的展现顺序，rank完之后还有一些策略的调整，比如信息流场景中的控制相同作者的数目等等，所以可以看到个性化召回的候选集是多么的重要，因为最终展现给用户的就是从这个候选集中选出来的。那么就可能会有疑问，为什么不能将所有的item进行排序？这是为了保证后端响应时间。 与用户离的最近的是端，在移动互联网的时代主要的流量集中在了移动app也可以是网站前端。连接接前后端的是WEB API层。WEB层主要给APP端提供API服务，解析端上发来的请求，调用后端rpc服务。得到的结果投全到端上。web api层尽量不做策略业务逻辑，但是会做一些诸如log写实时信息队列，或写分布式存储这样的事情来方便后续的数据分析和模型训练。 最后是后端的RPC服务。个性化推荐算法主要发挥作用的部分。 RPC服务的三大策略部分。 第一：个性化召回，基于用户的行为，通过算法模型来为用户精准推荐。或基于用户画像的标签推荐同类型的item。举个栗子，如果某个用户过往经常点击体育类的item，那么用户画像就给她标上体育的lable。那么有较新的体育类新闻，会优先推荐给改用户。召回决定了最终推荐结果的天花板，因为这一步决定了候选集。 第二部分：排序部分。第一部分召回了用户感兴趣的物品集合后，我们需要决策 出展现给用户的顺序。好的顺序可以让用户在列表的开始找到自己的所需，完成转化。因为用户的每一次下拉都是有成本的，如何不能在最初的几屏里，显示用户的所需，用户就很可能流失掉。结合刚才召回所举的例子，给用户召回了体育类的item，不同的item可能会有不同的浏览人数，评论人数，发布时间，不同的字数，不同的时长，不同的发布时间等等，同样该用户也有体育类的细分的倾向性。 第三部分：策略调整部分，基于业务场景的策略调整部分。由于召回和排序大多数是基于模型来做的，所以基于业务场景的策略调整部分可以增加一些规则来fit业务场景。比如在信息流场景中，我们不希望给用户一直连续推荐同一个作者的新闻，我们可以加一些打散的策略。 2、个性化召回解析 个性化召回算法分为哪几大类？ 基于用户行为的（也就是用户基于推荐系统推荐给他的item点击或者没点。） ​ CF(基于邻域的算法：user CF item CF)、矩阵分解、基于图的推荐（graph-based model）——基于图的随机游走算法：PersonalRank 这一类的个性化召回算法总体来说就是推荐结果的可解释性较强，比较通俗易懂，但是缺少一些新颖性。 基于user profile的 经过用户的自然属性，也就是说经过用户的偏好统计，那么基于这个统计的类别去召回。推荐效果不错，但是可扩展性较差。也就是说一旦用户被标上了某一个类别或者某几个类别的标签之后，很难迁移到其余的一些标签。 基于用户的偏好的统计的类别类召回。效果不错，可扩展性比较差。 隐语义模型Latent Factorization Model(LFM) 新颖性、创新性十足，但是可解释性不是那么强。 3、工业界个性化召回架构 整体的召回架构可以分为两大类： 第一大类是离线模型。根据用户行为基于离线的model file算出推荐结果，这些推荐结果可以是用户喜欢哪些item集合，也可以是item之间的相似度文件 ，计算出具有某种lable的item的排序。然后离线计算好的排序的文件写入KV存储。在用户访问服务的时候，Recall部分直接从KV中读取。因为我们直接存储的是item ID,我们读取到的item id的时候还需要去Detail Server中得到每个item id的详情，然后将详情拼接好传给rank。(在线的server recall部分直接调用这个结果，拿到ID之后访问detail server得到详情，再往rank部分传递) 第二大类是深度学习模型，如果采用深度学习的一些model，这是需要将model file算出来的item embedding的向量也需要离线存入KV中，但是用户在访问我们的KV的时候，在线访问深度学习模型服务（recall server）的User embedding。同时去将user embedding层的向量和item embedding层的向量做最近邻计算，并得到召回。 第02部分 个性化召回算法协同过滤理论部分本章节主要讲解itemcf与usercf的基础理论部分与理论公式升级部分，并详细介绍itemcf与usercf的优缺点分析 Item Collaborative Filtering(Item CF)背景 信息过载，用户需求不明确 强依赖于用户行为 工业界主流落地场景 信息流 电商 o2oLBS 含义：给用户推荐他之前喜欢的物品相似的物品 如何衡量相似 基于用户行为，如果喜欢2个物品的用户重合度越高，那么2个物品也就越相似。 如何衡量喜欢 看用户是否真实点击，在电商场景下，更看重实际转化（实际消费购买）；信息流场景下，更看重真实的点击（基于一定时长下的停留） 物品之间相似度公式： $s_{i j}=\frac{|u(i) \cap u(j)|}{\sqrt{|u(i)| \cup|u(j)|}}$ u(i)表示喜欢物品i的用户数，$|u(i) \cap u(j)|$表示同时喜欢物品i和物品j的用户数 根据用户行为计算出用户相似度矩阵： 分子：u(i)表示对item (i)有过行为的用户集合 ,u(j)表示对item (j)有过行为的用户集合 ，分子表示user的重合程度，重合度越高，越相似。 分母：归一化（举例：对item(i)有过行为的用户2个，对item(j)有过行为的用户3个$\sqrt{2} \sqrt{3}=\sqrt{6}$,物理意义：惩罚的热门物品与其他物品的相似度，因为热门物品对应的user倒排会非常长造成了与很多物品都有重合，如果分母除以一个很大的数，将相似度的数值趋于0。 用户u对物品j的兴趣公式： $p_{u j}=\sum_{i \in N(u) \cap s(j, k)} s_{i j} * r_{u i}$ N(u) 表示用户喜欢的物品集合，$s(j, k) $表示和物品j最相似的k个物品的集合。$s_{ij}$表示物品i和j的相似度. 表示用户u对物品i的兴趣。 $r_{ui}$表示user对 i的行为得分，$s_{ij}$表示物品的相似度得分 $p_{uj}$对user进行item(j)的推荐，根据item(i)来完成推荐的，item(i)是user行为过的物品并且取与item(i)最相似的top k个(一般50个）， Item CF在工业界落地公式升级1： 理论意义：针对于活跃用户应该被降低在相似度公式中的贡献度。 如果在某电商系统中，如果某User A是批发商，他购买了很多物品，可能有啤酒，书刊等，这都不能真实的表现他的兴趣。还有一名User B,他只买了啤酒和书刊，这能完全表现他的兴趣。如果我们在计算啤酒和书刊的相似度的时候，如果按照之前相似度公式User A和User B对啤酒和书刊的相似度贡献是一样的。这样子显然是不合理的。我们需要降低User A在相似度计算过程中的贡献度。 $s_{i j}=\frac{\sum_{u \in u(i) \cap u(j)} \frac{1}{\log (1+|N(u)|)}}{\sqrt{|u(i)||u(j)|}}$ u(i)表示喜欢物品i的用户数，$|u(i) \cap u(j)|$表示同时喜欢物品i和物品j的用户数 与之前的相似度计算公式公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。之前的相似度计算公式中每个重合用户对相似度的贡献是一样的，都是1.但是升级后的公式，我们发现每个用户对相似度的贡献变成了不一样。N(u)表示用户u所行为过的item的总数。如果一个用户行为过的item的总数越多，那么他的相似度就越低。这样子是符合常理的认知的。 分子：N(u)表示用户u所行为过的item总数，如果用户行为过的总数越多，对相似度贡献越低。 Item CF在工业界落地公式升级2： 理论意义：用户在不同时间对item的操作应给予时间衰减惩罚。 因为在很多场景中，用户的兴趣随时间是有变化的。如在信息流场景中，可能30前看过的短视频，30天后就不一定喜欢了。因为在做物品相似度矩阵计算的时候，就假定了用户的行为可以反映用户的兴趣。所以需要给予时间衰减降权。 $s_{i j}=\frac{\sum_{u \in u(i) \cap u(j)} {f(\Delta t)}}{\sqrt{|u(i)||u(j)|}}$ $f(\Delta t)=\frac{1}{1+\alpha \Delta t}$的物理意义就是说如果item i与item j被行为时间的差异越小，那么就越逼近于1.如果他们item i与item j被行为时间的差异越大，那么这个贡献就越低。 与之前的相似度计算公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。每个用户对相似度的贡献也发生了变化。这里的变化主要由$\Delta t$决定的。$\Delta t$是指用户item i与 item j所行为的时间的差异。 User Collaborative Filtering(User CF)意义：给用户推荐相似兴趣用户感兴趣的物品。 举个栗子：在我们读书的时候是否经常问学长学姐该读什么样的书或者下载什么样的论文？学长学姐就会给你推荐。在这个栗子中学长学姐和你就属于具有相同爱好的用户群体，因为你们具有相同的研究领域。 那么所以基于用户的协同过滤的算法有两个步骤： 1、找到相似兴趣用户的集合 那么问题来了，如何评价相似兴趣用户集合？区别于很多传统做法，这里主要采用基于用户行为重合度的方法，举例来说，如果两个用户的行为具有很高的重合度，那么他们具有很高的相似性。那么他们可以称为相似兴趣用户集合。 2、推荐相似用户行为过，而该用户并没有行为过的item。举个栗子，如果我们发现两个用户A、B都非常喜欢足球相关的视频，行为重合度极高。而用户B经常点击天下足球相关的视频，用户A并没有行为，那么我们可以推荐天下足球相关的视频给用户A。 栗子： User A 可以给User D 推荐b 基于用户的协同过滤算法的步骤 1、计算相似用户的相似度矩阵 相似度公式 $s_{u v}=\frac{|N(u) \cap N(v)|}{\sqrt{|N(u) | N(v)|}}$ N(u)表示用户u有过行为item的集合。N(v)表示用户v有过行为item的集合。 分子是item的重合程度。显然重合程度越高，user越相似。 分母做了一个归一化，物理意义上解释了惩罚了操作过多的用户与其他用户的相似程度。因为操作过多的用户对应的item的序列会非常的长，造成了与很多的用户都有相似。分母除以一个很大的数之后呢，就能把相似度得分的数值趋于0.在得到用户相似度矩阵过后，我们根据用户的行为点击，来完成相似用户的item推荐。 下面来看公式 $p_{u i}=\sum_{v \in s(u, k) \cap u(i)} S_{u v} {r}_{v i}$ ${r}_{v i}$表示用户v对item i的行为得分。在前面介绍item cf公式的时候，我们提到过对于不同的行为，我们对用户的行为得分定义不同。我们这里将行为得分归一化为1. $S_{u v} $表示user u与uer v的相似度得分。这里根据用户v来完成对用户u的推荐。所以这里要介绍用户v。用户v是用户u的前TOP k个的相似用户。并且用户v行为过的物品 item i,用户user u 没有行为。那么我们便得到了用户u对item i的推荐度得分。 工业界落地时公式升级1: 理论意义：降低那些异常活跃物品对与用户相似度的贡献 举个栗子解释： 如果某个电商系统中，User (A) 与User(B)同时购买了《新华字典》，User (A) 与User(C)同时购买了《机器学习》，并且他们都只有这一本书重合，User (A) 与User(B)、User (A) 与User(C)的重合度都是1，显然不合理，因为购买《新华字典》并不能十分准确的反映用户的兴趣，也许是给家里孩子买，换言之《新华字典》的用户倒排会非常的长，而购买《机器学习》的用户大概率可以反映他们的兴趣，因为这本书的购书群体很窄，因此我们需要降低那些很多人购买的在重合度中的贡献。 $s_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} \frac{1}{\log (1+|u(i)|)}}{\sqrt{|N(u)||N(v)|}}$ 分子：基础版本的相似度计算公式当中重合的每一item对整体的贡献都是相同的。在升级版中贡献变得不同的。u(i)表示对item(i)有过行为的用户集合，如果一个item被更多的用户行为过，那么它在重合度的贡献越低。这也符合我们的认知。 公式升级2（工业界）理论意义，不同用户对同一item行为的时间段不同应该给予时间惩罚（因为很多用户不同时间段，兴趣是发生变化的，比如，2个用户都曾经点击过足球类短视频，一个用户是近期点击，另一个用户是在好几个月之前欧洲杯比赛期间，也许在目前时间节点，已经不再喜欢足球类短视频了，我们在计算用户相似度矩阵的时候，假定了用户行为可以反映出用户的兴趣，所以我们要给予时间衰减降权） $s_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} f\left(\Delta t_{i}\right)}{\sqrt{|N(u) | N(v)|}}$ $f\left(\Delta t_{i}\right)=\frac{1}{1+\alpha\left|t_{u i}-t_{v i}\right|}$ 与基础版本的用户相似度矩阵计算公式，分母没有发生任何变化。 分子：每一个重合的item的贡献度得分都变得不同,它们的贡献度得分由函数$f\left(\Delta t_{i}\right)$决定。函数$f\left(\Delta t_{i}\right)$具体的得分是2个用户对同一item操作时间的差，如果$\left|t_{u i}-t_{v i}\right|$越短的话,$f\left(\Delta t_{i}\right)$的得分越高;如果$\left|t_{u i}-t_{v i}\right|$越长的话,$f\left(\Delta t_{i}\right)$的得分越低。相应的在重合度贡献中也就越低。 Itemcf VS Usercf优缺点比较： 推荐实时性 User cf用户有了新的行为，不会对结果造成很快的变化，因为User cf是基于相似度矩阵来完成推荐的，User本身的行为并不能造成自己的推荐结果发生改变。 Item cf用户一旦有了新的行为，推荐结果立刻发生改变，因为Item cf是基于相似度矩阵来完成推荐的，所以点击了物品，会立马推荐出相似的物品。 新用户/新物品的推荐 User cf新用户的到来是不能立即推荐的，需要等用户有了一定的行为并且得到了与其他用户相似度矩阵之后才可以完成推荐，新用户一旦被用户点击，User cf可以通过相似度用户矩阵将该物品推荐给相似的用户。 Item cf新用户一旦完成了Item点击，便可以推荐该Item相似的其余Item，新物品的到来，由于此时新物品 并没有与其他物品在相似度矩阵中出现，所以Item cf并不能将新物品及时地推荐出去。 推荐理由的可解释性 User cf由于是通过用户相似度矩阵来完成推荐的，结果会略显难以解释。 Item cf通过用户历史点击行为完成的推荐，所以推荐结果更加令人信服。 Item cf VS User cf适用场景性能层面考量 User cf通过计算用户相似度矩阵，所以它并不适合用户很多的场合。因为相似度矩阵计算起来代价非常大。 Item cf需要计算物品的相似度矩阵，所以Item cf适用于物品数远小于用户数场合。由于实战中用户量往往远大于物品的数量级，所以实战中更倾向于Item cf。 个性化层面考量 User cf适用于物品及时推荐下发且个性化需求不太强烈的领域。 Item cf适用于长尾物品丰富并且个性化需要强烈的领域。由于真实的推荐系统中，各种个性化召回算法组合，会有一些召回方法解决新物品及时下发问题，而我们需要个性化程度强烈，所以从个性化层面考虑，更倾向于在落地实战中采用Item cf。 ItemCF的优势： （1）计算性能高，通常用户数量远大于物品数量。 （2）可预先计算保留，物品并不善变。 ItemCF存在的问题：物品冷启动问题：当平台中物品数据较少或缺失时，无法精确计算物品相似度，解决办法： （1）文本分析，通过分析物品的介绍文本，计算相似度。（2）主题模型，通过主题模型分析物品文本主题得出主题相似度。（3）打标签，对物品打标签求得相似度。（4）推荐排行榜单。 第03部分 个性化召回算法协同过滤代码实战部分本章节结合具体的示例数据介绍itemcf与usercf基础部分的代码实战与升级部分的代码实战 3-1 数据集介绍与公共信息抽取函数代码实战本次代码实战的使用的2个数据集 rating.txt 用户对item的打分文件 userId movieId rating: userId对movieId的打分 timestamp：userId对movieId行为的时间戳 movies.txt item的info文件 movidId title:item的标题 genres:item的分类 在item CF和 User CF实战当中我们都需要得到user的点击序列，所以我们下面写一下公共的信息抽取函数。 本文使用PyCharm为代码编写平台。 1、数据集准备： 本实例使用MovieLens 数据集（下载地址：http://files.grouplens.org/datasets/movielens/ml-latest-small.zip中的ratings.csv（用户ID对电影ID的评分）以及movies.csv（电影类别明细）。如下： ​ ratings.csv movies.csv 2、项目结构 data文件夹用于存储电影评分数据，production文件夹用于存放推荐代码，util文件夹用于存放用于读取数据的工具文件。 3、reader.py：用于读取用户的点击序列（即每个用户对那些电影进行过评分）以及电影信息（id，名称，类别）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# _*_ encoding: utf-8 _*_&apos;&apos;&apos;@File : reader.py @Contact : anfrank@gmail.com@License : (C)Copyright 2019-2020@Modify Time @Author @Version @Desciption------------ ------- -------- -----------2019/7/16 13:38 anfrank 1.0 None&apos;&apos;&apos;# import libimport os# 获得用户的点击序列def get_user_click(rating_file): &apos;&apos;&apos; get user click list[userid,itemid] :param rating_file:input file :return:输出是一个dict key:userid value:[itemid1,itemid2] &apos;&apos;&apos; # 如果路径不存在，返回空数据 if not os.path.exists(rating_file): return &#123;&#125; # 打开文件 fp = open(rating_file) num = 0 # 用于传回的数据 user_click = &#123;&#125; # 循环数据 for line in fp: # 第一行是表头，需要跳过处理 if num == 0: num += 1 continue # 根据逗号提取每个项目 item = line.strip().split(&apos;,&apos;) # print(item) if len(item) &lt; 4: continue [userid, itemid, rating, timestamp] = item if float(rating) &lt; 3.0: # 如果评分低于3分，则视为该用户不喜欢该电影 continue # 将单一用户的点击序列添加至返回数据 if userid not in user_click: user_click[userid] = [] user_click[userid].append(itemid) fp.close() return user_click# 获取电影信息数据def get_item_info(item_file): &apos;&apos;&apos; get item info[title,genres] :param item_file: input iteminfo file :return: a dict,key itemid,value:[title,genres] &apos;&apos;&apos; # 若路径不存在则返回空 if not os.path.exists(item_file): return &#123;&#125; num = 0 item_info = &#123;&#125; # fp = open(item_file, &apos;r&apos;, encoding=&apos;UTF-8&apos;) fp = open(item_file,&apos;r&apos;,encoding=&apos;UTF-8&apos;) for line in fp: # 第一行是表头，需要跳过处理 if num == 0: num += 1 continue # 根据逗号提取每个项目 item = line.strip().split(&apos;,&apos;) if len(item) &lt; 3: # 若单行小于三项过滤（去除问题行） continue if len(item) == 3: [itemid, title, genres] = item # 这个elif语句是由于，有的电影名称中含有逗号，因此造成项数过多，需要另行处理 elif len(item) &gt; 3: itemid = item[0] genres = item[-1] # 获取最后一项 title = &quot;,&quot;.join(item[1:-1]) # 第一个到最后一个的拼接成为电影名称 # 将电影信息数据返回 if itemid not in item_info: item_info[itemid] = [title, genres] fp.close() return item_info# 测试上述方法if __name__ == &apos;__main__&apos;: # f = open(&quot;../data/ml-1m/ratings.dat&quot;) user_click = get_user_click(&quot;../data/ml-latest-small/ratings.csv&quot;) print(&quot;输出user_click字典的用户数量：&quot;) print(len(user_click)) print(&quot;输出user_click字典的key为1点击了的item：&quot;) print(user_click[&apos;1&apos;]) item_info = get_item_info(&quot;../data/ml-latest-small/movies.csv&quot;) print(&quot;输出item_info字典的item数量：&quot;) print(len(item_info)) print(&quot;输出item_info字典的key为1的item名称&quot;) print(item_info[&apos;1&apos;]) 3-2 itemcf基础部分代码实战三、参考资料1、https://www.imooc.com/learn/1029 2、https://www.imooc.com/learn/990 3、https://study.163.com/course/introduction/1004092024.htm 4、https://blog.csdn.net/yimingsilence/article/details/54934302 5、https://blog.csdn.net/xiaokang123456kao/article/details/74735992 6、项亮. 推荐系统实践[M]. 人民邮电出版社, 2012. 第04部分 个性化推荐召回算法的离线在线评估方法从离线在线两个方面，带大家详细了解如何评估个性化推荐算法对个性化推荐系统的影响。 1、业务指标信息流更关注： 点击率：总点击次数/总展现次数 平均阅读时长（两个小指标）： ​ 推荐精准度：总阅读时长/click uv ​ 推荐算法对整体趋势的影响：阅读总时长/show uv 电商推荐中更关注转化率： 转化率：总得成交次数/总的展现次数 还有总的成交额度（ GMV） 2、 item推荐覆盖率如果我们无休止的去剥削用得的点击历史，会发现推荐的item呈现长尾，很多item无法得到充分的展现。所以我们要利用一些发现算法保证item的覆盖率。 1覆盖率：去重后推荐的所有item的id数/库里面所有的itemid 如何在个性化召回算法中从离线和在线两个方面来评价算法的好坏呢？ 3、offline评价方法1评测模型推荐结果在测试集上的表现 如果在推荐系统中，某种算法给用户A推荐的物品（a、b、d）。又得到，在测试集中，用户A有过物品a,b,f,m的展现。这个时候我们发现推荐出来的真实结果和测试上的结果重合为物品（a、b）。这个集合就是我们评价的分母。 我们又发现用户a在测试集上点击了物品（a、f）,那么推荐的真实物品结果（a、b、d）,与用户在测试集上点击（a、f）也有重合,重合的为a，这个重合就是他的分母。点击率：总点击次数/总展现次数。综上，整体的点击率表现为1/2。 4、 online评价方法1234定义指标： 信息流中：点击率、平均阅读时长、覆盖率 生产环境中A/B test，分离出一部分流量对比 第05部分总结推荐引擎主体架构，工业界推荐系统落地 推荐引擎主体架构主要分为match召回、Rank排序、以及strategy策略调整部分。并对Match在工业界的几种落地架构进行了深入剖析。对工业界电商、信息流、地图基于位置服务的（LBS）的推荐进行了详细介绍。 CF算法的落地实战 item cf user cf item cf和user cf不同场景下的优劣对比 借助demo数据，实现itemCF与user CF 推荐系统在不同业务下的评价指标 分别从offline评价方法和online评价方法两个方面展示了，如何在新增一个召回算法来评价改算法的性能。 第06部分预习参考资料：recall:矩阵分解、graph、content based 、item2vec(用DNN来将user和item分别embedding成隐语义向量做向量召回) 推荐系统系列之隐语义模型 【机器学习】—隐语义模型DNN个性化推荐模型 DNN论文分享 - Item2vec: Neural Item Embedding for Collaborative Filtering 万物皆Embedding，从经典的word2vec到深度学习基本操作item2vec]]></content>
      <categories>
        <category>个性化推荐算法</category>
        <category>Item CF</category>
        <category>User CF</category>
      </categories>
      <tags>
        <tag>个性化推荐算法</tag>
        <tag>Item CF</tag>
        <tag>User CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的浪漫爱心表白源码]]></title>
    <url>%2F2019%2F05%2F13%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB%E7%88%B1%E5%BF%83%E8%A1%A8%E7%99%BD%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[程序员的浪漫爱心表白源码 简介我们程序员在追求爱情方面也是非常浪漫的，某位同学利用自己所学的HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜，这样的创意很容易打动女孩，如果你是单身的程序员，也赶紧来制作自己的爱心表白动画吧。 表白源码下载地址：https://github.com/enfangzhong/loveSource 个人博客展示：https://enfangzhong.github.io/ 在线演示 在我们rep中，我就展示了loveheart和love-ppt两个开源的表白动画。其他我就不一一全部上线演示了。 赶紧star吧。 loveheart演示地址：https://enfangzhong.github.io/love/ love-ppt演示地址：https://enfangzhong.github.io/loveshow/ 12套表白源码展示 表白网页款式01源码 表白网页款式02源码 ……….……….………. 表白网页款式06源码 表白网页款式07源码 表白网页款式08源码 ……….……….………. 表白网页款式11源码 表白网页款式12源码 祝天下有情人终成眷属！show the love line with your Mrs.Right]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>表白源码</tag>
        <tag>程序员表白源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记_02决策树与随机森林]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_02%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[机器学习笔记_02决策树与随机森林[TOC] 从LR到决策树1、总体流程与核心问题首先，在了解树模型之前，自然想到线性模型和树模型有什么区别呢？其中最重要的是，树形模型是一个一个特征进行处理，之前线性模型是所有特征给予权重相加得到一个新的值。决策树与逻辑回归的分类区别也在于此，逻辑回归是将所有特征通过sigmoid函数变换为概率后，通过大于某一概率阈值的划分为一类，小于某一概率阈值的为另一类；而决策树是对每一个特征做一个划分。另外逻辑回归只能找到线性分割（输入特征x与logit之间是线性的，除非对x进行多维映射），而决策树可以找到非线性分割。 而树形模型更加接近人的思维方式，可以产生可视化的分类规则，产生的模型具有可解释性（可以抽取规则）。树模型拟合出来的函数其实是分区间的阶梯函数。 决策树学习：采用自顶向下的递归的方法，基本思想是以信息熵为度量构造一棵熵值下降最快的树，到叶子节点处熵值为0（叶节点中的实例都属于一类）。 其次，需要了解几个重要的基本概念：根节点（最重要的特征）；父节点与子节点是一对，先有父节点，才会有子节点；叶节点（最终标签）。 2、熵、信息增益、信息增益率信息熵(Information Entropy) 信息熵是用来评估样本集合的纯度的一个参数，就是说，给出一个样本集合，这个样本集合中的样本可能属于好多不同的类别，也可能只属于一个类别，那么如果属于好多不同的类别的话，我们就说这个样本是不纯的，如果只属于一个类别，那么，我们就说这个样本是纯洁的。 而信息熵这个东西就是来计算一个样本集合中的数据是纯洁的还是不纯洁的。下面上公式： $Ent(D)=-\sum_{k=1}^{\left|y\right|}p_{k}log_{2}p_{k}$ 下面解释一下公式的意思，其实很好理解，计算一个集合的纯度，就是把集合中每一个类别所占的比例$p_k$（k从1到 $\left | y \right |$，其中 $\left | y \right |$ 表示类别的个数）乘上它的对数，然后加到一起，然后经过计算之后，可以得到一个数据集的信息熵，然后根据信息熵，可以判断这个数据集是否纯粹。信息熵越小的话，表明这个数据集越纯粹。信息熵的最小值为0，此时数据集D中只含有一个类别。 信息增益(Information Gain) 下面来介绍信息增益，所谓的信息增益，是要针对于具体的属性来讲的，比如说，数据集D中含有两个类别，分别是好人和坏人，那么，随便选择一个属性吧，比如说性别，性别这个属性中包含两个值，男人和女人，如果用男人和女人来划分数据集D的话，会得到两个集合，分别是$D_{man}$和$D_{woman}$。划分后的两个集合中各自有 好人和坏人，所以可以分别计算划分后两个集合的纯度，计算之后，把这两个集合的信息熵求加权平均$\frac{D_{man}}{D} Ent(D_{man})+\frac{D_{woman}}{D} Ent(D_{woman})$，跟之前没有划分的时候的信息熵$Ent(D)$相比较，用后者减去前者，得到的就是属性-性别对样本集D划分所得到的信息增益。可以通俗理解为，信息增益就是纯度提升值，用属性对原数据集进行划分后，得到的信息熵的差就是纯度的提升值。信息增益的公式如下： $Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{\left | D^{v} \right |}{\left | D \right |}Ent(D^{v})$ 先解释一下上式中的参数，D是数据集，a是选择的属性，a中一共有V个取值，用这个V取值去划分数据集D，分别得到数据集$D_1$到$D_V$，分别求这V个数据集的信息熵，并将其求加权平均。两者的差得到的就是信息增益。 那么这个信息增益有什么用呢？有用，可以根据信息增益值的大小来判断是否要用这个属性a去划分数据集D，如果得到的信息增益比较大，那么就说明这个属性是用来划分数据集D比较好的属性，否则则认为该属性不适合用来划分数据集D。这样有助于去构建决策树。 著名的算法ID3就是采用信息增益来作为判断是否用该属性划分数据集的标准。 信息增益率(Information Gain Ratio) 为什么要提出信息增益率这种评判划分属性的方法？信息增益不是就很好吗？其实不然，用信息增益作为评判划分属性的方法其实是有一定的缺陷的，书上说，信息增益准则对那些属性的取值比较多的属性有所偏好，也就是说，采用信息增益作为判定方法，会倾向于去选择属性取值比较多的属性。那么，选择取值多的属性为什么就不好了呢？举个比较极端的例子，如果将身份证号作为一个属性，那么，其实每个人的身份证号都是不相同的，也就是说，有多少个人，就有多少种取值，它的取值很多吧，让我们继续看，如果用身份证号这个属性去划分原数据集D，那么，原数据集D中有多少个样本，就会被划分为多少个子集，每个子集只有一个人，这种极端情况下，因为一个人只可能属于一种类别，好人，或者坏人，那么此时每个子集的信息熵就是0了，就是说此时每个子集都特别纯。这样的话，会导致信息增益公式的第二项$\sum_{v=1}^{V}\frac{\left | D^{v} \right |}{\left | D \right |}Ent(D^{v})$整体为0，这样导致的结果是，信息增益计算出来的特别大，然后决策树会用身份证号这个属性来划分原数据集D，其实这种划分毫无意义。因此，为了改变这种不良偏好带来的不利影响，提出了采用信息增益率作为评判划分属性的方法。 公式如下： $Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$ 其中$IV(a)$的计算方式如下： $IV(a)=-\sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}log_2\frac{\left | D^v \right |}{\left | D \right |}$ $IV(a)$被称为是的“固有值”，这个$IV(a)$的公式是不是很熟悉啊，简直和信息熵的计算公式一毛一样，就是看属性a的纯度，如果a只含有少量的取值的话，那么a的纯度就比较高，否则的话，a的取值越多，a的纯度越低，$IV(a)$的值也就越大，因此，最后得到的信息增益率就越低。 采用信息增益率可以解决ID3算法中存在的问题(ID3会对那些属性的取值比较多的属性有所偏好，如西瓜的颜色有10种)，因此将采用信息增益率作为判定划分属性好坏的方法称为C4.5。 需要注意的是，增益率准则对属性取值较少的时候会有偏好，为了解决这个问题，C4.5并不是直接选择增益率最大的属性作为划分属性，而是之前先通过一遍筛选，先把信息增益低于平均水平的属性剔除掉，之后从剩下的属性中选择信息增益率最高的，这样的话，相当于两方面都得到了兼顾。 （结合信息增益与信息增益率使用） 采用信息增益率可以解决ID3算法中存在的问题，因此将采用信息增益率作为判定划分属性好坏的方法称为C4.5。需要注意的是，增益率准则对属性取值较少的时候会有偏好，为了解决这个问题，C4.5并不是直接选择增益率最大的属性作为划分属性，而是之前先通过一遍筛选，先把信息增益低于平均水平的属性剔除掉，之后从剩下的属性中选择信息增益率最高的，这样的话，相当于两方面都得到了兼顾。 基尼指数(gini index):CART中使用定义： 是一种不等性度量； 通常用来度量收入不平衡，可以用来度量任何不均匀分布； 是介于0~1之间的数，0-完全相等，1-完全不相等； 总体内包含的类别越杂乱，基尼指数就越大 基尼不纯度指标在CART算法中, 基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。假设y的可能取值为{1, 2, …, m},令fifi是样本被赋予i的概率，则基尼指数可以通过如下计算： $\begin{aligned} \operatorname{Gini}(D) &amp;=\sum_{k=1}^{|\mathcal{Y}|} \sum_{k^{\prime} \neq k} p_{k} p_{k^{\prime}} \\ &amp;=1-\sum_{k=1}^{|\mathcal{Y}|} p_{k}^{2} \end{aligned}$ 反映了从D中随机抽取两个样例，其类别标签不一致的概率。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
        <tag>随机森林</tag>
        <tag>信息增益</tag>
        <tag>信息增益率</tag>
        <tag>基尼指数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记_01线性回归和逻辑回归]]></title>
    <url>%2F2019%2F05%2F10%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_01%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[机器学习笔记_01线性回归和逻辑回归[TOC] 一、什么是机器学习利用大量的数据样本，使得计算机通过不断的学习获得一个模型，用来对新的未知数据做预测。 有监督学习（分类、回归） 同时将数据样本和标签输入给模型，模型学习到数据和标签的映射关系，从而对新数据进行预测。 无监督学习（聚类）只有数据，没有标签，模型通过总结规律，从数据中挖掘出信息。 强化学习强化学习会在没有任何标签的情况下，通过先尝试做出一些行为得到一个结果，通过这个结果是对还是错的反馈，调整之前的行为，就这样不断的调整，算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果。 就好比你有一只还没有训练好的小狗，每当它把屋子弄乱后，就减少美味食物的数量（惩罚），每次表现不错时，就加倍美味食物的数量（奖励），那么小狗最终会学到一个知识，就是把客厅弄乱是不好的行为。 【David Silve强化学习课程】： 推荐David Silver的Reinforcement Learning Course 课件链接：https://github.com/enfangzhong/DavidSilverRLPPT 机器学习基本术语与概念 二、线性回归利用大量的样本$D=\left(x_{i}, y_{i}\right)_{i=1}^{N}$，通过有监督的学习，学习到由x到y的映射f，利用该映射关系对未知的数据进行预估，因为y为连续值，所以是回归问题。 单变量情况 多变量情况 二维空间的直线，转化为高维空间的平面 2.1 线性回归的表达式机器学习是数据驱动的算法，数据驱动=数据+模型，模型就是输入到输出的映射关系。 模型=假设函数（不同的学习方式）+优化 1. 假设函数线性回归的假设函数（$\theta_{0}$表示截距项，$x_0=1$,方便矩阵表达）： $f(x)=\theta_{0} x_{0}+\theta_{1} x_{1}+\theta_{2} x_{2} \ldots+\theta_{n} x_{n}$向量形式（θ,x都是列向量）：$f(x)=\theta^{T} x$ 2. 优化方法监督学习的优化方法=损失函数+对损失函数的优化 3. 损失函数如何衡量已有的参数$\theta$的好坏？ 利用损失函数来衡量，损失函数度量预测值和标准答案的偏差，不同的参数有不同的偏差，所以要通过最小化损失函数，也就是最小化偏差来得到最好的参数。映射函数:$h_{\theta}(x)$损失函数：$J\left(\theta_{0}, \theta_{1}, \ldots, \theta_{n}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$ 解释：因为有m个样本，所以要平均，分母的2是为了求导方便 最小化损失函数（ loss function）：凸函数 4. 损失函数的优化损失函数如右图所示，是一个凸函数，我们的目标是达到最低点，也就是使得损失函数最小。 多元情况下容易出现局部极值 求极值的数学思想，对公式求导=0即可得到极值，但是工业上计算量很大，公式很复杂，所以从计算机的角度来讲，求极值是利用梯度下降法。 ① 初始位置选取很重要 ② 复梯度方向更新，二维情况下，函数变换最快的方向是斜率方向，多维情况下就成为梯度，梯度表示函数值增大的最快的方向，所以要在负梯度方向上进行迭代。 ③ θ的更新公式如上图，每个参数 $\theta_1,\theta_2…$ 都是分别更新的 高维情况：梯度方向就是垂直于登高线的方向 参数更新示例： 对每个theta都进行更新： 学习率： ① 学习率太大，会跳过最低点，可能不收敛② 学习率太小收敛速度过慢 5. 过拟合和欠拟合（underfitting vs overfitting） 过拟合的原因：① 如果我们有很多的特征或模型很复杂，则假设函数曲线可以对训练样本拟合的非常好$\left(J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2} \approx 0\right)$，学习能力太强了，但是丧失了一般性。从而导致对新给的待预测样本，预测效果差.② 眼见不一定为实，训练样本中肯定存在噪声点，如果全都学习的话肯定会将噪声也学习进去。 过拟合造成什么结果： 过拟合是给参数的自由空间太大了，可以通过简单的方式让参数变化太快，并未学习到底层的规律，模型抖动太大，很不稳定，variance变大，对新数据没有泛化能力。 所有的模型都可能存在过拟合的风险： 更多的参数，更复杂的模型，意味着有更强的能力， 但也更可能无法无天 眼见不一定为实，你看到的内容不一定是全部真实的数据分布，死记硬背不太好 6. 利用正则化解决过拟合问题正则化的作用： ① 控制参数变化幅度，对变化大的参数惩罚，不让模型“无法无天” ② 限制参数搜索空间 添加正则化的损失函数$J\left(\theta_{0}, \theta_{1}, \ldots, \theta_{n}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}-y^{(i)}\right)^{2}+\frac{\lambda}{2 m} \sum_{j=1}^{n} \theta_{j}^{2}\right.$ m：样本有m个n：n个参数，对n个参数进行惩罚λ：对误差的惩罚程度，λ 越大对误差的惩罚越大，容易出现过拟合，λ越小，对误差的惩罚越小，对误差的容忍度越大，泛化能力好。 7. 线性回归代码实例 三、逻辑回归监督学习，解决二分类问题。 分类的本质：在空间中找到一个决策边界来完成分类的决策 逻辑回归：线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。所以逻辑回归就是将线性回归的$(-\infty,+\infty)$结果，通过sigmoid函数映射到(0,1) 之间。线性回归决策函数：$h_{\theta}(x)=\theta^{T} x$ sigmoid函数：$g(z)=\frac{1}{1+e^{-z}}$ ① 可以对$(-\infty,+\infty)$结果，映射到(0,1) 之间，作为概率。 ② $x]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL内连接、左外连接、右外连接、交叉连接区别]]></title>
    <url>%2F2018%2F10%2F17%2FSQL%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[内连接、左外连接、右外连接、交叉连接区别在之前，我对MSSQL中的内连接和外连接所得出的数据集不是很清楚。这几天重新温习了一下SQL的书本，现在的思路应该是很清楚了，现在把自己的理解发出来给大家温习下。希望和我一样对SQL的连接语句不太理解的朋友能够有所帮助。（发这么菜的教程，各位大大们别笑话偶了，呵:D ） 有两个表A和表B。表A结构如下： Aid：int；标识种子，主键，自增ID Aname：varchar 数据情况，即用select * from A出来的记录情况如下图1所示： 图1:A表数据 表B结构如下： Bid：int；标识种子，主键，自增ID Bnameid：int 数据情况，即用select * from B出来的记录情况如下图2所示： 图2:B表数据 为了把Bid和Aid加以区分，不让大家有误解，所以把Bid的起始种子设置为100。有SQL基本知识的人都知道，两个表要做连接，就必须有个连接字段，从上表中的数据可以看出，在A表中的Aid和B表中的Bnameid就是两个连接字段。下图3说明了连接的所有记录集之间的关系： 图3:连接关系图 现在我们对内连接和外连接一一讲解。 1.内连接：利用内连接可获取两表的公共部分的记录，即图3的记录集C 语句如下：Select from A JOIN B ON A.Aid=B.Bnameid 运行结果如下图4所示：其实select from A,B where A.Aid=B.Bnameid与Select * from A JOIN B ON A.Aid=B.Bnameid的运行结果是一样的。 图4:内连接数据 2.外连接：外连接分为两种，一种是左连接（Left JOIN）和右连接（Right JOIN） (1)左连接（Left JOIN）：即图3公共部分记录集C＋表A记录集A1。 语句如下：select * from A Left JOIN B ON A.Aid=B.Bnameid运行结果如下图5所示： 图5:左连接数据 说明：在语句中，A在B的左边，并且是Left Join，所以其运算方式为：A左连接B的记录=图3公共部分记录集C＋表A记录集A1在图3中即记录集C中的存在的Aid为：2 3 6 7 8图1中即表A所有记录集A中存在的Aid为：1 2 3 4 5 6 7 8 9表A记录集A1中存在的Aid=(图1中即A表中所有Aid)-(图3中即记录集C中存在的Aid)，最终得出为：1 4 5 9由此得出图5中A左连接B的记录=图3公共部分记录集C＋表A记录集A1, 最终得出的结果图5中可以看出Bnameid及Bid非NULL的记录都为图3公共部分记录集C中的记录；Bnameid及Bid为NULL的Aid为1 4 5 9的四笔记录就是表A记录集A1中存在的Aid。 (2)右连接（Right JOIN）：即图3公共部分记录集C＋表B记录集B1。 语句如下：select * from A Right JOIN B ON A.Aid=B.Bnameid 运行结果如下图6所示： 图6:右连接数据 说明： 在语句中，A在B的左边，并且是Right Join，所以其运算方式为：A右连接B的记录=图3公共部分记录集C＋表B记录集B1在图3中即记录集C中的存在的Aid为：2 3 6 7 8图2中即表B所有记录集B中存在的Bnameid为：2 3 6 7 8 11表B记录集B1中存在的Bnameid=(图2中即B表中所有Bnameid)-(图3中即记录集C中存在的Aid)，最终得出为：11由此得出图6中A右连接B的记录=图3公共部分记录集C＋表B记录集B1, 最终得出的结果图6中可以看出Aid及Aname非NULL的记录都为图3公共部分记录集C中的记录；Aid及Aname为NULL的Aid为11的记录就是表B记录集B1中存在的Bnameid。 交叉连接：两张表联合没有条件情况下，条数 = 图1 * 图2 交叉连接不带WHERE子句，它返回被连接的两个表所有数据行的笛卡尔积，返回结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SQL内连接</tag>
        <tag>左外连接</tag>
        <tag>右外连接</tag>
        <tag>交叉连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git个人总结笔记]]></title>
    <url>%2F2018%2F09%2F06%2FGit%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git个人总结笔记初始化一个Git仓库使用git init命令。 添加文件到Git仓库分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件； 使用命令git commit -m ，完成。 查看git仓库状态要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset —hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。如：git reset —hard HEAD^ 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。如：git reset —hard commit_id git diff HEAD — readme.txt：查看工作区和版本库里面最新版本的区别 撤销修改git checkout — readme.txt把readme.txt文件在工作区的修改全部撤销 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 就是让这个文件回到最近一次git commit或git add时的状态 git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout — file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。git rm —cached … 远程仓库创建SSH Key：$ ssh-keygen -t rsa -C “youremail@example.com”github添加SHH 本地仓库进行远程同步1git remote add origin git@github.com:michaelliao/learngit.git 1git push -u origin master 第一次push加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 以后只要本地作了提交，就可以通过命令：1$ git push origin master 远程仓库tips: 要关联一个远程库，使用命令 1git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 远程仓库克隆1git clone git@github.com:michaelliao/gitskills.git 分支管理（重要）master指向最新的提交HEAD指向的就是当前分支 只有master分支的时候：每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 下面开始实战。首先，我们创建dev分支，然后切换到dev分支：git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：12git branch devgit checkout dev git branch命令查看当前分支 把dev分支的工作成果合并到master分支上:git merge dev 合并后删除分支：git branch -d dev 总结：Git鼓励大量使用分支：1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 本地库上使用命令git remote add把它和码云的远程库关联1git remote add origin git@gitee.com:liaoxuefeng/learngit.git git remote -v查看远程库信息123git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 删除已关联的名为origin的远程库：1git remote rm origin 关联GitHub的远程库1git remote add github git@github.com:michaelliao/learngit.git 关联码云的远程库：1git remote add gitee git@gitee.com:liaoxuefeng/learngit.git 12345git remote -vgitee git@gitee.com:liaoxuefeng/learngit.git (fetch)gitee git@gitee.com:liaoxuefeng/learngit.git (push)github git@github.com:michaelliao/learngit.git (fetch)github git@github.com:michaelliao/learngit.git (push) 如果要推送到GitHub，使用命令：1git push github master 如果要推送到码云，使用命令：1git push gitee master 为开源项目贡献代码1git clone git@github.com:enfangzhong/bootstrap.git 添加推特公司bootstrap项目远程仓库git remote add upstream git@github.com:twbs/bootstrap.git 查看建立连接的远程仓库 1、首先拉取推特公司最新代码git pull upstream master 2、自己创建分支git checkout -b feature/add_sth 然后去修改你自己代码 git status查看状态 git add ./ git commit -m “add sth” 3.切换到主分支，继续拉取网上最新代码 git checkout mastergit pull upstream master 4.切换到分支，进行测试，git checkout feature/add_sth 5.合并分支git rebase master git push origin feature/add_sth]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GiT撤销</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaveEE请求转发和重定向的区别]]></title>
    <url>%2F2018%2F09%2F05%2FJaveEE%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、请求转发和重定向请求转发：request.getRequestDispatcher(URL地址).forward(request, response) 处理流程： 客户端发送请求，Servlet做出业务逻辑处理。 Servlet调用forword()方法，服务器Servlet把目标资源返回给客户端浏览器。 重定向：response.sendRedirect(URL地址) 处理流程： 客户端发送请求，Servlet做出业务逻辑处理。 Servlet调用response.sendReadirect()方法，把要访问的目标资源作为response响应头信息发给客户端浏览器。 客户端浏览器重新访问服务器资源xxx.jsp，服务器再次对客户端浏览器做出响应。重定向以上两种情况，你都需要考虑Servlet处理完后，数据如何在jsp页面上呈现。图例是请求、响应的流程，没有标明数据如何处理、展现。 二、转发和重定向的路径问题1）使用相对路径在重定向和转发中没有区别2）重定向和请求转发使用绝对路径时，根/路径代表了不同含义重定向response.sendRedirect(“xxx”)是服务器向客户端发送一个请求头信息，由客户端再请求一次服务器。/指的Tomcat的根目录,写绝对路径应该写成”/当前Web程序根名称/资源名” 。如”/WebModule/login.jsp”,”/bbs/servlet/LoginServlet”转发是在服务器内部进行的，写绝对路径/开头指的是当前的Web应用程序。绝对路径写法就是是”/login.jsp”或”/servlet/LoginServlet”。 总结：以上要注意是区分是从服务器外的请求，还在是内部转发，从服务器外的请求，从Tomcat根写起(就是要包括当前Web的根)；是服务器内部的转发，很简单了，因为在当前服务器内，/写起指的就是当前Web的根目录。 三、转发和重定向的区别 request.getRequestDispatcher()是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；服务器内部转发，整个过程处于同一个请求当中。response.sendRedirect()则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。不在同一个请求。重定向，实际上客户端会向服务器端发送两个请求。所以转发中数据的存取可以用request作用域：request.setAttribute(), request.getAttribute()，重定向是取不到request中的数据的。只能用session。 forward()更加高效，在可以满足需要时，尽量使用RequestDispatcher.forward()方法。（思考一下为什么？） RequestDispatcher是通过调用HttpServletRequest对象的getRequestDispatcher()方法得到的，是属于请求对象的方法。sendRedirect()是HttpServletResponse对象的方法，即响应对象的方法，既然调用了响应对象的方法，那就表明整个请求过程已经结束了，服务器开始向客户端返回执行的结果。 重定向可以跨域访问，而转发是在web服务器内部进行的，不能跨域访问。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java框架</tag>
        <tag>java编程</tag>
        <tag>JaveEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2F2018%2F09%2F05%2FRedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Redis简介关于关系型数据库和nosql数据库 关系型数据库是基于关系表的数据库，最终会将数据持久化到磁盘上，而nosql数据 库是基于特殊的结构，并将数据存储到内存的数据库。从性能上而言，nosql数据库 要优于关系型数据库，从安全性上而言关系型数据库要优于nosql数据库，所以在实 际开发中一个项目中nosql和关系型数据库会一起使用，达到性能和安全性的双保证。 为什么要使用Redisredis在Linux上的安装 安装redis编译的c环境，yum install gcc-c++ 将redis-2.6.16.tar.gz上传到Linux系统中 解压到/usr/local下 tar -xvf redis-2.6.16.tar.gz -C /usr/local 进入redis-2.6.16目录 使用make命令编译redis 在redis-2.6.16目录中 使用make PREFIX=/usr/local/redis install命令安装redis到/usr/local/redis中 拷贝redis-2.6.16中的redis.conf到安装目录redis中 启动redis 在bin下执行命令redis-server redis.conf 如需远程连接redis，需配置redis端口6379在linux防火墙中开发 /sbin/iptables -I INPUT -p tcp —dport 6379 -j ACCEPT /etc/rc.d/init.d/iptables save 启动后看到如上欢迎页面，但此窗口不能关闭，窗口关闭就认为redis也关闭了(类似Tomcat通过bin下的startup.bat的方式) 解决方案：可以通过修改配置文件 配置redis后台启动，即服务器启动了但不会穿件控制台窗口 将redis.conf文件中的daemonize从false修改成true表示后台启动 使用命令查看6379端口是否启动ps -ef | grep redis 使用java去操作RedisRedis的常用命令 redis是一种高级的key-value的存储系统 其中的key是字符串类型，尽可能满足如下几点： key不要太长，最好不要操作1024个字节，这不仅会消耗内存还会降低查找 效率 key不要太短，如果太短会降低key的可读性 在项目中，key最好有一个统一的命名规范（根据企业的需求） 其中value 支持五种数据类型： 字符串型 string 字符串列表 lists 字符串集合 sets 有序字符串集合 sorted sets 哈希类型 hashs 我们对Redis的学习，主要是对数据的存储，下面将来学习各种Redis的数据类型的 存储操作： 存储字符串string 字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这 便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。 在Redis中字符串类型的Value最多可以容纳的数据长度是512M set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK” get key：获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。 getset key value：先获取该key的值，然后在设置该key的值。 4）incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值 为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执 行失败并返回相应的错误信息。 5）decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值 为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执 行失败并返回相应的错误信息。 6）incrby key increment：将指定的key的value原子性增加increment，如果该 key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成 整型，如hello则失败并返回错误信息 7）decrby key decrement：将指定的key的value原子性减少decrement，如果 该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能 转成整型，如hello则失败并返回错误信息 8）append key value：如果该key存在，则在原有的value后追加该值；如果该 key 不存在，则重新创建一个key/value 存储lists类型 在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表 一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不 存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移 除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是 4294967295。 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。 lpush key value1 value2…：在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。 rpush key value1、value2…：在该list的尾部添加元素 lrange key start end：获取链表中从start到end的元素的值，start、end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推… lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。 5）rpushx key value：在该list的尾部添加元素 6）lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。 7）rpop key：从尾部弹出元素。 8）rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部 9）llen key：返回指定的key关联的链表中的元素的数量。 10）lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元 素，-1代表链表的尾元素。 11）lrem key count value：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。 12）linsert key before|after pivot value：在pivot元素前或者后插入value这个 元素。 存储sets类型 在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我 们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要 说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295。 和List类型不同的是，Set集合中不允许出现重复的元素。和List类型相比，Set类 型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计 算操作，如unions、intersections和differences。由于这些操作均在服务端完成， 因此效率极高，而且也节省了大量的网络IO开销 1）sadd key value1、value2…：向set中添加数据，如果该key的值已有则不会 重复添加 2）smembers key：获取set中所有的成员 3）scard key：获取set中成员的数量 4）sismember key member：判断参数中指定的成员是否在该set中，1表示存 在，0表示不存在或者该key本身就不存在 5）srem key member1、member2…：删除set中指定的成员 6）srandmember key：随机返回set中的一个成员 7）sdiff sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有 关。即返回差集。 8）sdiffstore destination key1 key2：将key1、key2相差的成员存储在 destination上 9）sinter key[key1,key2…]：返回交集。 10）sinterstore destination key1 key2：将返回的交集存储在destination上 11）sunion key1、key2：返回并集。 12）sunionstore destination key1 key2：将返回的并集存储在destination上 存储sortedset Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出 现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分 数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然 而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score) 却是可以重复的。 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为 集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此， 即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一 特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis 同样的高效，在其它数据库中进行建模是非常困难的。 例如：游戏排名、微博热点话题等使用场景。 1）zadd key score member score2 member2 … ：将所有成员以及该成员的 分数存放到sorted-set中 2）zcard key：获取集合中的成员数量 3）zcount key min max：获取分数在[min,max]之间的成员 zincrby key increment member：设置指定成员的增加的分数。 zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数。 zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。 zrank key member：返回成员在集合中的位置。 zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。 zscore key member：返回指定成员的分数 存储hash Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所 以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果 Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash 可以存储4294967295个键值对。  1）hset key field value：为指定的key设定field/value对（键值对）。 2）hgetall key：获取key中的所有filed-vaule 3）hget key field：返回指定的key中的field的值 4）hmset key fields：设置key中的多个filed/value 5）hmget key fileds：获取key中的多个filed的值 6）hexists key field：判断指定的key中的filed是否存在 7）hlen key：获取key所包含的field的数量 8）hincrby key field increment：设置key中filed的值增加increment，如：age增加20 Redis的通用操作(见文档)Redis的特性(见文档)Redis的事务(见文档)Redis的持久化(见文档)总结： nosql redis安装——linux（重点） jedis（重点） redis的数据操作类型 5中 (了解) —- string和hash redis的其他]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发中的23种设计模式详解]]></title>
    <url>%2F2018%2F09%2F03%2FJava%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java开发中的23种设计模式详解java的设计模式大体上分为三大类： 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 设计模式遵循的原则有6个：1、开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 2、里氏代换原则（Liskov Substitution Principle） 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 使用多个隔离的借口来降低耦合度。 5、迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。 1. 工厂模式（Factory Method） 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。 1234567891011121314151617181920212223242526272829interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;class C implements food&#123;&#125;public class StaticFactory &#123; private StaticFactory()&#123;&#125; public static food getA()&#123; return new A(); &#125; public static food getB()&#123; return new B(); &#125; public static food getC()&#123; return new C(); &#125;&#125;class Client&#123; //客户端代码只需要将相应的参数传入即可得到对象 //用户不需要了解工厂类内部的逻辑。 public void get(String name)&#123; food x = null ; if ( name.equals(&quot;A&quot;)) &#123; x = StaticFactory.getA(); &#125;else if ( name.equals(&quot;B&quot;))&#123; x = StaticFactory.getB(); &#125;else &#123; x = StaticFactory.getC(); &#125; &#125;&#125; 2. 抽象工厂模式（Abstract Factory） 一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。 抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。 实例代码： 12345678910111213141516171819202122232425interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;interface produce&#123; food get();&#125;class FactoryForA implements produce&#123; @Override public food get() &#123; return new A(); &#125;&#125;class FactoryForB implements produce&#123; @Override public food get() &#123; return new B(); &#125;&#125;public class AbstractFactory &#123; public void ClientCode(String name)&#123; food x= new FactoryForA().get(); x = new FactoryForB().get(); &#125;&#125; 3. 单例模式（Singleton） 在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。 12345678910public class Singleton &#123; private Singleton()&#123;&#125; private static class SingletonBuild&#123; private static Singleton value = new Singleton(); &#125; public Singleton getInstance()&#123; return SingletonBuild.value ;&#125; &#125; 4.建造者模式（Builder） 在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？ 难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Builder &#123; static class Student&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; //构建器，利用构建器作为参数来构建Student对象 static class StudentBuilder&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; public StudentBuilder setName(String name) &#123; this.name = name; return this ; &#125; public StudentBuilder setNumber(int number) &#123; this.number = number; return this ; &#125; public StudentBuilder setSex(String sex) &#123; this.sex = sex; return this ; &#125; public StudentBuilder setAge(int age) &#123; this.age = age; return this ; &#125; public StudentBuilder setSchool(String school) &#123; this.school = school; return this ; &#125; public Student build() &#123; return new Student(this); &#125; &#125; public Student(StudentBuilder builder)&#123; this.age = builder.age; this.name = builder.name; this.number = builder.number; this.school = builder.school ; this.sex = builder.sex ; &#125; &#125; public static void main( String[] args )&#123; Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build(); Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build(); &#125;&#125; 5. 原型模式（Protype）原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。 12345678910111213141516171819202122232425262728public class Prototype implements Cloneable&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override protected Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;finally &#123; return null; &#125; &#125; public static void main ( String[] args)&#123; Prototype pro = new Prototype(); Prototype pro1 = (Prototype)pro.clone(); &#125;&#125; 此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。 6.适配器模式（Adapter）适配器模式的作用就是在原来的类上提供新功能。主要可分为3种： 类适配：创建新类，继承源类，并实现新接口，例如class adapter extends oldClass implements newFunc{}对象适配：创建新类持源类的实例，并实现新接口，例如class adapter implements newFunc { private oldClass oldInstance ;}接口适配：创建新的抽象类实现旧接口方法。例如abstract class adapter implements oldClassFunc { void newFunc();}7.装饰模式（Decorator） 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如： 12345678910111213interface Source&#123; void method();&#125;public class Decorator implements Source&#123; private Source source ; public void decotate1()&#123; System.out.println(&quot;decorate&quot;); &#125; @Override public void method() &#123; decotate1(); source.method(); &#125;&#125; 8.代理模式（Proxy）客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。 这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。 1234567891011121314151617181920interface Source&#123; void method();&#125;class OldClass implements Source&#123; @Override public void method() &#123; &#125;&#125;class Proxy implements Source&#123; private Source source = new OldClass(); void doSomething()&#123;&#125; @Override public void method() &#123; new Class1().Func1(); source.method(); new Class2().Func2(); doSomething(); &#125;&#125; 9.外观模式（Facade）为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。 1234567891011121314151617public class Facade &#123; private subSystem1 subSystem1 = new subSystem1(); private subSystem2 subSystem2 = new subSystem2(); private subSystem3 subSystem3 = new subSystem3(); public void startSystem()&#123; subSystem1.start(); subSystem2.start(); subSystem3.start(); &#125; public void stopSystem()&#123; subSystem1.stop(); subSystem2.stop(); subSystem3.stop(); &#125;&#125; 10.桥接模式（Bridge）这里引用下http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125;class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125;//客户端使用代码Shape redCircle = new Circle(100,100, 10, new RedCircle());Shape greenCircle = new Circle(100,100, 10, new GreenCircle());redCircle.draw();greenCircle.draw(); 11.组合模式（Composite） 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例： 12345678910111213141516171819202122abstract class component&#123;&#125;class File extends component&#123; String filename;&#125;class Folder extends component&#123; component[] files ; //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。 String foldername ; public Folder(component[] source)&#123; files = source ;&#125; public void scan()&#123; for ( component f:files)&#123; if ( f instanceof File)&#123; System.out.println(&quot;File &quot;+((File) f).filename); &#125;else if(f instanceof Folder)&#123; Folder e = (Folder)f ; System.out.println(&quot;Folder &quot;+e.foldername); e.scan(); &#125; &#125; &#125; &#125; 12.享元模式（Flyweight）使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。 123456789101112131415161718192021222324abstract class flywei&#123; &#125;public class Flyweight extends flywei&#123; Object obj ; public Flyweight(Object obj)&#123; this.obj = obj; &#125;&#125;class FlyweightFactory&#123; private HashMap&lt;Object,Flyweight&gt; data; public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125; public Flyweight getFlyweight(Object object)&#123; if ( data.containsKey(object))&#123; return data.get(object); &#125;else &#123; Flyweight flyweight = new Flyweight(object); data.put(object,flyweight); return flyweight; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java框架</tag>
        <tag>java编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo博客同时部署发布托管到github和coding]]></title>
    <url>%2F2018%2F08%2F30%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding%2F</url>
    <content type="text"><![CDATA[前言之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说gitcafe,但是听说gitcafe已经被coding收购了，所以就决定部署到coding。 查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。 正文_config.yml配置想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 所以我的是这样：12345deploy: type: git repo: github: git@github.com:enfang/enfang.github.io.git,master coding: git@git.coding.net:enfang/enfang.git,master 我这边提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用http的方式，只要将地址改成相应的http地址即可。 coding上创建一个新项目这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面，还不懂如何创建hexo的请看我之前的系类文章。首先我们创建一个项目，创建后进入项目的代码模块，获取到这个项目的ssh地址，我的是https://git.coding.net/enfang/enfang.git 同步本地hexo到coding上把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心如果你看过我第一篇文章里面介绍过秘钥生成。coding上的第一篇文章github上的第一篇文章 我这里直接使用之前部署github时已经生成的公钥。 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 添加后，测试公钥是否添加成功，在git bash命令输入：1ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了：1Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ] 最后使用部署命令就能把博客同步到coding上面： hexo deploy -g pages服务方式部署部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。12cd source/touch Staticfile #名字必须是Staticfile 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 注意： 如果你的项目名称跟你coding的用户名一样，比如我的用户是叫enfang,博客项目名也叫enfang那直接访问 enfang.coding.me就能访问博客，否则就要带上项目名：enfang.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了 总结到此为止，终于可以实现一次部署，github和coding两个网站同时更新。访问速度也是唰唰唰的快，忙乎了两天终于搭好了独立博客。希望对还在搭建hexo独立博客的小伙伴有帮助。本人博客效果效果展示 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>github博客</tag>
        <tag>hexo博客</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加在线联系功能]]></title>
    <url>%2F2018%2F08%2F29%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo博客添加在线联系功能Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:配置方法如下:首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件_config.yml，添加如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。 需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置: 最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:效果展示: 酱油哥博客 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>github博客</tag>
        <tag>hexo博客</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用方法]]></title>
    <url>%2F2018%2F08%2F27%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown的使用方法第一步：下载markdown进入markdown官网，选择download，进行下载。 列表1 列表2 a 子列表1 b 子列表2 列表3 链接举例酱油哥博客斜体字体加粗 分割线 &lt;html&gt;&lt;/html&gt; 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;markdown使用&lt;/tile&gt; &lt;head&gt; &lt;body&gt;&lt;body&gt;&lt;/html&gt; 引用 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>github博客</tag>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客及美化]]></title>
    <url>%2F2018%2F08%2F26%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_hexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github一步步搭建属于自己的博客（基础篇） 1、准备工作安装Node.js和配置好Node.js环境，打开cmd命令行，输入：1node -v 安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入：1git --version 2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面12d:cd blog 命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步输入hexo init，初始化该文件夹（有点漫长的等待。。。）输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址，正式体验Hexo问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。4、将本地博客部署到github网站上去。将Hexo与Github page联系起来，设置Git的user name和email 设置Git的user name和email a 在博客blog目录下，右键选Git Baes Here,命令行中输入，其中的name和email替换成你自己的用户名和邮箱 12$ git config --global user.name &quot;Name&quot;$ git config --global user.email &quot;email@example.com&quot; 输入输入cd ~/.ssh,检查是否由.ssh的文件夹 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了5、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）1234deploy: type: git repo: git@github.com:enfangzhong/enfangzhong.github.io.git branch: master repo值是你在github项目里的ssh（右下角）6、新建一篇博客，在cmd执行命令：hexo new post “博客名”1hexo new post &quot;你好，酱油哥&quot; 这时候在文件夹_posts目录下将会看到已经创建的文件在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git —save使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧主题优化展示: 酱油哥 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>github博客</tag>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客_主题优化篇]]></title>
    <url>%2F2018%2F08%2F26%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Hexo个人博客_主题优化篇 1、Hexo访问统计功能Hexo Next 解决 Busuanzi 统计浏览失效1node -v 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧主题优化展示: 酱油哥 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>github博客</tag>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客写文章模板]]></title>
    <url>%2F2017%2F02%2F01%2Fhexo%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[[TOC] 一级标题]]></content>
      <categories>
        <category>hexo博客模板</category>
        <category>hexo</category>
        <category>博客模板</category>
      </categories>
      <tags>
        <tag>hexo博客模板</tag>
        <tag>hexo</tag>
        <tag>博客模板</tag>
      </tags>
  </entry>
</search>

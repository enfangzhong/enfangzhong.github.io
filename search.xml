<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java开发中的23种设计模式详解]]></title>
    <url>%2F2018%2F09%2F03%2FJava%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[title: Hexo博客添加在线联系功能date: 2018-08-29 21:03:11tags: - 博客 - git - hexo - 博客优化 categories: 搭建博客Java开发中的23种设计模式详解java的设计模式大体上分为三大类： 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 设计模式遵循的原则有6个：1、开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 2、里氏代换原则（Liskov Substitution Principle） 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 使用多个隔离的借口来降低耦合度。 5、迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。 1. 工厂模式（Factory Method） 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。 1234567891011121314151617181920212223242526272829interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;class C implements food&#123;&#125;public class StaticFactory &#123; private StaticFactory()&#123;&#125; public static food getA()&#123; return new A(); &#125; public static food getB()&#123; return new B(); &#125; public static food getC()&#123; return new C(); &#125;&#125;class Client&#123; //客户端代码只需要将相应的参数传入即可得到对象 //用户不需要了解工厂类内部的逻辑。 public void get(String name)&#123; food x = null ; if ( name.equals(&quot;A&quot;)) &#123; x = StaticFactory.getA(); &#125;else if ( name.equals(&quot;B&quot;))&#123; x = StaticFactory.getB(); &#125;else &#123; x = StaticFactory.getC(); &#125; &#125;&#125; 2. 抽象工厂模式（Abstract Factory） 一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。 抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。 实例代码： 12345678910111213141516171819202122232425interface food&#123;&#125;class A implements food&#123;&#125;class B implements food&#123;&#125;interface produce&#123; food get();&#125;class FactoryForA implements produce&#123; @Override public food get() &#123; return new A(); &#125;&#125;class FactoryForB implements produce&#123; @Override public food get() &#123; return new B(); &#125;&#125;public class AbstractFactory &#123; public void ClientCode(String name)&#123; food x= new FactoryForA().get(); x = new FactoryForB().get(); &#125;&#125; 3. 单例模式（Singleton） 在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。 12345678910public class Singleton &#123; private Singleton()&#123;&#125; private static class SingletonBuild&#123; private static Singleton value = new Singleton(); &#125; public Singleton getInstance()&#123; return SingletonBuild.value ;&#125; &#125; 4.建造者模式（Builder） 在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？ 难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Builder &#123; static class Student&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; //构建器，利用构建器作为参数来构建Student对象 static class StudentBuilder&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; public StudentBuilder setName(String name) &#123; this.name = name; return this ; &#125; public StudentBuilder setNumber(int number) &#123; this.number = number; return this ; &#125; public StudentBuilder setSex(String sex) &#123; this.sex = sex; return this ; &#125; public StudentBuilder setAge(int age) &#123; this.age = age; return this ; &#125; public StudentBuilder setSchool(String school) &#123; this.school = school; return this ; &#125; public Student build() &#123; return new Student(this); &#125; &#125; public Student(StudentBuilder builder)&#123; this.age = builder.age; this.name = builder.name; this.number = builder.number; this.school = builder.school ; this.sex = builder.sex ; &#125; &#125; public static void main( String[] args )&#123; Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build(); Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build(); &#125;&#125; 5. 原型模式（Protype）原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。 12345678910111213141516171819202122232425262728public class Prototype implements Cloneable&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override protected Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;finally &#123; return null; &#125; &#125; public static void main ( String[] args)&#123; Prototype pro = new Prototype(); Prototype pro1 = (Prototype)pro.clone(); &#125;&#125; 此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。 6.适配器模式（Adapter）适配器模式的作用就是在原来的类上提供新功能。主要可分为3种： 类适配：创建新类，继承源类，并实现新接口，例如class adapter extends oldClass implements newFunc{}对象适配：创建新类持源类的实例，并实现新接口，例如class adapter implements newFunc { private oldClass oldInstance ;}接口适配：创建新的抽象类实现旧接口方法。例如abstract class adapter implements oldClassFunc { void newFunc();}7.装饰模式（Decorator） 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如： 12345678910111213interface Source&#123; void method();&#125;public class Decorator implements Source&#123; private Source source ; public void decotate1()&#123; System.out.println(&quot;decorate&quot;); &#125; @Override public void method() &#123; decotate1(); source.method(); &#125;&#125; 8.代理模式（Proxy）客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。 这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。 1234567891011121314151617181920interface Source&#123; void method();&#125;class OldClass implements Source&#123; @Override public void method() &#123; &#125;&#125;class Proxy implements Source&#123; private Source source = new OldClass(); void doSomething()&#123;&#125; @Override public void method() &#123; new Class1().Func1(); source.method(); new Class2().Func2(); doSomething(); &#125;&#125; 9.外观模式（Facade）为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。 1234567891011121314151617public class Facade &#123; private subSystem1 subSystem1 = new subSystem1(); private subSystem2 subSystem2 = new subSystem2(); private subSystem3 subSystem3 = new subSystem3(); public void startSystem()&#123; subSystem1.start(); subSystem2.start(); subSystem3.start(); &#125; public void stopSystem()&#123; subSystem1.stop(); subSystem2.stop(); subSystem3.stop(); &#125;&#125; 10.桥接模式（Bridge）这里引用下http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125;class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125;//客户端使用代码Shape redCircle = new Circle(100,100, 10, new RedCircle());Shape greenCircle = new Circle(100,100, 10, new GreenCircle());redCircle.draw();greenCircle.draw(); 11.组合模式（Composite） 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例： 12345678910111213141516171819202122abstract class component&#123;&#125;class File extends component&#123; String filename;&#125;class Folder extends component&#123; component[] files ; //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。 String foldername ; public Folder(component[] source)&#123; files = source ;&#125; public void scan()&#123; for ( component f:files)&#123; if ( f instanceof File)&#123; System.out.println(&quot;File &quot;+((File) f).filename); &#125;else if(f instanceof Folder)&#123; Folder e = (Folder)f ; System.out.println(&quot;Folder &quot;+e.foldername); e.scan(); &#125; &#125; &#125; &#125; 12.享元模式（Flyweight）使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。 123456789101112131415161718192021222324abstract class flywei&#123; &#125;public class Flyweight extends flywei&#123; Object obj ; public Flyweight(Object obj)&#123; this.obj = obj; &#125;&#125;class FlyweightFactory&#123; private HashMap&lt;Object,Flyweight&gt; data; public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125; public Flyweight getFlyweight(Object object)&#123; if ( data.containsKey(object))&#123; return data.get(object); &#125;else &#123; Flyweight flyweight = new Flyweight(object); data.put(object,flyweight); return flyweight; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
        <category>java编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java框架</tag>
        <tag>java编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo博客同时部署发布托管到github和coding]]></title>
    <url>%2F2018%2F08%2F30%2Fhexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding%2F</url>
    <content type="text"><![CDATA[前言之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说gitcafe,但是听说gitcafe已经被coding收购了，所以就决定部署到coding。 查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。 正文_config.yml配置想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 所以我的是这样：12345deploy: type: git repo: github: git@github.com:enfang/enfang.github.io.git,master coding: git@git.coding.net:enfang/enfang.git,master 我这边提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用http的方式，只要将地址改成相应的http地址即可。 coding上创建一个新项目这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面，还不懂如何创建hexo的请看我之前的系类文章。首先我们创建一个项目，创建后进入项目的代码模块，获取到这个项目的ssh地址，我的是https://git.coding.net/enfang/enfang.git 同步本地hexo到coding上把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心如果你看过我第一篇文章里面介绍过秘钥生成。coding上的第一篇文章github上的第一篇文章 我这里直接使用之前部署github时已经生成的公钥。 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 添加后，测试公钥是否添加成功，在git bash命令输入：1ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了：1Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ] 最后使用部署命令就能把博客同步到coding上面： hexo deploy -g pages服务方式部署部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。12cd source/touch Staticfile #名字必须是Staticfile 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 注意： 如果你的项目名称跟你coding的用户名一样，比如我的用户是叫enfang,博客项目名也叫enfang那直接访问 enfang.coding.me就能访问博客，否则就要带上项目名：enfang.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了 总结到此为止，终于可以实现一次部署，github和coding两个网站同时更新。访问速度也是唰唰唰的快，忙乎了两天终于搭好了独立博客。希望对还在搭建hexo独立博客的小伙伴有帮助。本人博客效果效果展示 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建博客</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加在线联系功能]]></title>
    <url>%2F2018%2F08%2F29%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo博客添加在线联系功能Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:配置方法如下:首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件_config.yml，添加如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。 需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置: 最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:效果展示: 酱油哥博客 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建博客</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用方法]]></title>
    <url>%2F2018%2F08%2F27%2Fmarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown的使用方法第一步：下载markdown进入markdown官网，选择download，进行下载。 列表1 列表2 a 子列表1 b 子列表2 列表3 链接举例酱油哥博客斜体字体加粗 分割线 &lt;html&gt;&lt;/html&gt; 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;markdown使用&lt;/tile&gt; &lt;head&gt; &lt;body&gt;&lt;body&gt;&lt;/html&gt; 引用 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建博客</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客及美化]]></title>
    <url>%2F2018%2F08%2F26%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github一步步搭建属于自己的博客（基础篇） 1、准备工作安装Node.js和配置好Node.js环境，打开cmd命令行，输入：1node -v 安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入：1git --version 2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面12d:cd blog 命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步输入hexo init，初始化该文件夹（有点漫长的等待。。。）输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址，正式体验Hexo问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。4、将本地博客部署到github网站上去。将Hexo与Github page联系起来，设置Git的user name和email 设置Git的user name和email a 在博客blog目录下，右键选Git Baes Here,命令行中输入，其中的name和email替换成你自己的用户名和邮箱123456789101112$ git config --global user.name &quot;Name&quot;$ git config --global user.email &quot;email@example.com&quot;``` - 输入输入cd ~/.ssh,检查是否由.ssh的文件夹- 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator\.ssh）。### 登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去### 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了## 5、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） deploy: type: git repo: git@github.com:enfangzhong/enfangzhong.github.io.git branch: master1234### repo值是你在github项目里的ssh（右下角）## 6、新建一篇博客，在cmd执行命令：hexo new post “博客名” hexo new post “你好，酱油哥”` 这时候在文件夹_posts目录下将会看到已经创建的文件在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧主题优化展示: 酱油哥 欢迎访问我的博客Git托管博客效果 Coding托管博客效果 码云托管博客效果]]></content>
      <categories>
        <category>搭建博客</category>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酱油哥</title>
  
  <subtitle>喜欢一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。W我真的好想你，在每一个雨季，你选择遗忘的，是我最不舍的。W不怕万人阻挡，只怕自己投降。W成熟是给你陌生人看的，逗比是给朋友看的，幼稚是给喜欢的人看的。W人生当苦无妨，良人当归即可。W逝者如斯乎，不舍昼夜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://enfangzhong.github.io/"/>
  <updated>2018-09-03T05:31:53.456Z</updated>
  <id>http://enfangzhong.github.io/</id>
  
  <author>
    <name>酱油哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java开发中的23种设计模式详解</title>
    <link href="http://enfangzhong.github.io/2018/09/03/Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://enfangzhong.github.io/2018/09/03/Java开发中的23种设计模式详解/</id>
    <published>2018-09-03T04:58:00.000Z</published>
    <updated>2018-09-03T05:31:53.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java开发中的23种设计模式详解"><a href="#Java开发中的23种设计模式详解" class="headerlink" title="Java开发中的23种设计模式详解"></a>Java开发中的23种设计模式详解</h1><h2 id="java的设计模式大体上分为三大类："><a href="#java的设计模式大体上分为三大类：" class="headerlink" title="java的设计模式大体上分为三大类："></a>java的设计模式大体上分为三大类：</h2><ul><li>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。</li><li>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</li><li>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h2 id="设计模式遵循的原则有6个："><a href="#设计模式遵循的原则有6个：" class="headerlink" title="设计模式遵循的原则有6个："></a>设计模式遵循的原则有6个：</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>　　<strong>对扩展开放，对修改关闭</strong>。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>　　只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>　　这个是开闭原则的基础，<strong>对接口编程</strong>，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>　　使用多个隔离的借口来降低耦合度。</p><p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>　　一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>　　原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</p><h2 id="1-工厂模式（Factory-Method）"><a href="#1-工厂模式（Factory-Method）" class="headerlink" title="1. 工厂模式（Factory Method）"></a>1. 工厂模式（Factory Method）</h2><p>　　常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。</p><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface food&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A implements food&#123;&#125;</span><br><span class="line">class B implements food&#123;&#125;</span><br><span class="line">class C implements food&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line"></span><br><span class="line">    private StaticFactory()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static food getA()&#123;  return new A(); &#125;</span><br><span class="line">    public static food getB()&#123;  return new B(); &#125;</span><br><span class="line">    public static food getC()&#123;  return new C(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client&#123;</span><br><span class="line">    //客户端代码只需要将相应的参数传入即可得到对象</span><br><span class="line">    //用户不需要了解工厂类内部的逻辑。</span><br><span class="line">    public void get(String name)&#123;</span><br><span class="line">        food x = null ;</span><br><span class="line">        if ( name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            x = StaticFactory.getA();</span><br><span class="line">        &#125;else if ( name.equals(&quot;B&quot;))&#123;</span><br><span class="line">            x = StaticFactory.getB();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            x = StaticFactory.getC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-抽象工厂模式（Abstract-Factory）"><a href="#2-抽象工厂模式（Abstract-Factory）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory）"></a>2. 抽象工厂模式（Abstract Factory）</h2><p>　　一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。</p><p>　　抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。</p><p>　　实例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface food&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A implements food&#123;&#125;</span><br><span class="line">class B implements food&#123;&#125;</span><br><span class="line"></span><br><span class="line">interface produce&#123; food get();&#125;</span><br><span class="line"></span><br><span class="line">class FactoryForA implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FactoryForB implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AbstractFactory &#123;</span><br><span class="line">    public void ClientCode(String name)&#123;</span><br><span class="line">        food x= new FactoryForA().get();</span><br><span class="line">        x = new FactoryForB().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3. 单例模式（Singleton）"></a>3. 单例模式（Singleton）</h2><p> 　　在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。</p><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonBuild&#123;</span><br><span class="line">        private static Singleton value = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;  return  SingletonBuild.value ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-建造者模式（Builder）"><a href="#4-建造者模式（Builder）" class="headerlink" title="4.建造者模式（Builder）"></a>4.建造者模式（Builder）</h2><p>　　在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？</p><p>　　难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Builder &#123;</span><br><span class="line"></span><br><span class="line">    static class Student&#123;</span><br><span class="line">        String name = null ;</span><br><span class="line">        int number = -1 ;</span><br><span class="line">        String sex = null ;</span><br><span class="line">        int age = -1 ;</span><br><span class="line">        String school = null ;</span><br><span class="line"></span><br><span class="line">　　　　　//构建器，利用构建器作为参数来构建Student对象</span><br><span class="line">        static class StudentBuilder&#123;</span><br><span class="line">            String name = null ;</span><br><span class="line">            int number = -1 ;</span><br><span class="line">            String sex = null ;</span><br><span class="line">            int age = -1 ;</span><br><span class="line">            String school = null ;</span><br><span class="line">            public StudentBuilder setName(String name) &#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setNumber(int number) &#123;</span><br><span class="line">                this.number = number;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setSex(String sex) &#123;</span><br><span class="line">                this.sex = sex;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setAge(int age) &#123;</span><br><span class="line">                this.age = age;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setSchool(String school) &#123;</span><br><span class="line">                this.school = school;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line">            public Student build() &#123;</span><br><span class="line">                return new Student(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Student(StudentBuilder builder)&#123;</span><br><span class="line">            this.age = builder.age;</span><br><span class="line">            this.name = builder.name;</span><br><span class="line">            this.number = builder.number;</span><br><span class="line">            this.school = builder.school ;</span><br><span class="line">            this.sex = builder.sex ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main( String[] args )&#123;</span><br><span class="line">        Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build();</span><br><span class="line">        Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-原型模式（Protype）"><a href="#5-原型模式（Protype）" class="headerlink" title="5. 原型模式（Protype）"></a>5. 原型模式（Protype）</h2><p>原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone()   &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main ( String[] args)&#123;</span><br><span class="line">        Prototype pro = new Prototype();</span><br><span class="line">        Prototype pro1 = (Prototype)pro.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。</p><h2 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h2><p>适配器模式的作用就是在原来的类上提供新功能。主要可分为3种：</p><p>类适配：创建新类，继承源类，并实现新接口，例如<br>class  adapter extends oldClass  implements newFunc{}<br>对象适配：创建新类持源类的实例，并实现新接口，例如<br>class adapter implements newFunc { private oldClass oldInstance ;}<br>接口适配：创建新的抽象类实现旧接口方法。例如<br>abstract class adapter implements oldClassFunc { void newFunc();}<br>7.装饰模式（Decorator）<br> 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125;</span><br><span class="line">public class Decorator implements Source&#123;</span><br><span class="line"></span><br><span class="line">    private Source source ;</span><br><span class="line">    public void decotate1()&#123;</span><br><span class="line">        System.out.println(&quot;decorate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        decotate1();</span><br><span class="line">        source.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-代理模式（Proxy）"><a href="#8-代理模式（Proxy）" class="headerlink" title="8.代理模式（Proxy）"></a>8.代理模式（Proxy）</h2><p>客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。</p><p>这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125;</span><br><span class="line"></span><br><span class="line">class OldClass implements Source&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements Source&#123;</span><br><span class="line">    private Source source = new OldClass();</span><br><span class="line"></span><br><span class="line">    void doSomething()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        new Class1().Func1();</span><br><span class="line">        source.method();</span><br><span class="line">        new Class2().Func2();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-外观模式（Facade）"><a href="#9-外观模式（Facade）" class="headerlink" title="9.外观模式（Facade）"></a>9.外观模式（Facade）</h2><p>为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    private subSystem1 subSystem1 = new subSystem1();</span><br><span class="line">    private subSystem2 subSystem2 = new subSystem2();</span><br><span class="line">    private subSystem3 subSystem3 = new subSystem3();</span><br><span class="line">    </span><br><span class="line">    public void startSystem()&#123;</span><br><span class="line">        subSystem1.start();</span><br><span class="line">        subSystem2.start();</span><br><span class="line">        subSystem3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void stopSystem()&#123;</span><br><span class="line">        subSystem1.stop();</span><br><span class="line">        subSystem2.stop();</span><br><span class="line">        subSystem3.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-桥接模式（Bridge）"><a href="#10-桥接模式（Bridge）" class="headerlink" title="10.桥接模式（Bridge）"></a>10.桥接模式（Bridge）</h2><p>这里引用下<a href="http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">interface DrawAPI &#123;</span><br><span class="line">    public void drawCircle(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">class RedCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GreenCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    protected DrawAPI drawAPI;</span><br><span class="line">    protected Shape(DrawAPI drawAPI)&#123;</span><br><span class="line">        this.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    private int x, y, radius;</span><br><span class="line"></span><br><span class="line">    public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.drawCircle(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端使用代码</span><br><span class="line">Shape redCircle = new Circle(100,100, 10, new RedCircle());</span><br><span class="line">Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</span><br><span class="line">redCircle.draw();</span><br><span class="line">greenCircle.draw();</span><br></pre></td></tr></table></figure><h2 id="11-组合模式（Composite）"><a href="#11-组合模式（Composite）" class="headerlink" title="11.组合模式（Composite）"></a>11.组合模式（Composite）</h2><p> 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class component&#123;&#125;</span><br><span class="line"></span><br><span class="line">class File extends  component&#123; String filename;&#125;</span><br><span class="line"></span><br><span class="line">class Folder extends  component&#123;</span><br><span class="line">    component[] files ;  //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。</span><br><span class="line">    String foldername ;</span><br><span class="line">    public Folder(component[] source)&#123; files = source ;&#125;</span><br><span class="line">    </span><br><span class="line">    public void scan()&#123;</span><br><span class="line">        for ( component f:files)&#123;</span><br><span class="line">            if ( f instanceof File)&#123;</span><br><span class="line">                System.out.println(&quot;File &quot;+((File) f).filename);</span><br><span class="line">            &#125;else if(f instanceof Folder)&#123;</span><br><span class="line">                Folder e = (Folder)f ;</span><br><span class="line">                System.out.println(&quot;Folder &quot;+e.foldername);</span><br><span class="line">                e.scan();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-享元模式（Flyweight）"><a href="#12-享元模式（Flyweight）" class="headerlink" title="12.享元模式（Flyweight）"></a>12.享元模式（Flyweight）</h2><p>使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract class flywei&#123; &#125;</span><br><span class="line"></span><br><span class="line">public class Flyweight extends flywei&#123;</span><br><span class="line">    Object obj ;</span><br><span class="line">    public Flyweight(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  FlyweightFactory&#123;</span><br><span class="line">    private HashMap&lt;Object,Flyweight&gt; data;</span><br><span class="line"></span><br><span class="line">    public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125;</span><br><span class="line"></span><br><span class="line">    public Flyweight getFlyweight(Object object)&#123;</span><br><span class="line">        if ( data.containsKey(object))&#123;</span><br><span class="line">            return data.get(object);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Flyweight flyweight = new Flyweight(object);</span><br><span class="line">            data.put(object,flyweight);</span><br><span class="line">            return flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java开发中的23种设计模式详解&quot;&gt;&lt;a href=&quot;#Java开发中的23种设计模式详解&quot; class=&quot;headerlink&quot; title=&quot;Java开发中的23种设计模式详解&quot;&gt;&lt;/a&gt;Java开发中的23种设计模式详解&lt;/h1&gt;&lt;h2 id=&quot;java的
      
    
    </summary>
    
      <category term="设计模式" scheme="http://enfangzhong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java编程" scheme="http://enfangzhong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="http://enfangzhong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java框架" scheme="http://enfangzhong.github.io/tags/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="java编程" scheme="http://enfangzhong.github.io/tags/java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>将hexo博客同时部署发布托管到github和coding</title>
    <link href="http://enfangzhong.github.io/2018/08/30/hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/"/>
    <id>http://enfangzhong.github.io/2018/08/30/hexo博客同时部署发布托管到github和coding/</id>
    <published>2018-08-29T16:12:11.000Z</published>
    <updated>2018-09-03T05:27:47.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说gitcafe,但是听说gitcafe已经被coding收购了，所以就决定部署到coding。 查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。<br><img src="https://i.loli.net/2018/08/30/5b86d9304789a.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>_config.yml配置<br>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  message: [message]</span><br><span class="line">  repo:</span><br><span class="line">    github: &lt;repository url&gt;,[branch]</span><br><span class="line">    gitcafe: &lt;repository url&gt;,[branch]</span><br></pre></td></tr></table></figure></p><p>所以我的是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github: git@github.com:enfang/enfang.github.io.git,master</span><br><span class="line">      coding: git@git.coding.net:enfang/enfang.git,master</span><br></pre></td></tr></table></figure></p><p>我这边提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用http的方式，只要将地址改成相应的http地址即可。</p><p>coding上创建一个新项目<br>这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面，还不懂如何创建hexo的请看我之前的系类文章。首先我们创建一个项目，创建后进入项目的代码模块，获取到这个项目的ssh地址，我的是<a href="https://git.coding.net/enfang/enfang.git" target="_blank" rel="noopener">https://git.coding.net/enfang/enfang.git</a><br><img src="https://i.loli.net/2018/08/30/5b86d929e4b68.png" alt=""></p><p>同步本地hexo到coding上<br>把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心<br>如果你看过我第一篇文章里面介绍过秘钥生成。<br>coding上的<a href="http://enfang.coding.me/2018/08/26/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/#more" target="_blank" rel="noopener">第一篇文章</a><br>github上的<a href="https://enfangzhong.github.io/2018/08/26/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/#more">第一篇文章</a></p><p>我这里直接使用之前部署github时已经生成的公钥。<br><img src="https://i.loli.net/2018/08/30/5b86d92990647.png" alt=""></p><p>本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。<br><img src="https://i.loli.net/2018/08/30/5b86d92a0c55e.png" alt=""></p><p>添加后，测试公钥是否添加成功，在git bash命令输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></p><p>如果得到下面提示就表示公钥添加成功了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ]</span><br></pre></td></tr></table></figure></p><p>最后使用部署命令就能把博客同步到coding上面：</p><p>hexo deploy -g<br><img src="https://i.loli.net/2018/08/30/5b86d92a3da71.png" alt=""></p><p>pages服务方式部署<br>部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单<br>就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd source/</span><br><span class="line">touch Staticfile  #名字必须是Staticfile</span><br></pre></td></tr></table></figure></p><p>分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。</p><p><strong>注意：</strong></p><p>如果你的项目名称跟你coding的用户名一样，比如我的用户是叫enfang,博客项目名也叫enfang<br>那直接访问 enfang.coding.me就能访问博客，否则就要带上项目名：enfang.coding.me/项目名 才能访问<br>推荐项目名跟用户名一样，这样就可以省略项目名了<br><img src="https://i.loli.net/2018/08/30/5b86d92bb1a82.png" alt=""></p><p>总结<br>到此为止，终于可以实现一次部署，github和coding两个网站同时更新。访问速度也是唰唰唰的快，忙乎了两天终于搭好了独立博客。希望对还在搭建hexo独立博客的小伙伴有帮助。<br>本人博客效果<br><img src="https://i.loli.net/2018/08/30/5b86d932b57bd.png" alt=""><br><a href="https://enfangzhong.github.io/">效果展示</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说g
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="git" scheme="http://enfangzhong.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://enfangzhong.github.io/tags/hexo/"/>
    
      <category term="博客优化" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加在线联系功能</title>
    <link href="http://enfangzhong.github.io/2018/08/29/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/"/>
    <id>http://enfangzhong.github.io/2018/08/29/Hexo博客添加在线联系功能/</id>
    <published>2018-08-29T13:03:11.000Z</published>
    <updated>2018-09-03T05:16:11.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客添加在线联系功能"><a href="#Hexo博客添加在线联系功能" class="headerlink" title="Hexo博客添加在线联系功能"></a>Hexo博客添加在线联系功能</h1><p>Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。</p><p>最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:<br><img src="https://i.loli.net/2018/08/29/5b867bfc05324.png" alt=""><br>配置方法如下:<br>首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="https://i.loli.net/2018/08/29/5b867bfc134be.png" alt=""><br>以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&apos;init&apos;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&apos;update&apos;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开主题配置文件_config.yml，添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里输入前面获取的app_id</span><br></pre></td></tr></table></figure></p><p>最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。</p><p>需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:<br><img src="https://i.loli.net/2018/08/29/5b867bfc0a0c8.png" alt=""></p><p>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="https://i.loli.net/2018/08/29/5b867bfc055c2.png" alt=""><br>效果展示: <a href="https://enfangzhong.github.io/">酱油哥博客</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo博客添加在线联系功能&quot;&gt;&lt;a href=&quot;#Hexo博客添加在线联系功能&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客添加在线联系功能&quot;&gt;&lt;/a&gt;Hexo博客添加在线联系功能&lt;/h1&gt;&lt;p&gt;Hexo博客如何添加在线联系功能呢,发现了一
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="git" scheme="http://enfangzhong.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://enfangzhong.github.io/tags/hexo/"/>
    
      <category term="博客优化" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>markdown的使用方法</title>
    <link href="http://enfangzhong.github.io/2018/08/27/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://enfangzhong.github.io/2018/08/27/markdown的使用方法/</id>
    <published>2018-08-27T13:03:11.000Z</published>
    <updated>2018-09-03T05:16:03.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markDown的使用方法"><a href="#markDown的使用方法" class="headerlink" title="markDown的使用方法"></a>markDown的使用方法</h1><h2 id="第一步：下载markdown"><a href="#第一步：下载markdown" class="headerlink" title="第一步：下载markdown"></a>第一步：下载markdown</h2><h3 id="进入markdown官网，选择download，进行下载。"><a href="#进入markdown官网，选择download，进行下载。" class="headerlink" title="进入markdown官网，选择download，进行下载。"></a>进入markdown官网，选择download，进行下载。</h3><ul><li>列表1</li><li>列表2<br>  a 子列表1<br>  b 子列表2</li><li>列表3</li></ul><p>链接举例<br><a href="http://enfang.coding.me/enfang/" target="_blank" rel="noopener">酱油哥博客</a><br><img src="https://i.loli.net/2018/08/31/5b8920fdca03d.png" alt=""><br><em>斜体</em><br><strong>字体加粗</strong></p><hr><p>分割线</p><hr><p><code>&lt;html&gt;&lt;/html&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;markdown使用&lt;/tile&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;body&gt;&lt;body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><p> <strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;markDown的使用方法&quot;&gt;&lt;a href=&quot;#markDown的使用方法&quot; class=&quot;headerlink&quot; title=&quot;markDown的使用方法&quot;&gt;&lt;/a&gt;markDown的使用方法&lt;/h1&gt;&lt;h2 id=&quot;第一步：下载markdown&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="git" scheme="http://enfangzhong.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://enfangzhong.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客及美化</title>
    <link href="http://enfangzhong.github.io/2018/08/26/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/"/>
    <id>http://enfangzhong.github.io/2018/08/26/hexo+github搭建个人博客及美化更新/</id>
    <published>2018-08-26T13:03:11.000Z</published>
    <updated>2018-09-03T05:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo+Github一步步搭建属于自己的博客（基础篇）</p><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><h3 id="安装Node-js和配置好Node-js环境，打开cmd命令行，输入："><a href="#安装Node-js和配置好Node-js环境，打开cmd命令行，输入：" class="headerlink" title="安装Node.js和配置好Node.js环境，打开cmd命令行，输入："></a>安装Node.js和配置好Node.js环境，打开cmd命令行，输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git-GUI-Here和Git-Bash-Here。查看git是否安装成功，在cmd命令行中输入："><a href="#安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git-GUI-Here和Git-Bash-Here。查看git是否安装成功，在cmd命令行中输入：" class="headerlink" title="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入："></a>安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="2、Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README"><a href="#2、Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README" class="headerlink" title="2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README"></a>2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README</h2><h3 id="在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub-Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。"><a href="#在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub-Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。" class="headerlink" title="在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。"></a>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。</h3><h2 id="3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"><a href="#3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面" class="headerlink" title="3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"></a>3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><h3 id="命令行中输入npm-install-hexo-g，开始安装Hexo，等待安装完毕后进行下一步"><a href="#命令行中输入npm-install-hexo-g，开始安装Hexo，等待安装完毕后进行下一步" class="headerlink" title="命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步"></a>命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步</h3><h3 id="输入hexo-init，初始化该文件夹（有点漫长的等待。。。）"><a href="#输入hexo-init，初始化该文件夹（有点漫长的等待。。。）" class="headerlink" title="输入hexo init，初始化该文件夹（有点漫长的等待。。。）"></a>输入hexo init，初始化该文件夹（有点漫长的等待。。。）</h3><h3 id="输入npm-install，安装所需要的组件"><a href="#输入npm-install，安装所需要的组件" class="headerlink" title="输入npm install，安装所需要的组件"></a>输入npm install，安装所需要的组件</h3><h3 id="输入hexo-g，首次体验Hexo"><a href="#输入hexo-g，首次体验Hexo" class="headerlink" title="输入hexo g，首次体验Hexo"></a>输入hexo g，首次体验Hexo</h3><h3 id="输入hexo-s，开启服务器，访问该网址，正式体验Hexo"><a href="#输入hexo-s，开启服务器，访问该网址，正式体验Hexo" class="headerlink" title="输入hexo s，开启服务器，访问该网址，正式体验Hexo"></a>输入hexo s，开启服务器，访问该网址，正式体验Hexo</h3><h3 id="问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl-c停止服务器，接着输入“hexo-server-p-端口号”来改变端口号，如何在浏览器中输入：localhost-端口号，你就可以在本地查看部署好的个人博客项目了。"><a href="#问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl-c停止服务器，接着输入“hexo-server-p-端口号”来改变端口号，如何在浏览器中输入：localhost-端口号，你就可以在本地查看部署好的个人博客项目了。" class="headerlink" title="问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。"></a>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。</h3><h2 id="4、将本地博客部署到github网站上去。"><a href="#4、将本地博客部署到github网站上去。" class="headerlink" title="4、将本地博客部署到github网站上去。"></a>4、将本地博客部署到github网站上去。</h2><h3 id="将Hexo与Github-page联系起来，设置Git的user-name和email"><a href="#将Hexo与Github-page联系起来，设置Git的user-name和email" class="headerlink" title="将Hexo与Github page联系起来，设置Git的user name和email"></a>将Hexo与Github page联系起来，设置Git的user name和email</h3><ul><li>设置Git的user name和email<br>  a 在博客blog目录下，右键选Git Baes Here,命令行中输入，其中的name和email替换成你自己的用户名和邮箱<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br><span class="line">``` </span><br><span class="line">- 输入输入cd ~/.ssh,检查是否由.ssh的文件夹</span><br><span class="line">- 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator\.ssh）。</span><br><span class="line"></span><br><span class="line">### 登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</span><br><span class="line"></span><br><span class="line">### 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</span><br></pre></td></tr></table></figure></li></ul><p>deploy:<br>  type: git<br>  repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:enfangzhong/enfangzhong.github.io.git<br>  branch: master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### repo值是你在github项目里的ssh（右下角）</span><br><span class="line"></span><br><span class="line">## 6、新建一篇博客，在cmd执行命令：hexo new post “博客名”</span><br></pre></td></tr></table></figure></p><p>hexo new post “你好，酱油哥”<br><code>`</code></p><h3 id="这时候在文件夹-posts目录下将会看到已经创建的文件"><a href="#这时候在文件夹-posts目录下将会看到已经创建的文件" class="headerlink" title="这时候在文件夹_posts目录下将会看到已经创建的文件"></a>这时候在文件夹_posts目录下将会看到已经创建的文件</h3><h3 id="在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-–save"><a href="#在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-–save" class="headerlink" title="在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save"></a>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</h3><h3 id="使用编辑器编好文章，那么就可以使用命令：hexo-d-g，生成以及部署了"><a href="#使用编辑器编好文章，那么就可以使用命令：hexo-d-g，生成以及部署了" class="headerlink" title="使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了"></a>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了</h3><h3 id="部署成功后访问你的地址：http-用户名-github-io。那么将看到生成的文章"><a href="#部署成功后访问你的地址：http-用户名-github-io。那么将看到生成的文章" class="headerlink" title="部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章"></a>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</h3><h3 id="好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧"><a href="#好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧" class="headerlink" title="好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧"></a>好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧</h3><p>主题优化展示: <a href="https://enfangzhong.github.io/">酱油哥</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo+Github一步步搭建属于自己的博客（基础篇）&lt;/p&gt;
&lt;h2 id=&quot;1、准备工作&quot;&gt;&lt;a href=&quot;#1、准备工作&quot; class=&quot;headerlink&quot; title=&quot;1、准备工作&quot;&gt;&lt;/a&gt;1、准备工作&lt;/h2&gt;&lt;h3 id=&quot;安装Node-js和配
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="git" scheme="http://enfangzhong.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://enfangzhong.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>

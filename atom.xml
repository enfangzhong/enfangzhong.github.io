<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnFrank</title>
  
  <subtitle>喜欢一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。W我真的好想你，在每一个雨季，你选择遗忘的，是我最不舍的。W不怕万人阻挡，只怕自己投降。W成熟是给你陌生人看的，逗比是给朋友看的，幼稚是给喜欢的人看的。W人生当苦无妨，良人当归即可。W逝者如斯乎，不舍昼夜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://enfangzhong.github.io/"/>
  <updated>2019-05-13T07:44:38.195Z</updated>
  <id>http://enfangzhong.github.io/</id>
  
  <author>
    <name>AnFrank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的浪漫爱心表白源码</title>
    <link href="http://enfangzhong.github.io/2019/05/13/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB%E7%88%B1%E5%BF%83%E8%A1%A8%E7%99%BD%E6%BA%90%E7%A0%81/"/>
    <id>http://enfangzhong.github.io/2019/05/13/Hexo个人博客_程序员的浪漫爱心表白源码/</id>
    <published>2019-05-13T11:03:11.000Z</published>
    <updated>2019-05-13T07:44:38.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的浪漫爱心表白源码"><a href="#程序员的浪漫爱心表白源码" class="headerlink" title="程序员的浪漫爱心表白源码"></a>程序员的浪漫爱心表白源码</h1><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们程序员在追求爱情方面也是非常浪漫的，某位同学利用自己所学的HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜，这样的创意很容易打动女孩，如果你是单身的程序员，也赶紧来制作自己的爱心表白动画吧。</p><p>本人博客：<a href="https://enfangzhong.github.io/">https://enfangzhong.github.io/</a></p><h2 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h2><ul><li><p>在我们rep中，我就展示了loveheart和love-ppt两个开源的表白动画。其他我就不一一全部上线演示了。</p></li><li><p>赶紧star吧。</p><p>​</p></li></ul><blockquote><p>loveheart演示地址：<a href="https://enfangzhong.github.io/love/">https://enfangzhong.github.io/love/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-f7b6477973f86e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>love-ppt演示地址：<a href="https://enfangzhong.github.io/loveshow/">https://enfangzhong.github.io/loveshow/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-773f036e969807a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/13821160-d23105c858bf3da4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="12套表白源码展示"><a href="#12套表白源码展示" class="headerlink" title="12套表白源码展示"></a>12套表白源码展示</h3><p><img src="https://upload-images.jianshu.io/upload_images/13821160-88080f6f0e22fd4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>表白网页款式01源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-40576803f072c1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>表白网页款式02源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-a56318467e45b8b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>……….<br>……….<br>……….</p><blockquote><p>表白网页款式06源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-957555f77dfd686c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>表白网页款式07源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-a23e93d0d508b27a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>表白网页款式08源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-b6f8c34f46f3bf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>……….<br>……….<br>……….</p><blockquote><p>表白网页款式11源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-745db3e4898218ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>表白网页款式12源码</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13821160-624163a77b9bc234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>祝天下有情人终成眷属！show the love line with your Mrs.Right</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的浪漫爱心表白源码&quot;&gt;&lt;a href=&quot;#程序员的浪漫爱心表白源码&quot; class=&quot;headerlink&quot; title=&quot;程序员的浪漫爱心表白源码&quot;&gt;&lt;/a&gt;程序员的浪漫爱心表白源码&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cl
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="表白源码" scheme="http://enfangzhong.github.io/tags/%E8%A1%A8%E7%99%BD%E6%BA%90%E7%A0%81/"/>
    
      <category term="程序员表白源码" scheme="http://enfangzhong.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A1%A8%E7%99%BD%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记_02决策树与随机森林</title>
    <link href="http://enfangzhong.github.io/2019/05/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_02%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>http://enfangzhong.github.io/2019/05/13/机器学习笔记_02决策树与随机森林/</id>
    <published>2019-05-13T09:03:11.000Z</published>
    <updated>2019-05-13T02:20:00.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记-02决策树与随机森林"><a href="#机器学习笔记-02决策树与随机森林" class="headerlink" title="机器学习笔记_02决策树与随机森林"></a>机器学习笔记_02决策树与随机森林</h1><p>[TOC]</p><h1 id="从LR到决策树"><a href="#从LR到决策树" class="headerlink" title="从LR到决策树"></a>从LR到决策树</h1><h2 id="1、总体流程与核心问题"><a href="#1、总体流程与核心问题" class="headerlink" title="1、总体流程与核心问题"></a>1、总体流程与核心问题</h2><p>首先，在了解树模型之前，自然想到线性模型和树模型有什么区别呢？其中最重要的是，树形模型是一个一个特征进行处理，之前线性模型是所有特征给予权重相加得到一个新的值。决策树与逻辑回归的分类区别也在于此，逻辑回归是将所有特征通过sigmoid函数变换为概率后，通过大于某一概率阈值的划分为一类，小于某一概率阈值的为另一类；而决策树是对每一个特征做一个划分。另外逻辑回归只能找到线性分割（输入特征x与logit之间是线性的，除非对x进行多维映射），而决策树可以找到非线性分割。</p><p><strong>而树形模型更加接近人的思维方式，可以产生可视化的分类规则，产生的模型具有可解释性（可以抽取规则）。</strong>树模型拟合出来的函数其实是分区间的阶梯函数。</p><p><strong>决策树学习：采用自顶向下的递归的方法，基本思想是以信息熵为度量构造一棵熵值下降最快的树，到叶子节点处熵值为0（叶节点中的实例都属于一类）。</strong></p><p>  其次，需要了解几个重要的基本概念：根节点（最重要的特征）；父节点与子节点是一对，先有父节点，才会有子节点；叶节点（最终标签）。</p><h2 id="2、熵、信息增益、信息增益率"><a href="#2、熵、信息增益、信息增益率" class="headerlink" title="2、熵、信息增益、信息增益率"></a>2、熵、信息增益、信息增益率</h2><h3 id="信息熵-Information-Entropy"><a href="#信息熵-Information-Entropy" class="headerlink" title="信息熵(Information Entropy)"></a>信息熵(Information Entropy)</h3><p>　　信息熵是用来评估样本集合的纯度的一个参数，就是说，给出一个样本集合，这个样本集合中的样本可能属于好多不同的类别，也可能只属于一个类别，那么如果属于好多不同的类别的话，我们就说这个样本是不纯的，如果只属于一个类别，那么，我们就说这个样本是纯洁的。<br>　　而信息熵这个东西就是来计算一个样本集合中的数据是纯洁的还是不纯洁的。下面上公式：<br>　　 $Ent(D)=-\sum_{k=1}^{\left|y\right|}p_{k}log_{2}p_{k}$<br>　　下面解释一下公式的意思，其实很好理解，计算一个集合的纯度，就是把集合中每一个类别所占的比例$p_k$（k从1到 $\left | y \right |$，其中 $\left | y \right |$ 表示类别的个数）乘上它的对数，然后加到一起，然后经过计算之后，可以得到一个数据集的信息熵，然后根据信息熵，可以判断这个数据集是否纯粹。信息熵越小的话，表明这个数据集越纯粹。信息熵的最小值为0，此时数据集D中只含有一个类别。</p><h3 id="信息增益-Information-Gain"><a href="#信息增益-Information-Gain" class="headerlink" title="信息增益(Information Gain)"></a>信息增益(Information Gain)</h3><p>　　下面来介绍信息增益，所谓的信息增益，是要针对于具体的属性来讲的，比如说，数据集D中含有两个类别，分别是好人和坏人，那么，随便选择一个属性吧，比如说性别，性别这个属性中包含两个值，男人和女人，如果用男人和女人来划分数据集D的话，会得到两个集合，分别是$D_{man}$和$D_{woman}$。划分后的两个集合中各自有 好人和坏人，所以可以分别计算划分后两个集合的纯度，计算之后，把这两个集合的信息熵求加权平均$\frac{D_{man}}{D} Ent(D_{man})+\frac{D_{woman}}{D} Ent(D_{woman})$，跟之前没有划分的时候的信息熵$Ent(D)$相比较，用后者减去前者，得到的就是属性-性别对样本集D划分所得到的信息增益。可以通俗理解为，信息增益就是纯度提升值，用属性对原数据集进行划分后，得到的信息熵的差就是纯度的提升值。信息增益的公式如下： </p><p>$Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{\left | D^{v} \right |}{\left | D \right |}Ent(D^{v})$　　<br>　　先解释一下上式中的参数，D是数据集，a是选择的属性，a中一共有V个取值，用这个V取值去划分数据集D，分别得到数据集$D_1$到$D_V$，分别求这V个数据集的信息熵，并将其求加权平均。两者的差得到的就是信息增益。<br>　　那么这个信息增益有什么用呢？有用，可以根据信息增益值的大小来判断是否要用这个属性a去划分数据集D，如果得到的信息增益比较大，那么就说明这个属性是用来划分数据集D比较好的属性，否则则认为该属性不适合用来划分数据集D。这样有助于去构建决策树。<br>　　著名的<strong>算法ID3</strong>就是<strong>采用信息增益</strong>来作为判断是否用该属性划分数据集的标准。</p><h3 id="信息增益率-Information-Gain-Ratio"><a href="#信息增益率-Information-Gain-Ratio" class="headerlink" title="信息增益率(Information Gain Ratio)"></a>信息增益率(Information Gain Ratio)</h3><p>　　为什么要提出信息增益率这种评判划分属性的方法？信息增益不是就很好吗？其实不然，用信息增益作为评判划分属性的方法其实是有一定的缺陷的，书上说，信息增益准则对那些属性的取值比较多的属性有所偏好，也就是说，采用信息增益作为判定方法，会倾向于去选择属性取值比较多的属性。那么，选择取值多的属性为什么就不好了呢？举个比较极端的例子，如果将身份证号作为一个属性，那么，其实每个人的身份证号都是不相同的，也就是说，有多少个人，就有多少种取值，它的取值很多吧，让我们继续看，如果用身份证号这个属性去划分原数据集D，那么，原数据集D中有多少个样本，就会被划分为多少个子集，每个子集只有一个人，这种极端情况下，因为一个人只可能属于一种类别，好人，或者坏人，那么此时每个子集的信息熵就是0了，就是说此时每个子集都特别纯。这样的话，会导致信息增益公式的第二项$\sum_{v=1}^{V}\frac{\left | D^{v} \right |}{\left | D \right |}Ent(D^{v})$整体为0，这样导致的结果是，信息增益计算出来的特别大，然后决策树会用身份证号这个属性来划分原数据集D，其实这种划分毫无意义。因此，为了改变这种不良偏好带来的不利影响，提出了采用信息增益率作为评判划分属性的方法。<br>　　公式如下：<br>　　 $Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$<br>　　其中$IV(a)$的计算方式如下：<br>　　 $IV(a)=-\sum_{v=1}^{V}\frac{\left | D^v \right |}{\left | D \right |}log_2\frac{\left | D^v \right |}{\left | D \right |}$<br>　　$IV(a)$被称为是的“固有值”，这个$IV(a)$的公式是不是很熟悉啊，简直和信息熵的计算公式一毛一样，就是看属性a的纯度，如果a只含有少量的取值的话，那么a的纯度就比较高，否则的话，a的取值越多，a的纯度越低，$IV(a)$的值也就越大，因此，最后得到的信息增益率就越低。<br>　　采用信息增益率可以解决ID3算法中存在的问题(ID3会对那些属性的取值比较多的属性有所偏好，如西瓜的颜色有10种)，因此将采用信息增益率作为判定划分属性好坏的方法称为C4.5。<br>　　需要注意的是，<em>增益率准则对属性取值较少的时候会有偏好</em>，为了解决这个问题，C4.5并不是直接选择增益率最大的属性作为划分属性，而是之前先通过一遍筛选，先把信息增益低于平均水平的属性剔除掉，之后从剩下的属性中选择信息增益率最高的，这样的话，相当于两方面都得到了兼顾。 （结合信息增益与信息增益率使用）</p><p>采用信息增益率可以解决ID3算法中存在的问题，因此将采用信息增益率作为判定划分属性好坏的方法称为C4.5。需要注意的是，增益率准则对属性取值较少的时候会有偏好，为了解决这个问题，C4.5并不是直接选择增益率最大的属性作为划分属性，而是之前先通过一遍筛选，先把信息增益低于平均水平的属性剔除掉，之后从剩下的属性中选择信息增益率最高的，这样的话，相当于两方面都得到了兼顾。 </p><h3 id="基尼指数-gini-index-CART中使用"><a href="#基尼指数-gini-index-CART中使用" class="headerlink" title="基尼指数(gini index):CART中使用"></a>基尼指数(gini index):CART中使用</h3><p>定义：</p><ul><li>是一种不等性度量；</li><li>通常用来度量收入不平衡，可以用来度量任何不均匀分布；</li><li>是介于0~1之间的数，0-完全相等，1-完全不相等；</li><li>总体内包含的类别越杂乱，基尼指数就越大</li></ul><h4 id="基尼不纯度指标"><a href="#基尼不纯度指标" class="headerlink" title="基尼不纯度指标"></a>基尼不纯度指标</h4><p>在CART算法中, 基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。<br>假设y的可能取值为{1, 2, …, m},令fifi是样本被赋予i的概率，则基尼指数可以通过如下计算： </p><p>$\begin{aligned} \operatorname{Gini}(D) &amp;=\sum_{k=1}^{|\mathcal{Y}|} \sum_{k^{\prime} \neq k} p_{k} p_{k^{\prime}} \\ &amp;=1-\sum_{k=1}^{|\mathcal{Y}|} p_{k}^{2} \end{aligned}$</p><p>反映了从D中随机抽取两个样例，其类别标签不一致的概率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习笔记-02决策树与随机森林&quot;&gt;&lt;a href=&quot;#机器学习笔记-02决策树与随机森林&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记_02决策树与随机森林&quot;&gt;&lt;/a&gt;机器学习笔记_02决策树与随机森林&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;

      
    
    </summary>
    
      <category term="机器学习" scheme="http://enfangzhong.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://enfangzhong.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="决策树" scheme="http://enfangzhong.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
      <category term="随机森林" scheme="http://enfangzhong.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    
      <category term="信息增益" scheme="http://enfangzhong.github.io/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A/"/>
    
      <category term="信息增益率" scheme="http://enfangzhong.github.io/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E7%8E%87/"/>
    
      <category term="基尼指数" scheme="http://enfangzhong.github.io/tags/%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记_01线性回归和逻辑回归</title>
    <link href="http://enfangzhong.github.io/2019/05/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_01%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://enfangzhong.github.io/2019/05/10/机器学习笔记_01线性回归和逻辑回归/</id>
    <published>2019-05-10T09:03:11.000Z</published>
    <updated>2019-05-11T08:52:47.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记-01线性回归和逻辑回归"><a href="#机器学习笔记-01线性回归和逻辑回归" class="headerlink" title="机器学习笔记_01线性回归和逻辑回归"></a>机器学习笔记_01线性回归和逻辑回归</h1><p>[TOC]</p><h3 id="一、什么是机器学习"><a href="#一、什么是机器学习" class="headerlink" title="一、什么是机器学习"></a>一、什么是机器学习</h3><p>利用大量的数据样本，使得计算机通过不断的学习获得一个模型，用来对新的未知数据做预测。</p><ul><li><strong>有监督学习（分类、回归）</strong></li></ul><p>同时将数据样本和标签输入给模型，模型学习到数据和标签的映射关系，从而对新数据进行预测。</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-35506d38cbd5e8cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p><strong>无监督学习（聚类）</strong><br>只有数据，没有标签，模型通过总结规律，从数据中挖掘出信息。<br><img src="https://upload-images.jianshu.io/upload_images/13821160-2d6b2857e3cd1378.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p><strong>强化学习</strong><br>强化学习会在没有任何标签的情况下，通过先尝试做出一些行为得到一个结果，通过这个结果是对还是错的反馈，调整之前的行为，就这样不断的调整，算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果。</p></li></ul><p>就好比你有一只还没有训练好的小狗，每当它把屋子弄乱后，就减少美味食物的数量（惩罚），每次表现不错时，就加倍美味食物的数量（奖励），那么小狗最终会学到一个知识，就是把客厅弄乱是不好的行为。</p><p>【David Silve强化学习课程】：</p><ul><li>推荐David Silver的Reinforcement Learning Course</li><li>课件链接：<a href="https://github.com/enfangzhong/DavidSilverRLPPT" target="_blank" rel="noopener">https://github.com/enfangzhong/DavidSilverRLPPT</a></li></ul><ul><li><strong>机器学习基本术语与概念</strong><br><img src="https://upload-images.jianshu.io/upload_images/13821160-4ab12fca72407710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h3 id="二、线性回归"><a href="#二、线性回归" class="headerlink" title="二、线性回归"></a>二、线性回归</h3><p>利用大量的样本$D=\left(x_{i}, y_{i}\right)_{i=1}^{N}$，通过有监督的学习，学习到由x到y的映射f，利用该映射关系对未知的数据进行预估，因为y为连续值，所以是回归问题。<br><img src="https://upload-images.jianshu.io/upload_images/13821160-c7abfa8040768809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p><strong>单变量情况</strong><br><img src="https://upload-images.jianshu.io/upload_images/13821160-b0faa2b1aace28ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p><strong>多变量情况</strong></p></li></ul><p>二维空间的直线，转化为高维空间的平面<br><img src="https://upload-images.jianshu.io/upload_images/13821160-0d11e9c8317bd70c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="2-1-线性回归的表达式"><a href="#2-1-线性回归的表达式" class="headerlink" title="2.1 线性回归的表达式"></a>2.1 线性回归的表达式</h4><p>机器学习是数据驱动的算法，数据驱动=数据+模型，模型就是输入到输出的映射关系。</p><p><strong>模型=假设函数（不同的学习方式）+优化</strong></p><h5 id="1-假设函数"><a href="#1-假设函数" class="headerlink" title="1. 假设函数"></a><strong>1. 假设函数</strong></h5><p>线性回归的假设函数（$\theta_{0}$表示截距项，$x_0=1$,方便矩阵表达）：</p><p>$f(x)=\theta_{0} x_{0}+\theta_{1} x_{1}+\theta_{2} x_{2} \ldots+\theta_{n} x_{n}$<br>向量形式（θ,x都是列向量）：<br>$f(x)=\theta^{T} x$<br><img src="https://upload-images.jianshu.io/upload_images/13821160-f8f5cbafb89b3e1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="2-优化方法"><a href="#2-优化方法" class="headerlink" title="2. 优化方法"></a><strong>2. 优化方法</strong></h5><p>监督学习的优化方法=损失函数+对损失函数的优化</p><h5 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3. 损失函数"></a><strong>3. 损失函数</strong></h5><p><strong>如何衡量已有的参数$\theta$的好坏？</strong></p><p>利用损失函数来衡量，损失函数度量预测值和标准答案的偏差，不同的参数有不同的偏差，所以要通过最小化损失函数，也就是最小化偏差来得到最好的参数。<br>映射函数:<br>$h_{\theta}(x)$<br>损失函数：<br>$J\left(\theta_{0}, \theta_{1}, \ldots, \theta_{n}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$</p><p>解释：因为有m个样本，所以要平均，分母的2是为了求导方便</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-d443068c17710143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>最小化损失函数（ loss function）：凸函数</p><h5 id="4-损失函数的优化"><a href="#4-损失函数的优化" class="headerlink" title="4. 损失函数的优化"></a><strong>4. 损失函数的优化</strong></h5><p>损失函数如右图所示，是一个凸函数，我们的目标是达到最低点，也就是使得损失函数最小。<br><img src="https://upload-images.jianshu.io/upload_images/13821160-292b6853d5dc92f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>多元情况下容易出现局部极值</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-c63f4eea68c08364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>求极值的数学思想，对公式求导=0即可得到极值，但是工业上计算量很大，公式很复杂，所以从计算机的角度来讲，求极值是利用<strong>梯度下降</strong>法。</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-7443d50d51ca57ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>① 初始位置选取很重要</p><p>② 复梯度方向更新，二维情况下，函数变换最快的方向是斜率方向，多维情况下就成为梯度，梯度表示函数值增大的最快的方向，所以要在负梯度方向上进行迭代。</p><p>③ θ的更新公式如上图，每个参数 $\theta_1,\theta_2…$ 都是分别更新的</p><p><strong>高维情况：梯度方向就是垂直于登高线的方向</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-8d5ce93c1c479b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>参数更新示例：<br><img src="https://upload-images.jianshu.io/upload_images/13821160-de69bf224159c8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对每个theta都进行更新：</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-6bd3d85040ae207c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>学习率：</strong></p><p>① 学习率太大，会跳过最低点，可能不收敛<br>② 学习率太小收敛速度过慢<br><img src="https://upload-images.jianshu.io/upload_images/13821160-eb31e7887213a716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="5-过拟合和欠拟合（underfitting-vs-overfitting）"><a href="#5-过拟合和欠拟合（underfitting-vs-overfitting）" class="headerlink" title="5. 过拟合和欠拟合（underfitting vs overfitting）"></a><strong>5. 过拟合和欠拟合（underfitting vs overfitting）</strong></h5><p><img src="https://upload-images.jianshu.io/upload_images/13821160-badb385bdff9b674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>过拟合的原因：</strong><br>① 如果我们有很多的特征或模型很复杂，则假设函数曲线可以对训练样本拟合的非常好$\left(J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2} \approx 0\right)$，学习能力太强了，但是丧失了一般性。从而导致对新给的待预测样本，预测效果差.<br>② 眼见不一定为实，训练样本中肯定存在噪声点，如果全都学习的话肯定会将噪声也学习进去。</p><p><strong>过拟合造成什么结果：</strong></p><p>过拟合是给参数的自由空间太大了，可以通过简单的方式让参数变化太快，并未学习到底层的规律，模型抖动太大，很不稳定，variance变大，对新数据没有泛化能力。</p><p>所有的模型都可能存在过拟合的风险：</p><ul><li>更多的参数，更复杂的模型，意味着有更强的能力， 但也更可能无法无天</li><li>眼见不一定为实，你看到的内容不一定是全部真实的数据分布，死记硬背不太好</li></ul><h5 id="6-利用正则化解决过拟合问题"><a href="#6-利用正则化解决过拟合问题" class="headerlink" title="6. 利用正则化解决过拟合问题"></a><strong>6. 利用正则化解决过拟合问题</strong></h5><p>正则化的作用：</p><p>① 控制参数变化幅度，对变化大的参数惩罚，不让模型“无法无天”</p><p>② 限制参数搜索空间</p><p>添加正则化的损失函数<br>$J\left(\theta_{0}, \theta_{1}, \ldots, \theta_{n}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}-y^{(i)}\right)^{2}+\frac{\lambda}{2 m} \sum_{j=1}^{n} \theta_{j}^{2}\right.$</p><p>m：样本有m个<br>n：n个参数，对n个参数进行惩罚<br>λ：对误差的惩罚程度，λ 越大对误差的惩罚越大，容易出现过拟合，λ越小，对误差的惩罚越小，对误差的容忍度越大，泛化能力好。</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-178c1c611a9baa50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="7-线性回归代码实例"><a href="#7-线性回归代码实例" class="headerlink" title="7. 线性回归代码实例"></a><strong>7. 线性回归代码实例</strong></h5><p><img src="https://upload-images.jianshu.io/upload_images/13821160-a9ce7b446e79d84e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="三、逻辑回归"><a href="#三、逻辑回归" class="headerlink" title="三、逻辑回归"></a>三、逻辑回归</h3><p>监督学习，解决二分类问题。</p><p>分类的本质：在空间中找到一个决策边界来完成分类的决策</p><p>逻辑回归：线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。所以逻辑回归就是将线性回归的$(-\infty,+\infty)$结果，通过sigmoid函数映射到(0,1) 之间。<br>线性回归决策函数：$h_{\theta}(x)=\theta^{T} x$</p><p><strong>sigmoid函数：</strong><br>$g(z)=\frac{1}{1+e^{-z}}$</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-94308262a2bd4d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>① 可以对$(-\infty,+\infty)$结果，映射到(0,1) 之间，作为概率。</p><p>② $x<0,$ sigmoid(x)$<\frac{1}{2}="" ;="" x="">0,$ sigmoid $(x)&gt;\frac{1}{2}$，可以将$ \frac{1}{2} $作为决策边界。</0,$></p><p>③ 数学特性好，求导容易：$g^{\prime}(z)=g(z) \cdot(1-g(z))$</p><h5 id="逻辑回归的决策函数"><a href="#逻辑回归的决策函数" class="headerlink" title="逻辑回归的决策函数"></a><strong>逻辑回归的决策函数</strong></h5><p>将线性回归决策函数通过sigmoid函数，获得逻辑回归的决策函数：$h_{\theta}(x)=g\left(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}\right)=\frac{1}{1+e^{-\theta^T {x}}}$</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-88532ed9a1685b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="3-1-逻辑回归的损失函数"><a href="#3-1-逻辑回归的损失函数" class="headerlink" title="3.1 逻辑回归的损失函数"></a>3.1 逻辑回归的损失函数</h4><p>线性回归的损失函数为平方损失函数，如果将其用于逻辑回归的损失函数，则其数学特性不好，有很多局部极小值，难以用梯度下降法求最优。<br>$J(\theta)=\frac{1}{m} \sum_{i=1}^{m} \frac{1}{2}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$</p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-cdf9addb70bd5a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-0b6d1fe731b0b756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>逻辑回归损失函数：对数损失函数</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-21d98340590f161d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>解释：如果一个样本为正样本，那么我们希望将其预测为正样本的概率p越大越好，也就是决策函数的值越大越好，则logp越大越好，逻辑回归的决策函数值就是样本为正的概率；</p><p>如果一个样本为负样本，那么我们希望将其预测为负样本的概率越大越好，也就是(1-p)越大越好，即log(1-p)越大越好。</p><p><strong>为什么要用log：</strong></p><p>样本集中有很多样本，要求其概率连乘，概率为(0,1)间的数，连乘越来越小，利用log变换将其变为连加，不会溢出，不会超出计算精度。</p><p><strong>逻辑回归损失函数：</strong><br><img src="https://upload-images.jianshu.io/upload_images/13821160-6344d206b32e3ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-0a3c7f18d7da5746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>$\frac{\partial J(\theta)}{\partial \theta_{j}}=\frac{1}{m}\left[\sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}\right]$</p><h4 id="3-2-逻辑回归实现多分类"><a href="#3-2-逻辑回归实现多分类" class="headerlink" title="3.2 逻辑回归实现多分类"></a>3.2 逻辑回归实现多分类</h4><p><img src="https://upload-images.jianshu.io/upload_images/13821160-e1a911c78ec981b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>一对一(one vs one)<br>一对一分类，每两个类之间构建一个分类器，共需要$\frac{N(N-1)}{2} $ 个分类器</p></li><li><p>一对多（one vs rest）<br>一对多分类器，每个分类器判断是三角形还是不是三角形，共需要N个分类器。</p></li></ul><h4 id="3-3-逻辑回归代码实现"><a href="#3-3-逻辑回归代码实现" class="headerlink" title="3.3 逻辑回归代码实现"></a>3.3 逻辑回归代码实现</h4><p><img src="https://upload-images.jianshu.io/upload_images/13821160-effbaad8b507c739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-98a0baf55abffa97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-9be3cbfb874309d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-fba5c8c8fbba9422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-d23d01f413a344d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>四、LR的特点<br>可解释性高，工业中可控度高。<br><img src="https://upload-images.jianshu.io/upload_images/13821160-2740c90b17518171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/13821160-686751f431a93f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="五、-为什么逻辑回归比线性回归好"><a href="#五、-为什么逻辑回归比线性回归好" class="headerlink" title="五、 为什么逻辑回归比线性回归好"></a>五、 为什么逻辑回归比线性回归好</h3><p>虽然逻辑回归能够用于分类，不过其本质还是线性回归。它仅在线性回归的基础上，在特征到结果的映射中加入了一层sigmoid函数（非线性）映射，即先把特征线性求和，然后使用sigmoid函数来预测。</p><p>这主要是由于线性回归在整个实数域内敏感度一致，而分类范围，需要在[0,1]之内。而逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，其回归方程与回归曲线如下图所示。逻辑曲线在z=0时，十分敏感，在z&gt;&gt;0或z&lt;&lt;0处，都不敏感，将预测值限定为(0,1)。</p><p>LR在线性回归的实数范围输出值上施加sigmoid函数将值收敛到0~1范围, 其目标函数也因此从差平方和函数变为对数损失函数, 以提供最优化所需导数（sigmoid函数是softmax函数的二元特例, 其导数均为函数值的f*(1-f)形式）。请注意, LR往往是解决二元0/1分类问题的, 只是它和线性回归耦合太紧, 不自觉也冠了个回归的名字(马甲无处不在). 若要求多元分类,就要把sigmoid换成大名鼎鼎的softmax了。</p><p>首先逻辑回归和线性回归首先都是广义的线性回归，其次经典线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数，另外线性回归在整个实数域范围内进行预测，敏感度一致，而分类范围，需要在[0,1]。逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。</p><p>逻辑回归的模型本质上是一个线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。</p><h3 id="六、-LR和SVM的关系"><a href="#六、-LR和SVM的关系" class="headerlink" title="六、 LR和SVM的关系"></a>六、 LR和SVM的关系</h3><p>1、LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题（在改进的情况下可以处理多分类问题）</p><p>2、两个方法都可以增加不同的正则化项，如l1、l2等等。所以在很多实验中，两种算法的结果是很接近的。</p><p>区别：</p><p>1、LR是参数模型，SVM是非参数模型。</p><p>2、从目标函数来看，区别在于逻辑回归采用的是logistical loss，SVM采用的是hinge loss，这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。</p><p>3、SVM的处理方法是只考虑support vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重。</p><p>4、逻辑回归相对来说模型更简单，好理解，特别是大规模线性分类时比较方便。而SVM的理解和优化相对来说复杂一些，SVM转化为对偶问题后,分类只需要计算与少数几个支持向量的距离,这个在进行复杂核函数计算时优势很明显,能够大大简化模型和计算。</p><p>5、logic 能做的 svm能做，但可能在准确率上有问题，svm能做的logic有的做不了。</p><p>博客中的PPT笔记地址：<a href="https://github.com/enfangzhong/ML_Material" target="_blank" rel="noopener">https://github.com/enfangzhong/ML_Material</a><br>（感谢七月在线机器学习课程。仅供学习交流,严禁用于商业用途）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习笔记-01线性回归和逻辑回归&quot;&gt;&lt;a href=&quot;#机器学习笔记-01线性回归和逻辑回归&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记_01线性回归和逻辑回归&quot;&gt;&lt;/a&gt;机器学习笔记_01线性回归和逻辑回归&lt;/h1&gt;&lt;p&gt;[TOC]&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://enfangzhong.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://enfangzhong.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="http://enfangzhong.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="逻辑回归" scheme="http://enfangzhong.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>SQL内连接、左外连接、右外连接、交叉连接区别</title>
    <link href="http://enfangzhong.github.io/2018/10/17/SQL%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%88%AB/"/>
    <id>http://enfangzhong.github.io/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/</id>
    <published>2018-10-17T15:08:51.000Z</published>
    <updated>2019-05-10T13:36:19.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内连接、左外连接、右外连接、交叉连接区别"><a href="#内连接、左外连接、右外连接、交叉连接区别" class="headerlink" title="内连接、左外连接、右外连接、交叉连接区别"></a>内连接、左外连接、右外连接、交叉连接区别</h2><p>在之前，我对MSSQL中的内连接和外连接所得出的数据集不是很清楚。这几天重新温习了一下SQL的书本，现在的思路应该是很清楚了，现在把自己的理解发出来给大家温习下。希望和我一样对SQL的连接语句不太理解的朋友能够有所帮助。（发这么菜的教程，各位大大们别笑话偶了，呵:D ） 有两个表A和表B。表A结构如下： Aid：int；标识种子，主键，自增ID Aname：varchar 数据情况，即用select * from A出来的记录情况如下图1所示：</p><p><img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111507739.png" alt=""><br>图1:A表数据</p><p>表B结构如下： Bid：int；标识种子，主键，自增ID Bnameid：int 数据情况，即用select * from B出来的记录情况如下图2所示：<br> <img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111601913.png" alt=""></p><p>图2:B表数据</p><p>为了把Bid和Aid加以区分，不让大家有误解，所以把Bid的起始种子设置为100。有SQL基本知识的人都知道，两个表要做连接，就必须有个连接字段，从上表中的数据可以看出，在A表中的Aid和B表中的Bnameid就是两个连接字段。下图3说明了连接的所有记录集之间的关系：<br> <img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111618065.png" alt=""><br>图3:连接关系图 </p><p>现在我们对内连接和外连接一一讲解。 1.内连接：利用内连接可获取两表的公共部分的记录，即图3的记录集C 语句如下：Select <em> from A JOIN B ON A.Aid=B.Bnameid 运行结果如下图4所示：其实select </em> from A,B where A.Aid=B.Bnameid与Select * from A JOIN B ON A.Aid=B.Bnameid的运行结果是一样的。<br> <img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111637904.png" alt=""><br>图4:内连接数据</p><p> 2.外连接：外连接分为两种，一种是左连接（Left JOIN）和右连接（Right JOIN）<br> (1)左连接（Left JOIN）：即图3公共部分记录集C＋表A记录集A1。<br> 语句如下：select * from A Left JOIN B ON A.Aid=B.Bnameid<br>运行结果如下图5所示：<br> <img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111658117.png" alt=""></p><p>图5:左连接数据</p><p>说明：在语句中，A在B的左边，并且是Left Join，所以其运算方式为：A左连接B的记录=图3公共部分记录集C＋表A记录集A1<br>在图3中即记录集C中的存在的Aid为：2 3 6 7 8<br>图1中即表A所有记录集A中存在的Aid为：1 2 3 4 5 6 7 8 9<br>表A记录集A1中存在的Aid=(图1中即A表中所有Aid)-(图3中即记录集C中存在的Aid)，最终得出为：1 4 5 9<br>由此得出图5中A左连接B的记录=图3公共部分记录集C＋表A记录集A1, 最终得出的结果图5中可以看出Bnameid及Bid非NULL的记录都为图3公共部分记录集C中的记录；Bnameid及Bid为NULL的Aid为1 4 5 9的四笔记录就是表A记录集A1中存在的Aid。</p><p>(2)右连接（Right JOIN）：即图3公共部分记录集C＋表B记录集B1。</p><p>语句如下：select * from A Right JOIN B ON A.Aid=B.Bnameid   运行结果如下图6所示：<br> <img src="/2018/10/17/SQL内连接、左外连接、右外连接、交叉连接区别/20181017111728233.png" alt=""><br>图6:右连接数据 </p><p>说明： 在语句中，A在B的左边，并且是Right Join，所以其运算方式为：A右连接B的记录=图3公共部分记录集C＋表B记录集B1<br>在图3中即记录集C中的存在的Aid为：2 3 6 7 8<br>图2中即表B所有记录集B中存在的Bnameid为：2 3 6 7 8 11<br>表B记录集B1中存在的Bnameid=(图2中即B表中所有Bnameid)-(图3中即记录集C中存在的Aid)，最终得出为：11<br>由此得出图6中A右连接B的记录=图3公共部分记录集C＋表B记录集B1, 最终得出的结果图6中可以看出Aid及Aname非NULL的记录都为图3公共部分记录集C中的记录；Aid及Aname为NULL的Aid为11的记录就是表B记录集B1中存在的Bnameid。    </p><p>交叉连接：两张表联合没有条件情况下，条数 = 图1 * 图2</p><p>交叉连接不带WHERE子句，它返回被连接的两个表所有数据行的笛卡尔积，返回结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内连接、左外连接、右外连接、交叉连接区别&quot;&gt;&lt;a href=&quot;#内连接、左外连接、右外连接、交叉连接区别&quot; class=&quot;headerlink&quot; title=&quot;内连接、左外连接、右外连接、交叉连接区别&quot;&gt;&lt;/a&gt;内连接、左外连接、右外连接、交叉连接区别&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://enfangzhong.github.io/categories/JavaWeb/"/>
    
    
      <category term="SQL内连接" scheme="http://enfangzhong.github.io/tags/SQL%E5%86%85%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="左外连接" scheme="http://enfangzhong.github.io/tags/%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="右外连接" scheme="http://enfangzhong.github.io/tags/%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="交叉连接" scheme="http://enfangzhong.github.io/tags/%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Git个人总结笔记</title>
    <link href="http://enfangzhong.github.io/2018/09/06/Git%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"/>
    <id>http://enfangzhong.github.io/2018/09/06/Git个人总结笔记/</id>
    <published>2018-09-06T03:16:28.000Z</published>
    <updated>2019-05-10T13:33:55.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git个人总结笔记"><a href="#Git个人总结笔记" class="headerlink" title="Git个人总结笔记"></a>Git个人总结笔记</h1><h2 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h2><p>使用git init命令。</p><h2 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h2><p>分两步：</p><ul><li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li><li>使用命令git commit -m <message>，完成。</message></li></ul><h2 id="查看git仓库状态"><a href="#查看git仓库状态" class="headerlink" title="查看git仓库状态"></a>查看git仓库状态</h2><p>要随时掌握工作区的状态，使用git status命令。</p><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset —hard commit_id。</p><ul><li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br>如：git reset —hard HEAD^</p></li><li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。<br>如：git reset —hard commit_id</p></li></ul><p>git diff HEAD — readme.txt：<br>查看工作区和版本库里面最新版本的区别</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>git checkout — readme.txt<br>把readme.txt文件在工作区的修改全部撤销</p><ul><li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ul><p>就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><p>git reset HEAD <file><br>可以把暂存区的修改撤销掉（unstage），重新放回工作区</file></p><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout — file。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</file></li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li></ul><p>git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。<br>git rm —cached <file>…</file></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>创建SSH Key：<br>$ ssh-keygen -t rsa -C “youremail@example.com”<br>github添加SHH</p><p>本地仓库进行远程同步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>第一次push加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来</p><p>以后只要本地作了提交，就可以通过命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p><p>远程仓库tips:</p><ul><li><p>要关联一个远程库，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git；</span><br></pre></td></tr></table></figure></li><li><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p></li></ul><h2 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><h2 id="分支管理（重要）"><a href="#分支管理（重要）" class="headerlink" title="分支管理（重要）"></a>分支管理（重要）</h2><p>master指向最新的提交<br>HEAD指向的就是当前分支</p><p>只有master分支的时候：<br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p><p><img src="/2018/09/06/Git个人总结笔记/20180906012830969.png" alt=""></p><p>从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变<br><img src="/2018/09/06/Git个人总结笔记/20180906013006354.png" alt=""><br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="/2018/09/06/Git个人总结笔记/20180906013104230.png" alt=""><br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="/2018/09/06/Git个人总结笔记/20180906013153959.png" alt=""></p><p>下面开始实战。<br>首先，我们创建dev分支，然后切换到dev分支：<br>git checkout -b dev</p><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></p><p>git branch命令查看当前分支</p><p>把dev分支的工作成果合并到master分支上:<br>git merge dev</p><p>合并后删除分支：<br>git branch -d dev</p><p>总结：<br>Git鼓励大量使用分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure></p><p>本地库上使用命令git remote add把它和码云的远程库关联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure></p><p>git remote -v查看远程库信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin    git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></p><p>删除已关联的名为origin的远程库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p><p>关联GitHub的远程库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></p><p>关联码云的远程库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee    git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee    git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github    git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github    git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure></p><p>如果要推送到码云，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure></p><h2 id="为开源项目贡献代码"><a href="#为开源项目贡献代码" class="headerlink" title="为开源项目贡献代码"></a>为开源项目贡献代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:enfangzhong/bootstrap.git</span><br></pre></td></tr></table></figure><p>添加推特公司bootstrap项目远程仓库<br>git remote add upstream git@github.com:twbs/bootstrap.git</p><p>查看建立连接的远程仓库<br><img src="/2018/09/06/Git个人总结笔记/20180906023141140.png" alt=""></p><p>1、首先拉取推特公司最新代码<br>git pull upstream master</p><p>2、自己创建分支<br>git checkout -b feature/add_sth</p><p>然后去修改你自己代码</p><p>git status查看状态</p><p>git add ./</p><p>git commit -m “add sth”</p><p>3.切换到主分支，继续拉取网上最新代码</p><p>git checkout master<br>git pull upstream master</p><p>4.切换到分支，进行测试，<br>git checkout feature/add_sth</p><p>5.合并分支<br>git rebase master</p><p>git push origin feature/add_sth</p><p><img src="/2018/09/06/Git个人总结笔记/20180906030018530.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git个人总结笔记&quot;&gt;&lt;a href=&quot;#Git个人总结笔记&quot; class=&quot;headerlink&quot; title=&quot;Git个人总结笔记&quot;&gt;&lt;/a&gt;Git个人总结笔记&lt;/h1&gt;&lt;h2 id=&quot;初始化一个Git仓库&quot;&gt;&lt;a href=&quot;#初始化一个Git仓库&quot; cla
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://enfangzhong.github.io/categories/JavaWeb/"/>
    
    
      <category term="Git" scheme="http://enfangzhong.github.io/tags/Git/"/>
    
      <category term="GiT撤销" scheme="http://enfangzhong.github.io/tags/GiT%E6%92%A4%E9%94%80/"/>
    
  </entry>
  
  <entry>
    <title>JaveEE请求转发和重定向的区别</title>
    <link href="http://enfangzhong.github.io/2018/09/05/JaveEE%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://enfangzhong.github.io/2018/09/05/JaveEE请求转发和重定向的区别/</id>
    <published>2018-09-05T06:32:29.000Z</published>
    <updated>2019-05-12T04:37:34.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、请求转发和重定向"><a href="#一、请求转发和重定向" class="headerlink" title="一、请求转发和重定向"></a>一、请求转发和重定向</h2><h3 id="请求转发："><a href="#请求转发：" class="headerlink" title="请求转发："></a>请求转发：</h3><p>request.getRequestDispatcher(URL地址).forward(request, response)</p><p>处理流程：</p><ul><li>客户端发送请求，Servlet做出业务逻辑处理。</li><li>Servlet调用forword()方法，服务器Servlet把目标资源返回给客户端浏览器。<br><img src="https://i.loli.net/2018/09/06/5b9128febacfe.png" alt=""></li></ul><h3 id="重定向："><a href="#重定向：" class="headerlink" title="重定向："></a>重定向：</h3><p>response.sendRedirect(URL地址)</p><p>处理流程：</p><ul><li>客户端发送请求，Servlet做出业务逻辑处理。</li><li>Servlet调用response.sendReadirect()方法，把要访问的目标资源作为response响应头信息发给客户端浏览器。</li><li>客户端浏览器重新访问服务器资源xxx.jsp，服务器再次对客户端浏览器做出响应。<br><img src="https://i.loli.net/2018/09/06/5b9129b0968aa.png" alt=""><br>重定向<br>以上两种情况，你都需要考虑Servlet处理完后，数据如何在jsp页面上呈现。图例是请求、响应的流程，没有标明数据如何处理、展现。</li></ul><h2 id="二、转发和重定向的路径问题"><a href="#二、转发和重定向的路径问题" class="headerlink" title="二、转发和重定向的路径问题"></a>二、转发和重定向的路径问题</h2><p>1）使用相对路径在重定向和转发中没有区别<br>2）重定向和请求转发使用绝对路径时，根/路径代表了不同含义<br>重定向response.sendRedirect(“xxx”)是服务器向客户端发送一个请求头信息，由客户端再请求一次服务器。/指的Tomcat的根目录,写绝对路径应该写成”/当前Web程序根名称/资源名” 。如”/WebModule/login.jsp”,”/bbs/servlet/LoginServlet”<br>转发是在服务器内部进行的，写绝对路径/开头指的是当前的Web应用程序。绝对路径写法就是是”/login.jsp”或”/servlet/LoginServlet”。</p><p><strong>总结：</strong>以上要注意是区分是从服务器外的请求，还在是内部转发，从服务器外的请求，从Tomcat根写起(就是要包括当前Web的根)；是服务器内部的转发，很简单了，因为在当前服务器内，/写起指的就是当前Web的根目录。</p><h2 id="三、转发和重定向的区别"><a href="#三、转发和重定向的区别" class="headerlink" title="三、转发和重定向的区别"></a>三、转发和重定向的区别</h2><ul><li><p>request.getRequestDispatcher()是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；服务器内部转发，整个过程处于同一个请求当中。<br>response.sendRedirect()则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。不在同一个请求。重定向，实际上客户端会向服务器端发送两个请求。<br>所以转发中数据的存取可以用request作用域：request.setAttribute(), request.getAttribute()，重定向是取不到request中的数据的。只能用session。</p></li><li><p>forward()更加高效，在可以满足需要时，尽量使用RequestDispatcher.forward()方法。（思考一下为什么？）</p></li><li><p>RequestDispatcher是通过调用HttpServletRequest对象的getRequestDispatcher()方法得到的，是属于请求对象的方法。<br>sendRedirect()是HttpServletResponse对象的方法，即响应对象的方法，既然调用了响应对象的方法，那就表明整个请求过程已经结束了，服务器开始向客户端返回执行的结果。</p></li><li><p>重定向可以跨域访问，而转发是在web服务器内部进行的，不能跨域访问。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、请求转发和重定向&quot;&gt;&lt;a href=&quot;#一、请求转发和重定向&quot; class=&quot;headerlink&quot; title=&quot;一、请求转发和重定向&quot;&gt;&lt;/a&gt;一、请求转发和重定向&lt;/h2&gt;&lt;h3 id=&quot;请求转发：&quot;&gt;&lt;a href=&quot;#请求转发：&quot; class=&quot;he
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://enfangzhong.github.io/categories/JavaWeb/"/>
    
    
      <category term="JaveEE" scheme="http://enfangzhong.github.io/tags/JaveEE/"/>
    
      <category term="java框架" scheme="http://enfangzhong.github.io/tags/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="java编程" scheme="http://enfangzhong.github.io/tags/java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="http://enfangzhong.github.io/2018/09/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://enfangzhong.github.io/2018/09/05/Redis学习笔记/</id>
    <published>2018-09-05T02:32:35.000Z</published>
    <updated>2019-05-10T13:39:05.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h3 id="关于关系型数据库和nosql数据库"><a href="#关于关系型数据库和nosql数据库" class="headerlink" title="关于关系型数据库和nosql数据库"></a>关于关系型数据库和nosql数据库</h3><blockquote><p>  关系型数据库是基于关系表的数据库，最终会将数据持久化到磁盘上，而nosql数据<br>  库是基于特殊的结构，并将数据存储到内存的数据库。从性能上而言，nosql数据库<br>  要优于关系型数据库，从安全性上而言关系型数据库要优于nosql数据库，所以在实<br>  际开发中一个项目中nosql和关系型数据库会一起使用，达到性能和安全性的双保证。</p></blockquote><h3 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h3><h3 id="redis在Linux上的安装"><a href="#redis在Linux上的安装" class="headerlink" title="redis在Linux上的安装"></a>redis在Linux上的安装</h3><ol><li><p>安装redis编译的c环境，yum install gcc-c++</p></li><li><p>将redis-2.6.16.tar.gz上传到Linux系统中</p></li><li><p>解压到/usr/local下 tar -xvf redis-2.6.16.tar.gz -C /usr/local</p></li><li><p>进入redis-2.6.16目录 使用make命令编译redis</p></li><li><p>在redis-2.6.16目录中 使用make PREFIX=/usr/local/redis install命令安装<br>redis到/usr/local/redis中</p></li><li><p>拷贝redis-2.6.16中的redis.conf到安装目录redis中</p></li><li><p>启动redis 在bin下执行命令redis-server redis.conf</p></li><li><p>如需远程连接redis，需配置redis端口6379在linux防火墙中开发</p></li></ol><blockquote><p>  /sbin/iptables -I INPUT -p tcp —dport 6379 -j ACCEPT</p><p>  /etc/rc.d/init.d/iptables save</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/37168456521de2f12b6616af58929fc4.png" alt=""></p><p>启动后看到如上欢迎页面，但此窗口不能关闭，窗口关闭就认为redis也关闭了(类<br>似Tomcat通过bin下的startup.bat的方式)</p><p>解决方案：可以通过修改配置文件 配置redis后台启动，即服务器启动了但不会<br>穿件控制台窗口</p><p>将redis.conf文件中的daemonize从false修改成true表示后台启动</p><p>使用命令查看6379端口是否启动ps -ef | grep redis</p><p><img src="/2018/09/05/Redis学习笔记/c7bdc26e311ca4aad1c8f0dbbde470cf.png" alt=""></p><h1 id="使用java去操作Redis"><a href="#使用java去操作Redis" class="headerlink" title="使用java去操作Redis"></a>使用java去操作Redis</h1><h1 id="Redis的常用命令"><a href="#Redis的常用命令" class="headerlink" title="Redis的常用命令"></a>Redis的常用命令</h1><blockquote><p>  redis是一种高级的key-value的存储系统</p><p>  其中的key是字符串类型，尽可能满足如下几点：</p></blockquote><ol><li><p>key不要太长，最好不要操作1024个字节，这不仅会消耗内存还会降低查找 效率</p></li><li><p>key不要太短，如果太短会降低key的可读性</p></li><li><p>在项目中，key最好有一个统一的命名规范（根据企业的需求）</p></li></ol><blockquote><p>  其中value 支持五种数据类型：</p></blockquote><ol><li><p>字符串型 string</p></li><li><p>字符串列表 lists</p></li><li><p>字符串集合 sets</p></li><li><p>有序字符串集合 sorted sets</p></li><li><p>哈希类型 hashs</p></li></ol><blockquote><p>  我们对Redis的学习，主要是对数据的存储，下面将来学习各种Redis的数据类型的<br>  存储操作：</p></blockquote><h3 id="存储字符串string"><a href="#存储字符串string" class="headerlink" title="存储字符串string"></a>存储字符串string</h3><blockquote><p>  字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这<br>  便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。<br>  在Redis中字符串类型的Value最多可以容纳的数据长度是512M</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/d719e7ea50fbb0ddd14a95366cb28382.png" alt=""></p><ol><li><p><strong>set key value</strong>：设定key持有指定的字符串value，如果该key存在则进行覆盖<br>操作。总是返回”OK”</p></li><li><p><strong>get key</strong>：获取key的value。如果与该key关联的value不是String类型，redis<br>将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返<br>回null。</p></li></ol><p><img src="/2018/09/05/Redis学习笔记/122f9d8b0eb285eb9b9adcce1830fb55.png" alt=""></p><ol><li><strong>getset key value</strong>：先获取该key的值，然后在设置该key的值。</li></ol><p><img src="/2018/09/05/Redis学习笔记/f235bea179383cbf7acba3331c2539bc.png" alt=""></p><blockquote><p>  4）<strong>incr key</strong>：将指定的key的value原子性的递增1.如果该key不存在，其初始值<br>  为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执<br>  行失败并返回相应的错误信息。</p><p>  5）<strong>decr key</strong>：将指定的key的value原子性的递减1.如果该key不存在，其初始值<br>  为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执<br>  行失败并返回相应的错误信息。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/550c428204f4d04aa54544d301edf00d.png" alt=""></p><blockquote><p>  6）<strong>incrby key increment</strong>：将指定的key的value原子性增加increment，如果该<br>  key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成<br>  整型，如hello则失败并返回错误信息</p><p>  7）<strong>decrby key decrement</strong>：将指定的key的value原子性减少decrement，如果<br>  该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能<br>  转成整型，如hello则失败并返回错误信息</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/09a5661b72a8d30fe1aaa56947a0ba24.png" alt=""></p><p><img src="/2018/09/05/Redis学习笔记/ad6001d7f725828dd13223f512d98ea4.png" alt=""></p><blockquote><p>  8）<strong>append key value</strong>：如果该key存在，则在原有的value后追加该值；如果该<br>  key 不存在，则重新创建一个key/value</p></blockquote><h3 id="存储lists类型"><a href="#存储lists类型" class="headerlink" title="存储lists类型"></a>存储lists类型</h3><blockquote><p>  在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表<br>  一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不<br>  存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移<br>  除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是<br>  4294967295。</p></blockquote><p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将<br>会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间<br>内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是<br>非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。</p><p><img src="/2018/09/05/Redis学习笔记/a95668510b8f0b7d098dc493b9a06fd0.png" alt=""></p><ol><li><p><strong>lpush key value1 value2…</strong>：在指定的key所关联的list的头部插入所有的<br>values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链<br>表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。</p></li><li><p><strong>rpush key value1、value2…</strong>：在该list的尾部添加元素</p></li><li><p><strong>lrange key start end</strong>：获取链表中从start到end的元素的值，start、end可<br>为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…</p></li></ol><p><img src="/2018/09/05/Redis学习笔记/c817bb72ebb9a912fc98728fd2555703.png" alt=""></p><ol><li><strong>lpushx key value</strong>：仅当参数中指定的key存在时（如果与key管理的list中没<br>有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。</li></ol><blockquote><p>  5）<strong>rpushx key value</strong>：在该list的尾部添加元素</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/f4168cd95ab247bffb96c7f4e53ca49c.png" alt=""></p><blockquote><p>  6）<strong>lpop key</strong>：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。</p><p>  7）<strong>rpop key</strong>：从尾部弹出元素。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/55bf55e5817df95473e372562a0c6f6d.png" alt=""></p><p><img src="/2018/09/05/Redis学习笔记/8ed2b9e5d38588b65001722cba9e596f.png" alt=""></p><blockquote><p>  8）<strong>rpoplpush resource destination</strong>：将链表中的尾部元素弹出并添加到头部</p><p>  9）<strong>llen key</strong>：返回指定的key关联的链表中的元素的数量。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/d828c877fc1d70d29c2e2874af7d3fb7.png" alt=""></p><blockquote><p>  10）<strong>lset key index<br>  value</strong>：设置链表中的index的脚标的元素值，0代表链表的头元<br>  素，-1代表链表的尾元素。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/e12c33b42ab106d631e248ee90c0bb05.png" alt=""></p><blockquote><p>  11）<strong>lrem key count<br>  value</strong>：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/3bdb15c54c9a766fb7a9607efea446b3.png" alt=""></p><blockquote><p>  12）<strong>linsert key before|after pivot<br>  value</strong>：在pivot元素前或者后插入value这个 元素。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/d3fbb6c9ed79291ca94214f2a67d00ff.png" alt=""></p><h3 id="存储sets类型"><a href="#存储sets类型" class="headerlink" title="存储sets类型"></a>存储sets类型</h3><blockquote><p>  在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我<br>  们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要<br>  说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295。</p><p>  和List类型不同的是，Set集合中不允许出现重复的元素。和List类型相比，Set类<br>  型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计<br>  算操作，如unions、intersections和differences。由于这些操作均在服务端完成，<br>  因此效率极高，而且也节省了大量的网络IO开销</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/a95668510b8f0b7d098dc493b9a06fd0.png" alt=""></p><blockquote><p>  1）sadd key value1、value2…：向set中添加数据，如果该key的值已有则不会<br>  重复添加</p><p>  2）smembers key：获取set中所有的成员</p><p>  3）scard key：获取set中成员的数量</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/a41c3bb595584719ad1f9a1f02ff08cd.png" alt=""></p><blockquote><p>  4）sismember key member：判断参数中指定的成员是否在该set中，1表示存<br>  在，0表示不存在或者该key本身就不存在</p><p>  5）srem key member1、member2…：删除set中指定的成员</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/1701297c2cd81dc7d0bda3721f10a301.png" alt=""></p><p>6）srandmember key：随机返回set中的一个成员</p><p><img src="/2018/09/05/Redis学习笔记/0b16524ef5e1db1fa4dba8226512454b.png" alt=""></p><blockquote><p>  7）sdiff sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有<br>  关。即返回差集。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/ffa48e0a498de079ab56848dda375900.png" alt=""></p><blockquote><p>  8）sdiffstore destination key1 key2：将key1、key2相差的成员存储在<br>  destination上</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/b600dad7d4568d70d774422aef6d32d1.png" alt=""></p><blockquote><p>  9）sinter key[key1,key2…]：返回交集。</p><p>  10）sinterstore destination key1 key2：将返回的交集存储在destination上</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/9a48658e5c6f7fe08177669386a8e7f1.png" alt=""></p><blockquote><p>  11）sunion key1、key2：返回并集。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/8847e09f463cee91443b06034ad63748.png" alt=""></p><blockquote><p>  12）sunionstore destination key1 key2：将返回的并集存储在destination上</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/994d5312aeb7e2fab285748c1ed4dab6.png" alt=""></p><h3 id="存储sortedset"><a href="#存储sortedset" class="headerlink" title="存储sortedset"></a>存储sortedset</h3><blockquote><p>  Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出<br>  现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分<br>  数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然<br>  而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)<br>  却是可以重复的。</p><p>  在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为<br>  集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，<br>  即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一<br>  特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis<br>  同样的高效，在其它数据库中进行建模是非常困难的。</p><p>  例如：游戏排名、微博热点话题等使用场景。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/a95668510b8f0b7d098dc493b9a06fd0.png" alt=""></p><blockquote><p>  1）<strong>zadd key score member score2 member2 …</strong> ：将所有成员以及该成员的<br>  分数存放到sorted-set中</p><p>  2）<strong>zcard key</strong>：获取集合中的成员数量</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/a9531d6a0b55abcb785b42e3e226a429.png" alt=""></p><blockquote><p>  3）<strong>zcount key min max</strong>：获取分数在[min,max]之间的成员</p><p>  zincrby key increment member：设置指定成员的增加的分数。</p><p>  zrange key start end<br>  [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数。</p><p>  zrangebyscore key min max [withscores] [limit offset<br>  count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit<br>  offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。</p><p>  zrank key member：返回成员在集合中的位置。</p><p>  zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。</p><p>  zscore key member：返回指定成员的分数</p></blockquote><h3 id="存储hash"><a href="#存储hash" class="headerlink" title="存储hash"></a>存储hash</h3><blockquote><p>  Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所<br>  以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果<br>  Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash<br>  可以存储4294967295个键值对。</p></blockquote><p><img src="/2018/09/05/Redis学习笔记/e8320268e156af3a42887d284af00fb1.png" alt=""></p><p></p><p>1）<strong>hset key field value</strong>：为指定的key设定field/value对（键值对）。</p><p>2）<strong>hgetall key：</strong>获取key中的所有filed-vaule</p><p><img src="/2018/09/05/Redis学习笔记/be52e27b0b7cb4e15cf9e125a268316f.png" alt=""></p><p>3）<strong>hget key field</strong>：返回指定的key中的field的值</p><p><img src="/2018/09/05/Redis学习笔记/347c176b3e916155debc4cd8494d9e42.png" alt=""></p><p>4）<strong>hmset key fields</strong>：设置key中的多个filed/value</p><p>5）<strong>hmget key fileds</strong>：获取key中的多个filed的值</p><p>6）<strong>hexists key field</strong>：判断指定的key中的filed是否存在</p><p>7）<strong>hlen key</strong>：获取key所包含的field的数量</p><p>8）<strong>hincrby key field increment</strong>：设置key中filed的值增加increment，如：age<br>增加20</p><h1 id="Redis的通用操作-见文档"><a href="#Redis的通用操作-见文档" class="headerlink" title="Redis的通用操作(见文档)"></a>Redis的通用操作(见文档)</h1><h1 id="Redis的特性-见文档"><a href="#Redis的特性-见文档" class="headerlink" title="Redis的特性(见文档)"></a>Redis的特性(见文档)</h1><h1 id="Redis的事务-见文档"><a href="#Redis的事务-见文档" class="headerlink" title="Redis的事务(见文档)"></a>Redis的事务(见文档)</h1><h1 id="Redis的持久化-见文档"><a href="#Redis的持久化-见文档" class="headerlink" title="Redis的持久化(见文档)"></a>Redis的持久化(见文档)</h1><p>总结：</p><ol><li><p>nosql</p></li><li><p>redis安装——linux（重点）</p></li><li><p>jedis（重点）</p></li><li><p>redis的数据操作类型 5中 (了解) —- string和hash</p></li><li><p>redis的其他</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;h3 id=&quot;关于关系型数据库和nosql数据库&quot;&gt;&lt;a href=&quot;#关于关系型数据库和nosql数据
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://enfangzhong.github.io/categories/JavaWeb/"/>
    
    
      <category term="Redis" scheme="http://enfangzhong.github.io/tags/Redis/"/>
    
      <category term="非关系型数据库" scheme="http://enfangzhong.github.io/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库" scheme="http://enfangzhong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java开发中的23种设计模式详解</title>
    <link href="http://enfangzhong.github.io/2018/09/03/Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://enfangzhong.github.io/2018/09/03/Java开发中的23种设计模式详解/</id>
    <published>2018-09-03T04:58:00.000Z</published>
    <updated>2019-05-10T12:20:46.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java开发中的23种设计模式详解"><a href="#Java开发中的23种设计模式详解" class="headerlink" title="Java开发中的23种设计模式详解"></a>Java开发中的23种设计模式详解</h1><h2 id="java的设计模式大体上分为三大类："><a href="#java的设计模式大体上分为三大类：" class="headerlink" title="java的设计模式大体上分为三大类："></a>java的设计模式大体上分为三大类：</h2><ul><li>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。</li><li>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</li><li>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h2 id="设计模式遵循的原则有6个："><a href="#设计模式遵循的原则有6个：" class="headerlink" title="设计模式遵循的原则有6个："></a>设计模式遵循的原则有6个：</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>　　<strong>对扩展开放，对修改关闭</strong>。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>　　只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>　　这个是开闭原则的基础，<strong>对接口编程</strong>，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>　　使用多个隔离的借口来降低耦合度。</p><p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>　　一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>　　原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</p><h2 id="1-工厂模式（Factory-Method）"><a href="#1-工厂模式（Factory-Method）" class="headerlink" title="1. 工厂模式（Factory Method）"></a>1. 工厂模式（Factory Method）</h2><p>　　常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。</p><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface food&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A implements food&#123;&#125;</span><br><span class="line">class B implements food&#123;&#125;</span><br><span class="line">class C implements food&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line"></span><br><span class="line">    private StaticFactory()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static food getA()&#123;  return new A(); &#125;</span><br><span class="line">    public static food getB()&#123;  return new B(); &#125;</span><br><span class="line">    public static food getC()&#123;  return new C(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client&#123;</span><br><span class="line">    //客户端代码只需要将相应的参数传入即可得到对象</span><br><span class="line">    //用户不需要了解工厂类内部的逻辑。</span><br><span class="line">    public void get(String name)&#123;</span><br><span class="line">        food x = null ;</span><br><span class="line">        if ( name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            x = StaticFactory.getA();</span><br><span class="line">        &#125;else if ( name.equals(&quot;B&quot;))&#123;</span><br><span class="line">            x = StaticFactory.getB();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            x = StaticFactory.getC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-抽象工厂模式（Abstract-Factory）"><a href="#2-抽象工厂模式（Abstract-Factory）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory）"></a>2. 抽象工厂模式（Abstract Factory）</h2><p>　　一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。</p><p>　　抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。</p><p>　　实例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface food&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A implements food&#123;&#125;</span><br><span class="line">class B implements food&#123;&#125;</span><br><span class="line"></span><br><span class="line">interface produce&#123; food get();&#125;</span><br><span class="line"></span><br><span class="line">class FactoryForA implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FactoryForB implements produce&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public food get() &#123;</span><br><span class="line">        return new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AbstractFactory &#123;</span><br><span class="line">    public void ClientCode(String name)&#123;</span><br><span class="line">        food x= new FactoryForA().get();</span><br><span class="line">        x = new FactoryForB().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3. 单例模式（Singleton）"></a>3. 单例模式（Singleton）</h2><p> 　　在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。</p><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonBuild&#123;</span><br><span class="line">        private static Singleton value = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;  return  SingletonBuild.value ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-建造者模式（Builder）"><a href="#4-建造者模式（Builder）" class="headerlink" title="4.建造者模式（Builder）"></a>4.建造者模式（Builder）</h2><p>　　在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？</p><p>　　难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Builder &#123;</span><br><span class="line"></span><br><span class="line">    static class Student&#123;</span><br><span class="line">        String name = null ;</span><br><span class="line">        int number = -1 ;</span><br><span class="line">        String sex = null ;</span><br><span class="line">        int age = -1 ;</span><br><span class="line">        String school = null ;</span><br><span class="line"></span><br><span class="line">　　　　　//构建器，利用构建器作为参数来构建Student对象</span><br><span class="line">        static class StudentBuilder&#123;</span><br><span class="line">            String name = null ;</span><br><span class="line">            int number = -1 ;</span><br><span class="line">            String sex = null ;</span><br><span class="line">            int age = -1 ;</span><br><span class="line">            String school = null ;</span><br><span class="line">            public StudentBuilder setName(String name) &#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setNumber(int number) &#123;</span><br><span class="line">                this.number = number;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setSex(String sex) &#123;</span><br><span class="line">                this.sex = sex;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setAge(int age) &#123;</span><br><span class="line">                this.age = age;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public StudentBuilder setSchool(String school) &#123;</span><br><span class="line">                this.school = school;</span><br><span class="line">                return  this ;</span><br><span class="line">            &#125;</span><br><span class="line">            public Student build() &#123;</span><br><span class="line">                return new Student(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Student(StudentBuilder builder)&#123;</span><br><span class="line">            this.age = builder.age;</span><br><span class="line">            this.name = builder.name;</span><br><span class="line">            this.number = builder.number;</span><br><span class="line">            this.school = builder.school ;</span><br><span class="line">            this.sex = builder.sex ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main( String[] args )&#123;</span><br><span class="line">        Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build();</span><br><span class="line">        Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-原型模式（Protype）"><a href="#5-原型模式（Protype）" class="headerlink" title="5. 原型模式（Protype）"></a>5. 原型模式（Protype）</h2><p>原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone()   &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main ( String[] args)&#123;</span><br><span class="line">        Prototype pro = new Prototype();</span><br><span class="line">        Prototype pro1 = (Prototype)pro.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。</p><h2 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h2><p>适配器模式的作用就是在原来的类上提供新功能。主要可分为3种：</p><p>类适配：创建新类，继承源类，并实现新接口，例如<br>class  adapter extends oldClass  implements newFunc{}<br>对象适配：创建新类持源类的实例，并实现新接口，例如<br>class adapter implements newFunc { private oldClass oldInstance ;}<br>接口适配：创建新的抽象类实现旧接口方法。例如<br>abstract class adapter implements oldClassFunc { void newFunc();}<br>7.装饰模式（Decorator）<br> 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125;</span><br><span class="line">public class Decorator implements Source&#123;</span><br><span class="line"></span><br><span class="line">    private Source source ;</span><br><span class="line">    public void decotate1()&#123;</span><br><span class="line">        System.out.println(&quot;decorate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        decotate1();</span><br><span class="line">        source.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-代理模式（Proxy）"><a href="#8-代理模式（Proxy）" class="headerlink" title="8.代理模式（Proxy）"></a>8.代理模式（Proxy）</h2><p>客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。</p><p>这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125;</span><br><span class="line"></span><br><span class="line">class OldClass implements Source&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements Source&#123;</span><br><span class="line">    private Source source = new OldClass();</span><br><span class="line"></span><br><span class="line">    void doSomething()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        new Class1().Func1();</span><br><span class="line">        source.method();</span><br><span class="line">        new Class2().Func2();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-外观模式（Facade）"><a href="#9-外观模式（Facade）" class="headerlink" title="9.外观模式（Facade）"></a>9.外观模式（Facade）</h2><p>为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    private subSystem1 subSystem1 = new subSystem1();</span><br><span class="line">    private subSystem2 subSystem2 = new subSystem2();</span><br><span class="line">    private subSystem3 subSystem3 = new subSystem3();</span><br><span class="line">    </span><br><span class="line">    public void startSystem()&#123;</span><br><span class="line">        subSystem1.start();</span><br><span class="line">        subSystem2.start();</span><br><span class="line">        subSystem3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void stopSystem()&#123;</span><br><span class="line">        subSystem1.stop();</span><br><span class="line">        subSystem2.stop();</span><br><span class="line">        subSystem3.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-桥接模式（Bridge）"><a href="#10-桥接模式（Bridge）" class="headerlink" title="10.桥接模式（Bridge）"></a>10.桥接模式（Bridge）</h2><p>这里引用下<a href="http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">interface DrawAPI &#123;</span><br><span class="line">    public void drawCircle(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">class RedCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GreenCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    protected DrawAPI drawAPI;</span><br><span class="line">    protected Shape(DrawAPI drawAPI)&#123;</span><br><span class="line">        this.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    private int x, y, radius;</span><br><span class="line"></span><br><span class="line">    public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.drawCircle(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端使用代码</span><br><span class="line">Shape redCircle = new Circle(100,100, 10, new RedCircle());</span><br><span class="line">Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</span><br><span class="line">redCircle.draw();</span><br><span class="line">greenCircle.draw();</span><br></pre></td></tr></table></figure><h2 id="11-组合模式（Composite）"><a href="#11-组合模式（Composite）" class="headerlink" title="11.组合模式（Composite）"></a>11.组合模式（Composite）</h2><p> 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class component&#123;&#125;</span><br><span class="line"></span><br><span class="line">class File extends  component&#123; String filename;&#125;</span><br><span class="line"></span><br><span class="line">class Folder extends  component&#123;</span><br><span class="line">    component[] files ;  //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。</span><br><span class="line">    String foldername ;</span><br><span class="line">    public Folder(component[] source)&#123; files = source ;&#125;</span><br><span class="line">    </span><br><span class="line">    public void scan()&#123;</span><br><span class="line">        for ( component f:files)&#123;</span><br><span class="line">            if ( f instanceof File)&#123;</span><br><span class="line">                System.out.println(&quot;File &quot;+((File) f).filename);</span><br><span class="line">            &#125;else if(f instanceof Folder)&#123;</span><br><span class="line">                Folder e = (Folder)f ;</span><br><span class="line">                System.out.println(&quot;Folder &quot;+e.foldername);</span><br><span class="line">                e.scan();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-享元模式（Flyweight）"><a href="#12-享元模式（Flyweight）" class="headerlink" title="12.享元模式（Flyweight）"></a>12.享元模式（Flyweight）</h2><p>使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract class flywei&#123; &#125;</span><br><span class="line"></span><br><span class="line">public class Flyweight extends flywei&#123;</span><br><span class="line">    Object obj ;</span><br><span class="line">    public Flyweight(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  FlyweightFactory&#123;</span><br><span class="line">    private HashMap&lt;Object,Flyweight&gt; data;</span><br><span class="line"></span><br><span class="line">    public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125;</span><br><span class="line"></span><br><span class="line">    public Flyweight getFlyweight(Object object)&#123;</span><br><span class="line">        if ( data.containsKey(object))&#123;</span><br><span class="line">            return data.get(object);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Flyweight flyweight = new Flyweight(object);</span><br><span class="line">            data.put(object,flyweight);</span><br><span class="line">            return flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java开发中的23种设计模式详解&quot;&gt;&lt;a href=&quot;#Java开发中的23种设计模式详解&quot; class=&quot;headerlink&quot; title=&quot;Java开发中的23种设计模式详解&quot;&gt;&lt;/a&gt;Java开发中的23种设计模式详解&lt;/h1&gt;&lt;h2 id=&quot;java的
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://enfangzhong.github.io/categories/JavaWeb/"/>
    
    
      <category term="java框架" scheme="http://enfangzhong.github.io/tags/java%E6%A1%86%E6%9E%B6/"/>
    
      <category term="java编程" scheme="http://enfangzhong.github.io/tags/java%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://enfangzhong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>将hexo博客同时部署发布托管到github和coding</title>
    <link href="http://enfangzhong.github.io/2018/08/30/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/"/>
    <id>http://enfangzhong.github.io/2018/08/30/Hexo个人博客_同时部署发布托管到github和coding/</id>
    <published>2018-08-29T16:12:11.000Z</published>
    <updated>2019-05-10T12:20:01.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说gitcafe,但是听说gitcafe已经被coding收购了，所以就决定部署到coding。 查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。<br><img src="https://i.loli.net/2018/08/30/5b86d9304789a.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>_config.yml配置<br>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  message: [message]</span><br><span class="line">  repo:</span><br><span class="line">    github: &lt;repository url&gt;,[branch]</span><br><span class="line">    gitcafe: &lt;repository url&gt;,[branch]</span><br></pre></td></tr></table></figure></p><p>所以我的是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github: git@github.com:enfang/enfang.github.io.git,master</span><br><span class="line">      coding: git@git.coding.net:enfang/enfang.git,master</span><br></pre></td></tr></table></figure></p><p>我这边提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用http的方式，只要将地址改成相应的http地址即可。</p><p>coding上创建一个新项目<br>这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面，还不懂如何创建hexo的请看我之前的系类文章。首先我们创建一个项目，创建后进入项目的代码模块，获取到这个项目的ssh地址，我的是<a href="https://git.coding.net/enfang/enfang.git" target="_blank" rel="noopener">https://git.coding.net/enfang/enfang.git</a><br><img src="https://i.loli.net/2018/08/30/5b86d929e4b68.png" alt=""></p><p>同步本地hexo到coding上<br>把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心<br>如果你看过我第一篇文章里面介绍过秘钥生成。<br>coding上的<a href="http://enfang.coding.me/2018/08/26/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/#more" target="_blank" rel="noopener">第一篇文章</a><br>github上的<a href="https://enfangzhong.github.io/2018/08/26/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/#more">第一篇文章</a></p><p>我这里直接使用之前部署github时已经生成的公钥。<br><img src="https://i.loli.net/2018/08/30/5b86d92990647.png" alt=""></p><p>本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。<br><img src="https://i.loli.net/2018/08/30/5b86d92a0c55e.png" alt=""></p><p>添加后，测试公钥是否添加成功，在git bash命令输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></p><p>如果得到下面提示就表示公钥添加成功了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ]</span><br></pre></td></tr></table></figure></p><p>最后使用部署命令就能把博客同步到coding上面：</p><p>hexo deploy -g<br><img src="https://i.loli.net/2018/08/30/5b86d92a3da71.png" alt=""></p><p>pages服务方式部署<br>部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单<br>就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd source/</span><br><span class="line">touch Staticfile  #名字必须是Staticfile</span><br></pre></td></tr></table></figure></p><p>分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。</p><p><strong>注意：</strong></p><p>如果你的项目名称跟你coding的用户名一样，比如我的用户是叫enfang,博客项目名也叫enfang<br>那直接访问 enfang.coding.me就能访问博客，否则就要带上项目名：enfang.coding.me/项目名 才能访问<br>推荐项目名跟用户名一样，这样就可以省略项目名了<br><img src="https://i.loli.net/2018/08/30/5b86d92bb1a82.png" alt=""></p><p>总结<br>到此为止，终于可以实现一次部署，github和coding两个网站同时更新。访问速度也是唰唰唰的快，忙乎了两天终于搭好了独立博客。希望对还在搭建hexo独立博客的小伙伴有帮助。<br>本人博客效果<br><img src="https://i.loli.net/2018/08/30/5b86d932b57bd.png" alt=""><br><a href="https://enfangzhong.github.io/">效果展示</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，之前查资料听说g
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://enfangzhong.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github博客" scheme="http://enfangzhong.github.io/tags/github%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客优化" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加在线联系功能</title>
    <link href="http://enfangzhong.github.io/2018/08/29/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/"/>
    <id>http://enfangzhong.github.io/2018/08/29/Hexo个人博客_添加在线联系功能/</id>
    <published>2018-08-29T13:03:11.000Z</published>
    <updated>2019-05-10T12:19:28.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客添加在线联系功能"><a href="#Hexo博客添加在线联系功能" class="headerlink" title="Hexo博客添加在线联系功能"></a>Hexo博客添加在线联系功能</h1><p>Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。</p><p>最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:<br><img src="https://i.loli.net/2018/08/29/5b867bfc05324.png" alt=""><br>配置方法如下:<br>首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="https://i.loli.net/2018/08/29/5b867bfc134be.png" alt=""><br>以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&apos;init&apos;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&apos;update&apos;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开主题配置文件_config.yml，添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里输入前面获取的app_id</span><br></pre></td></tr></table></figure></p><p>最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。</p><p>需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:<br><img src="https://i.loli.net/2018/08/29/5b867bfc0a0c8.png" alt=""></p><p>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="https://i.loli.net/2018/08/29/5b867bfc055c2.png" alt=""><br>效果展示: <a href="https://enfangzhong.github.io/">酱油哥博客</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo博客添加在线联系功能&quot;&gt;&lt;a href=&quot;#Hexo博客添加在线联系功能&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客添加在线联系功能&quot;&gt;&lt;/a&gt;Hexo博客添加在线联系功能&lt;/h1&gt;&lt;p&gt;Hexo博客如何添加在线联系功能呢,发现了一
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://enfangzhong.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github博客" scheme="http://enfangzhong.github.io/tags/github%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客优化" scheme="http://enfangzhong.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>markdown的使用方法</title>
    <link href="http://enfangzhong.github.io/2018/08/27/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://enfangzhong.github.io/2018/08/27/Hexo个人博客_markdown的使用方法/</id>
    <published>2018-08-27T13:03:11.000Z</published>
    <updated>2019-05-10T12:22:03.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markDown的使用方法"><a href="#markDown的使用方法" class="headerlink" title="markDown的使用方法"></a>markDown的使用方法</h1><h2 id="第一步：下载markdown"><a href="#第一步：下载markdown" class="headerlink" title="第一步：下载markdown"></a>第一步：下载markdown</h2><h3 id="进入markdown官网，选择download，进行下载。"><a href="#进入markdown官网，选择download，进行下载。" class="headerlink" title="进入markdown官网，选择download，进行下载。"></a>进入markdown官网，选择download，进行下载。</h3><ul><li>列表1</li><li>列表2<br>  a 子列表1<br>  b 子列表2</li><li>列表3</li></ul><p>链接举例<br><a href="http://enfang.coding.me/enfang/" target="_blank" rel="noopener">酱油哥博客</a><br><img src="https://i.loli.net/2018/08/31/5b8920fdca03d.png" alt=""><br><em>斜体</em><br><strong>字体加粗</strong></p><hr><p>分割线</p><hr><p><code>&lt;html&gt;&lt;/html&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;markdown使用&lt;/tile&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;body&gt;&lt;body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><p> <strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;markDown的使用方法&quot;&gt;&lt;a href=&quot;#markDown的使用方法&quot; class=&quot;headerlink&quot; title=&quot;markDown的使用方法&quot;&gt;&lt;/a&gt;markDown的使用方法&lt;/h1&gt;&lt;h2 id=&quot;第一步：下载markdown&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://enfangzhong.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github博客" scheme="http://enfangzhong.github.io/tags/github%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客_主题优化篇</title>
    <link href="http://enfangzhong.github.io/2018/08/26/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    <id>http://enfangzhong.github.io/2018/08/26/Hexo个人博客_主题优化篇/</id>
    <published>2018-08-26T13:03:11.000Z</published>
    <updated>2019-05-11T09:06:11.890Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo个人博客_主题优化篇</p><h3 id="1、Hexo访问统计功能"><a href="#1、Hexo访问统计功能" class="headerlink" title="1、Hexo访问统计功能"></a>1、Hexo访问统计功能</h3><h4 id="Hexo-Next-解决-Busuanzi-统计浏览失效"><a href="#Hexo-Next-解决-Busuanzi-统计浏览失效" class="headerlink" title="Hexo Next 解决 Busuanzi 统计浏览失效"></a>Hexo Next 解决 Busuanzi 统计浏览失效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧"><a href="#好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧" class="headerlink" title="好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧"></a>好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧</h3><p>主题优化展示: <a href="https://enfangzhong.github.io/">酱油哥</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo个人博客_主题优化篇&lt;/p&gt;
&lt;h3 id=&quot;1、Hexo访问统计功能&quot;&gt;&lt;a href=&quot;#1、Hexo访问统计功能&quot; class=&quot;headerlink&quot; title=&quot;1、Hexo访问统计功能&quot;&gt;&lt;/a&gt;1、Hexo访问统计功能&lt;/h3&gt;&lt;h4 id=&quot;Hex
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://enfangzhong.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github博客" scheme="http://enfangzhong.github.io/tags/github%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客及美化</title>
    <link href="http://enfangzhong.github.io/2018/08/26/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96%E6%9B%B4%E6%96%B0/"/>
    <id>http://enfangzhong.github.io/2018/08/26/Hexo个人博客_hexo+github搭建个人博客及美化更新/</id>
    <published>2018-08-26T13:03:11.000Z</published>
    <updated>2019-05-10T12:18:41.466Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo+Github一步步搭建属于自己的博客（基础篇）</p><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><h3 id="安装Node-js和配置好Node-js环境，打开cmd命令行，输入："><a href="#安装Node-js和配置好Node-js环境，打开cmd命令行，输入：" class="headerlink" title="安装Node.js和配置好Node.js环境，打开cmd命令行，输入："></a>安装Node.js和配置好Node.js环境，打开cmd命令行，输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git-GUI-Here和Git-Bash-Here。查看git是否安装成功，在cmd命令行中输入："><a href="#安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git-GUI-Here和Git-Bash-Here。查看git是否安装成功，在cmd命令行中输入：" class="headerlink" title="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入："></a>安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="2、Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README"><a href="#2、Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README" class="headerlink" title="2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README"></a>2、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README</h2><h3 id="在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub-Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。"><a href="#在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub-Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。" class="headerlink" title="在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。"></a>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。</h3><h2 id="3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"><a href="#3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面" class="headerlink" title="3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"></a>3、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><h3 id="命令行中输入npm-install-hexo-g，开始安装Hexo，等待安装完毕后进行下一步"><a href="#命令行中输入npm-install-hexo-g，开始安装Hexo，等待安装完毕后进行下一步" class="headerlink" title="命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步"></a>命令行中输入npm install hexo -g，开始安装Hexo，等待安装完毕后进行下一步</h3><h3 id="输入hexo-init，初始化该文件夹（有点漫长的等待。。。）"><a href="#输入hexo-init，初始化该文件夹（有点漫长的等待。。。）" class="headerlink" title="输入hexo init，初始化该文件夹（有点漫长的等待。。。）"></a>输入hexo init，初始化该文件夹（有点漫长的等待。。。）</h3><h3 id="输入npm-install，安装所需要的组件"><a href="#输入npm-install，安装所需要的组件" class="headerlink" title="输入npm install，安装所需要的组件"></a>输入npm install，安装所需要的组件</h3><h3 id="输入hexo-g，首次体验Hexo"><a href="#输入hexo-g，首次体验Hexo" class="headerlink" title="输入hexo g，首次体验Hexo"></a>输入hexo g，首次体验Hexo</h3><h3 id="输入hexo-s，开启服务器，访问该网址，正式体验Hexo"><a href="#输入hexo-s，开启服务器，访问该网址，正式体验Hexo" class="headerlink" title="输入hexo s，开启服务器，访问该网址，正式体验Hexo"></a>输入hexo s，开启服务器，访问该网址，正式体验Hexo</h3><h3 id="问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl-c停止服务器，接着输入“hexo-server-p-端口号”来改变端口号，如何在浏览器中输入：localhost-端口号，你就可以在本地查看部署好的个人博客项目了。"><a href="#问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl-c停止服务器，接着输入“hexo-server-p-端口号”来改变端口号，如何在浏览器中输入：localhost-端口号，你就可以在本地查看部署好的个人博客项目了。" class="headerlink" title="问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。"></a>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号，如何在浏览器中输入：localhost:端口号，你就可以在本地查看部署好的个人博客项目了。</h3><h2 id="4、将本地博客部署到github网站上去。"><a href="#4、将本地博客部署到github网站上去。" class="headerlink" title="4、将本地博客部署到github网站上去。"></a>4、将本地博客部署到github网站上去。</h2><h3 id="将Hexo与Github-page联系起来，设置Git的user-name和email"><a href="#将Hexo与Github-page联系起来，设置Git的user-name和email" class="headerlink" title="将Hexo与Github page联系起来，设置Git的user name和email"></a>将Hexo与Github page联系起来，设置Git的user name和email</h3><ul><li><p>设置Git的user name和email<br>  a 在博客blog目录下，右键选Git Baes Here,命令行中输入，其中的name和email替换成你自己的用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>输入输入cd ~/.ssh,检查是否由.ssh的文件夹</p></li><li>输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</li></ul><h3 id="登录Github，点击头像下的settings，添加ssh。新建一个new-ssh-key，将id-rsa-pub文件里的内容复制上去"><a href="#登录Github，点击头像下的settings，添加ssh。新建一个new-ssh-key，将id-rsa-pub文件里的内容复制上去" class="headerlink" title="登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去"></a>登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</h3><h3 id="输入ssh-T-git-github-com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了"><a href="#输入ssh-T-git-github-com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了" class="headerlink" title="输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了"></a>输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</h3><h2 id="5、配置Deployment，在其文件夹中，找到-config-yml文件，修改repo值（在末尾）"><a href="#5、配置Deployment，在其文件夹中，找到-config-yml文件，修改repo值（在末尾）" class="headerlink" title="5、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）"></a>5、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:enfangzhong/enfangzhong.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="repo值是你在github项目里的ssh（右下角）"><a href="#repo值是你在github项目里的ssh（右下角）" class="headerlink" title="repo值是你在github项目里的ssh（右下角）"></a>repo值是你在github项目里的ssh（右下角）</h3><h2 id="6、新建一篇博客，在cmd执行命令：hexo-new-post-“博客名”"><a href="#6、新建一篇博客，在cmd执行命令：hexo-new-post-“博客名”" class="headerlink" title="6、新建一篇博客，在cmd执行命令：hexo new post “博客名”"></a>6、新建一篇博客，在cmd执行命令：hexo new post “博客名”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;你好，酱油哥&quot;</span><br></pre></td></tr></table></figure><h3 id="这时候在文件夹-posts目录下将会看到已经创建的文件"><a href="#这时候在文件夹-posts目录下将会看到已经创建的文件" class="headerlink" title="这时候在文件夹_posts目录下将会看到已经创建的文件"></a>这时候在文件夹_posts目录下将会看到已经创建的文件</h3><h3 id="在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-—save"><a href="#在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-—save" class="headerlink" title="在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git —save"></a>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git —save</h3><h3 id="使用编辑器编好文章，那么就可以使用命令：hexo-d-g，生成以及部署了"><a href="#使用编辑器编好文章，那么就可以使用命令：hexo-d-g，生成以及部署了" class="headerlink" title="使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了"></a>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了</h3><h3 id="部署成功后访问你的地址：http-用户名-github-io。那么将看到生成的文章"><a href="#部署成功后访问你的地址：http-用户名-github-io。那么将看到生成的文章" class="headerlink" title="部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章"></a>部署成功后访问你的地址：<a href="http://用户名.github.io。那么将看到生成的文章" target="_blank" rel="noopener">http://用户名.github.io。那么将看到生成的文章</a></h3><h3 id="好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧"><a href="#好了，到此为止，最基本的也是最全面的hexo-github搭建博客完结。接下来进入主题优化吧" class="headerlink" title="好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧"></a>好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来进入主题优化吧</h3><p>主题优化展示: <a href="https://enfangzhong.github.io/">酱油哥</a></p><p><strong>欢迎访问我的博客</strong><br><a href="https://enfangzhong.github.io/">Git托管博客效果</a> </p><p><a href="http://enfang.coding.me/" target="_blank" rel="noopener">Coding托管博客效果</a></p><p><a href="https://itjyg.gitee.io" target="_blank" rel="noopener">码云托管博客效果</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo+Github一步步搭建属于自己的博客（基础篇）&lt;/p&gt;
&lt;h2 id=&quot;1、准备工作&quot;&gt;&lt;a href=&quot;#1、准备工作&quot; class=&quot;headerlink&quot; title=&quot;1、准备工作&quot;&gt;&lt;/a&gt;1、准备工作&lt;/h2&gt;&lt;h3 id=&quot;安装Node-js和配
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="http://enfangzhong.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://enfangzhong.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github博客" scheme="http://enfangzhong.github.io/tags/github%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo博客" scheme="http://enfangzhong.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>

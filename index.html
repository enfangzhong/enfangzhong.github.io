<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

  <script type="text/javascript" src="/js/src/crash_cheat.js"></script>
  

  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/favicon-32x32-next.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "9494e80d"
    });
  daovoice('update');
  </script>

  <meta name="description" content="你若晴天，我便安好。">
<meta name="keywords" content="AnFrank AnFrank&#39;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="AnFrank&#39;s Blog">
<meta property="og:url" content="http://enfangzhong.github.io/index.html">
<meta property="og:site_name" content="AnFrank&#39;s Blog">
<meta property="og:description" content="你若晴天，我便安好。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AnFrank&#39;s Blog">
<meta name="twitter:description" content="你若晴天，我便安好。">



  <link rel="alternate" href="/atom.xml" title="AnFrank's Blog" type="application/atom+xml">




  <link rel="canonical" href="http://enfangzhong.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>AnFrank's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">


<!-- 加入APlayer音乐播放器 -->
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>

<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>




  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>



<a href="https://github.com/enfangzhong" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><script>
 function GetRandomNum(Min,Max)
  {
    var Range = Max - Min;
    var Rand = Math.random();
    return(Min + Math.round(Rand * Range));
  }
function setSidebarMarginTop (headerOffset) {
    return $('#sidebar').css({ 'margin-top': headerOffset });
  }
 function getHeaderOffset () {
    return $('.header-inner').height() + CONFIG.sidebar.offset;
  }
  window.onload=function(){
    var subtitle = "世界真的很小，好像一转身，就不知道会遇见谁。W世界真的很大，好像一转身，就不知道谁会消失。W成熟是给你陌生人看的，逗比是给朋友看的，幼稚是给喜欢的人看的。w";
     var mytitle = subtitle.split("W");
     var max = mytitle.length-1;
     var index = GetRandomNum(0,max);
     var text = mytitle[index];
     $("#helloTitle").html(text);
     var headOffset = getHeaderOffset();
     setSidebarMarginTop(headOffset);
     //动态subtitle设置
  }
</script>

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AnFrank's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  
    <p style="color:#black;font-size:18px;font-family:STXingkai" id="helloTitle" class="site-subtitle"></p>
  

  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>微言</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-links">
    <a href="/links/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-link"></i> <br>友链</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-guestbook">
    <a href="/guestbook" rel="section">
      <i class="menu-item-icon fa fa-fw fa-comments"></i> <br>留言</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-love">
    <a href="/love/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>love</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-loveshow">
    <a href="/loveshow/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>loveshow</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>


  

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <!--轮播图-->

<script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

<style type="text/css">

.glyphicon-chevron-left:before{
	/* content: "《" */
}
.glyphicon-chevron-right:before{
	/* content: "》" */
}

.right-siders{
   border-radius: 10px;
   /*margin-top: 5px;*/
   margin-bottom: 5px;
}

.my-carousel:hover{
  margin-left: 5px;
  //padding: 5px 1px;
  border-radius: 5px;
  transform: scale(1.1);
  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);
}

@media (max-width: 767px){
	.rights{
		display: none;
	}
	.carousel{
		width: 100% !important;
		height: 100% !important;
	}
	.slide{
		width: 100% !important;
		height: 100% !important;
	}

}

.carousel{
	width: 65%;
	height: 100%;
	position: relative;
}

.carousel-inner {
  position: relative;
  overflow: hidden;
  width: 100%;
}
.carousel-inner > .item {
  display: none;
  position: relative;
  -webkit-transition: 0.6s ease-in-out left;
  -o-transition: 0.6s ease-in-out left;
  transition: 0.6s ease-in-out left;
}
.carousel-inner > .item > img,
.carousel-inner > .item > a > img {
  line-height: 1;
}
@media all and (transform-3d), (-webkit-transform-3d) {
  .carousel-inner > .item {
    -webkit-transition: -webkit-transform 0.6s ease-in-out;
    -moz-transition: -moz-transform 0.6s ease-in-out;
    -o-transition: -o-transform 0.6s ease-in-out;
    transition: transform 0.6s ease-in-out;
    -webkit-backface-visibility: hidden;
    -moz-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-perspective: 1000px;
    -moz-perspective: 1000px;
    perspective: 1000px;
  }
  .carousel-inner > .item.next,
  .carousel-inner > .item.active.right {
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.prev,
  .carousel-inner > .item.active.left {
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.next.left,
  .carousel-inner > .item.prev.right,
  .carousel-inner > .item.active {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    left: 0;
  }
}
.carousel-inner > .active,
.carousel-inner > .next,
.carousel-inner > .prev {
  display: block;
}
.carousel-inner > .active {
  left: 0;
}
.carousel-inner > .next,
.carousel-inner > .prev {
  position: absolute;
  top: 0;
  width: 100%;
}
.carousel-inner > .next {
  left: 100%;
}
.carousel-inner > .prev {
  left: -100%;
}
.carousel-inner > .next.left,
.carousel-inner > .prev.right {
  left: 0;
}
.carousel-inner > .active.left {
  left: -100%;
}
.carousel-inner > .active.right {
  left: 100%;
}
.carousel-control {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  /*width: 5%;*/
  opacity: 0.5;
  filter: alpha(opacity=50);
  font-size: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
  background-color: rgba(0, 0, 0, 0);
}
.carousel-control.left {
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#80000000, endColorstr=#00000000, GradientType=1);
}
.carousel-control.right {
  left: auto;
  right: 0;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000, endColorstr=#80000000, GradientType=1);
}
.carousel-control:hover,
.carousel-control:focus {
  outline: 0;
  color: #fff;
  text-decoration: none;
  opacity: 0.9;
  filter: alpha(opacity=90);
}
.carousel-control .icon-prev,
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-left,
.carousel-control .glyphicon-chevron-right {
  position: absolute;
  top: 50%;
  margin-top: -10px;
  z-index: 5;
  display: inline-block;
}
/*
.carousel-control .icon-prev,
.carousel-control .glyphicon-chevron-left {
  left: 50%;
  margin-left: -10px;
}
*/

.carousel-control .icon-prev,
.carousel-control .glyphicon-chevron-left {
  background: url('/images/icon-slides.png');
  background-position-y: -20px;
  left: 9px;
}

/*
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-right {
  right: 50%;
  margin-right: -10px;
}
*/

.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-right {
  background: url('/images/icon-slides.png');
  background-position-x: -50px;
  background-position-y: -20px;
  right: 0px;
}

.carousel-control .icon-prev,
.carousel-control .icon-next {
  width: 20px;
  height: 20px;
  line-height: 1;
  font-family: serif;
}

.carousel-control .icon-prev:before {
  content: 2039;
}
.carousel-control .icon-next:before {
  content: 203a;
}

.carousel-indicators {
  position: absolute;
  bottom: 2px;
  left: 50%;
  z-index: 15;
  width: 60%;
  margin-left: -30%;
  padding-left: 0;
  list-style: none;
  text-align: center;
}
.carousel-indicators li {
  display: inline-block;
  width: 30px;
  height: 3px;
  margin: 5px;
  text-indent: -999px;
  border: 1px solid #bbb;
  border-radius: 10px;
  cursor: pointer;
  background-color: rgba(0, 0, 0, .24);
}
.carousel-indicators .active {
  width: 30px;
  height: 3px;
  background-color: #fff;
}
.carousel-caption {
  position: absolute;
  left: 15%;
  right: 15%;
  bottom: 20px;
  z-index: 10;
  padding-top: 20px;
  padding-bottom: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
}
.carousel-caption .btn {
  text-shadow: none;
}
@media screen and (min-width: 768px) {
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-prev,
  .carousel-control .icon-next {
    width: 30px;
    height: 30px;
    margin-top: -10px;
    font-size: 30px;
  }
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .icon-prev {
    margin-left: -10px;
  }
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-next {
   /* margin-right: -10px; */
  }
  .carousel-caption {
    left: 20%;
    right: 20%;
    padding-bottom: 30px;
  }
  .carousel-indicators {
    bottom: -10px;
  }
}
</style>

<div width="100%" height="320px" style="border: 0px; overflow: hidden; border-radius: 10px; margin-bottom: 25px;" scrolling="no">

    <div id="myCarousel" class="carousel slide" data-ride="carousel" data-interval="3500" style="float:left">

      <!-- 轮播（Carousel）指标 -->
      <ol class="carousel-indicators">
      
      
        <li data-target="#myCarousel" data-slide-to="0"></li>
        
      
        <li data-target="#myCarousel" data-slide-to="1"></li>
        
      
        <li data-target="#myCarousel" data-slide-to="2"></li>
        
      
        <li data-target="#myCarousel" data-slide-to="3"></li>
        
      
        <li data-target="#myCarousel" data-slide-to="4"></li>
        
      
        <li data-target="#myCarousel" data-slide-to="5"></li>
        
      
      </ol>

      <!-- 轮播（Carousel）项目 -->
      <div class="carousel-inner" style="height: 280px; border-radius: 10px; width: 100%;">
       
       
          
          <a class="item active" href="/messageboard/" target="_blank" style="height: 100%;">
            
            <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%">
          </a>
          
          
      
          
            <a class="item" href="https://github.com/996icu/996.ICU" target="_blank" style="height: 100%;">
              <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%;">
            </a>
        
      
          
            <a class="item" href="/tags/JVM/" target="_blank" style="height: 100%;">
              <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%;">
            </a>
        
      
          
            <a class="item" href="/posts/258aee07.html" target="_blank" style="height: 100%;">
              <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%;">
            </a>
        
      
          
            <a class="item" href="/tags/博客/" target="_blank" style="height: 100%;">
              <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%;">
            </a>
        
      
          
            <a class="item" href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" style="height: 100%;">
              <img src="/images/blog-polish.png" class="nofancybox" style="width: 100%; height: 100%;">
            </a>
        
      
      </div>

      <!-- 轮播（Carousel）导航 -->
      <a class="left carousel-control" data-target="#myCarousel" href="javascript:void(0);" role="button" data-slide="prev">
          <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
      </a>
      <a class="right carousel-control" data-target="#myCarousel" href="javascript:void(0);" role="button" data-slide="next">
          <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
      </a>

	</div>

	<div class="rights" style="width: 30%; height: 280px; margin-right: 0px;margin-left: 20px;float: left;">
       <!-- 天气插件 -->
       <iframe scrolling="no" height="50px" frameborder="0" allowtransparency="true" src="//i.tianqi.com/index.php?c=code&id=12&color=%23&bdc=%23&icon=1&py=wuhan&num=5&site=12"></iframe>
    
       <!-- 关于博主 -->
       <div class="my-carousel">
         <a href="/about/" target="_blank">
            <img class="right-siders nofancybox" src="/images/about.png" width="100%">
         </a>
       </div>
    
       <!-- 推荐阅读 -->
       <div class="my-carousel">
         <a href="/books/" target="_blank">
           <img class="right-siders nofancybox" src="/images/read.png">
         </a>
       </div>

      <!-- 光影留念 -->
      <div class="my-carousel">
        <a href="/photos/" target="_blank">
          <img class="right-siders nofancybox" src="/images/photo.png">
        </a>
      </div>

      <!-- 留下脚印 -->
      <div class="my-carousel">
        <a href="/guestbook/" target="_blank">
          <img class="right-siders nofancybox" src="/images/foot.png">
        </a>
      </div>

   </div>

</div>



  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/20/架构与优化之JVM优化第03篇Tomcat8的优化 看懂Java底层字节码 编码的优化建议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/20/架构与优化之JVM优化第03篇Tomcat8的优化 看懂Java底层字节码 编码的优化建议/" itemprop="url">
                  架构与优化之JVM优化第03课Tomcat8的优化 看懂Java底层字节码 编码的优化建议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-20 20:03:11 / 修改时间：11:51:16" itemprop="dateCreated datePublished" datetime="2019-12-20T20:03:11+08:00">2019-12-20</time>
            

            
              

              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/20/架构与优化之JVM优化第03篇Tomcat8的优化 看懂Java底层字节码 编码的优化建议/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/20/架构与优化之JVM优化第03篇Tomcat8的优化 看懂Java底层字节码 编码的优化建议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>Tomcat8的优化</li>
<li>看懂Java底层字节码</li>
<li>编码的优化建议</li>
</ul>
<h1 id="1、Tomcat8优化"><a href="#1、Tomcat8优化" class="headerlink" title="1、Tomcat8优化"></a>1、Tomcat8优化</h1><p>tomcat服务器在JavaEE项目中使用率非常高，所以在生产环境对tomcat的优化也变得非 常重要了。<br>对于tomcat的优化，主要是从2个方面入手，一是，tomcat自身的配置，另一个是<br>tomcat所运行的jvm虚拟机的调优。<br>下面我们将从这2个方面进行讲解。</p>
<h2 id="1-1、Tomcat配置优化1-1-1、部署安装tomcat8-下载并安装："><a href="#1-1、Tomcat配置优化1-1-1、部署安装tomcat8-下载并安装：" class="headerlink" title="1.1、Tomcat配置优化1.1.1、部署安装tomcat8 下载并安装："></a>1.1、Tomcat配置优化1.1.1、部署安装tomcat8 下载并安装：</h2><p><a href="https://tomcat.apache.org/download-80.cgicd" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgicd</a> /tmp<br>wget <a href="http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat‐" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat‐</a> 8/v8.5.34/bin/apache‐tomcat‐8.5.34.tar.gz</p>
<p>tar ‐xvf apache‐tomcat‐8.5.34.tar.gz cd apache‐tomcat‐8.5.34/conf</p>
<h1 id="修改配置文件，配置tomcat的管理用户"><a href="#修改配置文件，配置tomcat的管理用户" class="headerlink" title="修改配置文件，配置tomcat的管理用户"></a>修改配置文件，配置tomcat的管理用户</h1><p>vim tomcat‐users.xml #写入如下内容：</p>
<h1 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h1><h1 id="如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403"><a href="#如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403" class="headerlink" title="如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403"></a>如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403</h1><p>vim webapps/manager/META‐INF/context.xml</p>
<h1 id="将-lt-Valve的内容注释掉"><a href="#将-lt-Valve的内容注释掉" class="headerlink" title="将&lt;Valve的内容注释掉"></a>将&lt;Valve的内容注释掉</h1><p>&lt;!‐‐ ‐‐&gt;</p>
<h1 id="保存退出即可"><a href="#保存退出即可" class="headerlink" title="保存退出即可"></a>保存退出即可</h1><h1 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h1><p>cd /tmp/apache‐tomcat‐8.5.34/bin/<br>./startup.sh &amp;&amp; tail ‐f …/logs/catalina.out</p>
<h1 id="打开浏览器进行测试访问http-192-168-40-133-8080"><a href="#打开浏览器进行测试访问http-192-168-40-133-8080" class="headerlink" title="打开浏览器进行测试访问http://192.168.40.133:8080/"></a>打开浏览器进行测试访问<a href="http://192.168.40.133:8080/" target="_blank" rel="noopener">http://192.168.40.133:8080/</a></h1><p>点击“Server Status”，输入用户名、密码进行登录，tomcat/tomcat进入之后即可看到服务的信息。</p>
<p>1.1.2、禁用AJP连接<br>在服务状态页面中可以看到，默认状态下会启用AJP服务，并且占用8009端口。<br>什么是AJP呢？<br>AJP（Apache JServer Protocol）<br>AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用。修改conf下的server.xml文件，将AJP服务禁用掉即可。</p>
<p><connector port="8009" protocol="AJP/1.3" redirectport="8443"><br>1</connector></p>
<p>重启tomcat，查看效果。可以看到AJP服务以及不存在了。<br>1.1.3、执行器（线程池）<br>在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。<br>修改server.xml文件：</p>
<p>&lt;!‐‐将注释打开‐‐&gt;</p>
<p><executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="500" minsparethreads="50" prestartminsparethreads="true" maxqueuesize="100"><br>&lt;!‐‐<br>参数说明：<br>maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000，根据硬件设施和业务来判断<br>minSpareThreads：Tomcat 初 始 化 时 创 建 的 线 程 数 ， 默 认 设 置 25 prestartminSpareThreads： 在 Tomcat 初始化的时候就初始化 minSpareThreads 的参数值，如果不等于 true，minSpareThreads 的值就没啥效果了<br>maxQueueSize，最大的等待队列数，超过则拒绝请求<br>‐‐&gt;</executor></p>
<p>&lt;!‐‐在Connector中设置executor属性指向上面的执行器‐‐&gt;</p>
<connector executor="tomcatThreadPool" port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>保存退出，重启tomcat，查看效果。<br>在页面中显示最大线程数为-1，这个是正常的，仅仅是显示的问题，实际使用的指定的值。</p>
<p>也有人遇到这样的问<br>题：<a href="https://blog.csdn.net/weixin_38278878/article/details/80144397" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38278878/article/details/80144397</a><br>1.1.4、3种运行模式<br>tomcat的运行模式有3种：<br>1.bio<br>默认的模式,性能非常低下,没有经过任何优化处理和支持.<br>2.nio<br>nio(new I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio 也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。<br>3.apr<br>安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能.<br>推荐使用nio，不过，在tomcat8中有最新的nio2，速度更快，建议使用nio2. 设置nio2：</p>
<p><connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol" connectiontimeout="20000" redirectport="8443"><br>1<br>2</connector></p>
<p>可以看到已经设置为nio2了。</p>
<p>1.2、部署测试用的java web项目<br>为了方便测试性能，我们将部署一个java web项目，这个项目本身和本套课程没有什么关系，仅仅用于测试。<br>注意：这里在测试时，我们使用一个新的tomcat，进行测试，后面再对其进行优化 调整，再测试。<br>1.2.1、创建dashboard数据库<br>在资料中找到sql脚本文件dashboard.sql，在linux服务器上执行。</p>
<p>cat dashboard.sql | mysql ‐uroot ‐proot<br>1<br>创建完成后，可以看到有3张表。<br>1.2.2、部署web应用<br>在资料中找到itcat-dashboard-web.war，上传到linux服务器，进行部署安装。</p>
<p>cd /tmp/apache‐tomcat‐8.5.34/webapps<br>rm ‐rf *<br>mkdir ROOT<br> cd ROOT/<br>rz上传war包<br>jar ‐xvf itcat‐dashboard‐web.war rm ‐rf itcat‐dashboard‐web.war</p>
<h1 id="修改数据库配置文件"><a href="#修改数据库配置文件" class="headerlink" title="修改数据库配置文件"></a>修改数据库配置文件</h1><p>cd /tmp/apache‐tomcat‐8.5.34/webapps/ROOT/WEB‐INF/classes vim jdbc.properties</p>
<h1 id="这里根据自己的实际情况进行配置"><a href="#这里根据自己的实际情况进行配置" class="headerlink" title="这里根据自己的实际情况进行配置"></a>这里根据自己的实际情况进行配置</h1><p>jdbc.driverClassName=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://node01:3306/dashboard? useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueri es=true<br>jdbc.username=root</p>
<p>jdbc.password=root<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>重新启动tomcat。<br>访问首页，查看是否已经启动成功：<a href="http://192.168.40.133:8080/index" target="_blank" rel="noopener">http://192.168.40.133:8080/index</a></p>
<p>1.3、使用Apache JMeter进行测试<br>Apache Jmeter是开源的压力测试工具，我们借助于此工具进行测试，将测试出tomcat<br>的吞吐量等信息。</p>
<p>1.3.1、下载安装<br>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi安装：直接将下载好的zip压缩包进行解压即可。进入bin目录，找到jmeter.bat文件，双机打开即可启动。1.3.2、修改主题和语言" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi安装：直接将下载好的zip压缩包进行解压即可。进入bin目录，找到jmeter.bat文件，双机打开即可启动。1.3.2、修改主题和语言</a><br>默认的主题是黑色风格的主题并且语言是英语，这样不太方便使用，所以需要修改下主题和中文语言。主题修改完成。</p>
<p>接下来设置语言为简体中文。1.3.3、创建首页的测试用例<br>第一步：保存测试用例<br>第二步：添加线程组，使用线程模拟用户的并发<br>1000个线程，每个线程循环10次，也就是tomcat会接收到10000个请求。<br>第三步：添加http请求第四步：添加请求监控1.3.4、启动、进行测试1.3.5、聚合报告<br>在聚合报告中，重点看吞吐量。</p>
<p>1.4、调整tomcat参数进行优化<br>通过上面测试可以看出，tomcat在不做任何调整时，吞吐量为73次/秒。<br>1.4.1、禁用AJP服务<br>可以看到，禁用AJP服务后，吞吐量会有所提升。<br>当然了，测试不一定准确，需要多测试几次才能看出是否有提升。</p>
<p>1.4.2、设置线程池<br>通过设置线程池，调整线程池相关的参数进行测试tomcat的性能。<br>1.4.2.1、最大线程数为500，初始为50</p>
<p><executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="500" minsparethreads="50" prestartminsparethreads="true"><br>1<br>2<br>测试结果：</executor></p>
<p>吞吐量为128次/秒，性能有所提升。<br>1.4.2.2、最大线程数为1000，初始为200</p>
<p><executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="1000" minsparethreads="200" prestartminsparethreads="true"><br>1<br>2</executor></p>
<p>吞吐量为151，性能有所提升。<br>1.4.2.3、最大线程数为5000，初始为1000<br>是否是线程数最多，速度越快呢？ 我们来测试下。</p>
<p><executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="5000" minsparethreads="1000" prestartminsparethreads="true"><br>1<br>2</executor></p>
<p>可以看到，虽然最大线程已经设置到5000，但是实际测试效果并不理想，并且平均的响 应时间也边长了，所以单纯靠提升线程数量是不能一直得到性能提升的。</p>
<p>1.4.2.4、设置最大等待队列数<br>默认情况下，请求发送到tomcat，如果tomcat正忙，那么该请求会一直等待。这样虽然 可以保证每个请求都能请求到，但是请求时间就会边长。</p>
<p>有些时候，我们也不一定要求请求一定等待，可以设置最大等待队列大小，如果超过就不等待了。这样虽然有些请求是失败的，但是请求时间会虽短。典型的应用：12306。</p>
<p>&lt;!‐‐最大等待数为100‐‐&gt;</p>
<p><executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="500" minsparethreads="100" prestartminsparethreads="true" maxqueuesize="100"><br>1<br>2<br>3<br>4<br>5<br>6<br>7</executor></p>
<p>测试结果：</p>
<p>平均响应时间：3.1秒响应时间明显缩短<br>错误率：49.88%<br>错误率提升到一半，也可以理解，最大线程为500，测试的并发为1000 吞吐量：238次/秒<br>吞吐量明显提升<br>结论：响应时间、吞吐量这2个指标需要找到平衡才能达到更好的性能。<br>1.4.3、设置nio2的运行模式<br>将最大线程设置为500进行测试：</p>
<executor name="tomcatThreadPool" nameprefix="catalina‐exec‐" maxthreads="500" minsparethreads="50" prestartminsparethreads="true">

<p>&lt;!‐‐ 设置nio2 ‐‐&gt;</p>
<connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol" connectiontimeout="20000" redirectport="8443">

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>可以看到，平均响应时间有缩短，吞吐量有提升，可以得出结论：nio2的性能要高于<br>nio。</p>
<p>1.5、调整JVM参数进行优化<br>接下来，测试通过jvm参数进行优化，为了测试一致性，依然将最大线程数设置为500， 启用nio2运行模式。<br>1.5.1、设置并行垃圾回收器</p>
<h1 id="年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512M-JAVA-OPTS-”‐XX-UseParallelGC-‐XX-UseParallelOldGC-‐Xms64m-‐Xmx512m-‐-XX-PrintGCDetails-‐XX-PrintGCTimeStamps-‐XX-PrintGCDateStamps-‐-XX-PrintHeapAtGC-‐Xloggc-logs-gc-log”"><a href="#年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512M-JAVA-OPTS-”‐XX-UseParallelGC-‐XX-UseParallelOldGC-‐Xms64m-‐Xmx512m-‐-XX-PrintGCDetails-‐XX-PrintGCTimeStamps-‐XX-PrintGCDateStamps-‐-XX-PrintHeapAtGC-‐Xloggc-logs-gc-log”" class="headerlink" title="年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512M JAVA_OPTS=”‐XX:+UseParallelGC ‐XX:+UseParallelOldGC ‐Xms64m ‐Xmx512m ‐ XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐ XX:+PrintHeapAtGC ‐Xloggc:../logs/gc.log”"></a>年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512M JAVA_OPTS=”‐XX:+UseParallelGC ‐XX:+UseParallelOldGC ‐Xms64m ‐Xmx512m ‐ XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐ XX:+PrintHeapAtGC ‐Xloggc:../logs/gc.log”</h1><p>1</p>
<p>测试结果与默认的JVM参数结果接近。（执行了2次测试，结果是第二次测试的结果）<br>1.5.2、查看gc日志文件<br>将gc.log文件上传到gceasy.io查看gc中是否存在问题。在报告中显示，在5次GC时，系统所消耗的时间大于用户时间，这反应出的服务器的性能存在瓶颈，调度CPU等资源所消耗的时间要长一些。<br>问题二：<br>可以关键指标中可以看出，吞吐量表现不错，但是gc时，线程的暂停时间稍有点长。<br>问题三：通过GC的统计可以看出：<br>年轻代的gc有74次，次数稍有多，说明年轻代设置的大小不合适需要调整<br>FullGC有8次，说明堆内存的大小不合适，需要调整<br>问题四：<br>从GC原因的可以看出，年轻代大小设置不合理，导致了多次GC。<br>1.5.3、调整年轻代大小</p>
<p>JAVA_OPTS=”‐XX:+UseParallelGC ‐XX:+UseParallelOldGC ‐Xms128m ‐Xmx1024m ‐ XX:NewSize=64m ‐XX:MaxNewSize=256m ‐XX:+PrintGCDetails ‐ XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐XX:+PrintHeapAtGC ‐ Xloggc:../logs/gc.log”<br>1<br>将初始堆大小设置为128m，最大为1024m<br>初始年轻代大小64m，年轻代最大256m<br>从测试结果来看，吞吐量以及响应时间均有提升。<br>查看gc日志：</p>
<p>可以看到GC次数要明显减少，说明调整是有效的。<br>1.5.4、设置G1垃圾回收器</p>
<h1 id="设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024m-JAVA-OPTS-”‐XX-UseG1GC-‐XX-MaxGCPauseMillis-100-‐Xms128m-‐Xmx1024m-‐-XX-PrintGCDetails-‐XX-PrintGCTimeStamps-‐XX-PrintGCDateStamps-‐-XX-PrintHeapAtGC-‐Xloggc-logs-gc-log”"><a href="#设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024m-JAVA-OPTS-”‐XX-UseG1GC-‐XX-MaxGCPauseMillis-100-‐Xms128m-‐Xmx1024m-‐-XX-PrintGCDetails-‐XX-PrintGCTimeStamps-‐XX-PrintGCDateStamps-‐-XX-PrintHeapAtGC-‐Xloggc-logs-gc-log”" class="headerlink" title="设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024m JAVA_OPTS=”‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=100 ‐Xms128m ‐Xmx1024m ‐ XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐ XX:+PrintHeapAtGC ‐Xloggc:../logs/gc.log”"></a>设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024m JAVA_OPTS=”‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=100 ‐Xms128m ‐Xmx1024m ‐ XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐ XX:+PrintHeapAtGC ‐Xloggc:../logs/gc.log”</h1><p>1<br>测试结果：</p>
<p>可以看到，吞吐量有所提升，评价响应时间也有所缩短。</p>
<p>1.5.5、小结<br>通过上述的测试，可以总结出，对tomcat性能优化就是需要不断的进行调整参数，然后 测试结果，可能会调优也可能会调差，这时就需要借助于gc的可视化工具来看gc的情 况。再帮我我们做出决策应该调整哪些参数。</p>
<p>2、JVM字节码<br>前面我们通过tomcat本身的参数以及jvm的参数对tomcat做了优化，其实要想将应用程 序跑的更快、效率更高，除了对tomcat容器以及jvm优化外，应用程序代码本身如果写 的效率不高的，那么也是不行的，所以，对于程序本身的优化也就很重要了。</p>
<p>对于程序本身的优化，可以借鉴很多前辈们的经验，但是有些时候，在从源码角度方面 分析的话，不好鉴别出哪个效率高，如对字符串拼接的操作，是直接“+”号拼接效率高还 是使用StringBuilder效率高？<br>这个时候，就需要通过查看编译好的class文件中字节码，就可以找到答案。<br>我们都知道，java编写应用，需要先通过javac命令编译成class文件，再通过jvm执行，<br>jvm执行时是需要将class文件中的字节码载入到jvm进行运行的。</p>
<p>2.1、通过javap命令查看class文件的字节码内容<br>首先，看一个简单的Test1类的代码：</p>
<p>package cn.itcast.jvm;<br>public class Test1 {<br>public static void main(String[] args) {<br>int a =  2; int b =  5; int c = b ‐ a;<br>System.out.println(c);<br>}<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>通过javap命令查看class文件中的字节码内容：</p>
<p>javap ‐v Test1.class &gt; Test1.txt<br>javap用法: javap <options> <classes><br>其中, 可能的选项包括:<br>‐help    ‐‐help    ‐?<br>‐version<br>‐v    ‐verbose<br>‐l<br>‐public<br>‐protected<br>‐package<br>‐p    ‐private<br>‐c<br>‐s<br>‐sysinfo</classes></options></p>
<p>‐constants<br>‐classpath <path></path><br>‐cp <path></path><br>‐bootclasspath <path></path><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>查看Test1.txt文件，内容如下：</p>
<p>Classfile /F:/code/itcast‐jvm/itcast‐jvm‐ test/target/classes/cn/itcast/jvm/Test1.class<br>Last modified 2018‐9‐27; size 577 bytes<br>MD5 checksum 4214859db3543c0c783ec8a216a4795f Compiled from “Test1.java”<br>public class cn.itcast.jvm.Test1 minor version: 0<br>major version: 52<br>flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:</p>
<h1 id="1-Methodref-5-23-java-lang-Object-”“-V"><a href="#1-Methodref-5-23-java-lang-Object-”“-V" class="headerlink" title="1 = Methodref    #5.#23    // java/lang/Object.”“: ()V"></a>1 = Methodref    #5.#23    // java/lang/Object.”<init>“: ()V</init></h1><h1 id="2-Fieldref-24-25-java-lang-System-out-Ljava-io-PrintStream"><a href="#2-Fieldref-24-25-java-lang-System-out-Ljava-io-PrintStream" class="headerlink" title="2 = Fieldref    #24.#25    // java/lang/System.out:Ljava/io/PrintStream;"></a>2 = Fieldref    #24.#25    // java/lang/System.out:Ljava/io/PrintStream;</h1><h1 id="3-Methodref-26-27-java-io-PrintStream-println-I-V"><a href="#3-Methodref-26-27-java-io-PrintStream-println-I-V" class="headerlink" title="3 = Methodref    #26.#27    // java/io/PrintStream.println: (I)V"></a>3 = Methodref    #26.#27    // java/io/PrintStream.println: (I)V</h1><h1 id="28-Utf8-cn-itcast-jvm-Test1"><a href="#28-Utf8-cn-itcast-jvm-Test1" class="headerlink" title="28 = Utf8    cn/itcast/jvm/Test1"></a>28 = Utf8    cn/itcast/jvm/Test1</h1><h1 id="29-Utf8-java-lang-Object"><a href="#29-Utf8-java-lang-Object" class="headerlink" title="29 = Utf8    java/lang/Object"></a>29 = Utf8    java/lang/Object</h1><h1 id="30-Utf8-java-lang-System"><a href="#30-Utf8-java-lang-System" class="headerlink" title="30 = Utf8    java/lang/System"></a>30 = Utf8    java/lang/System</h1><h1 id="31-Utf8-out"><a href="#31-Utf8-out" class="headerlink" title="31 = Utf8    out"></a>31 = Utf8    out</h1><h1 id="32-Utf8-Ljava-io-PrintStream"><a href="#32-Utf8-Ljava-io-PrintStream" class="headerlink" title="32 = Utf8    Ljava/io/PrintStream;"></a>32 = Utf8    Ljava/io/PrintStream;</h1><h1 id="33-Utf8-java-io-PrintStream"><a href="#33-Utf8-java-io-PrintStream" class="headerlink" title="33 = Utf8    java/io/PrintStream"></a>33 = Utf8    java/io/PrintStream</h1><h1 id="34-Utf8-println"><a href="#34-Utf8-println" class="headerlink" title="34 = Utf8    println"></a>34 = Utf8    println</h1><h1 id="35-Utf8-I-V"><a href="#35-Utf8-I-V" class="headerlink" title="35 = Utf8    (I)V"></a>35 = Utf8    (I)V</h1><p>{<br>public cn.itcast.jvm.Test1(); descriptor: ()V<br>flags: ACC_PUBLIC Code:<br>stack=1, locals=1, args_size=1 0: aload_0<br>1: invokespecial #1    // Method<br>java/lang/Object.”<init>“:()V<br>4: return LineNumberTable:<br>line 3: 0 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    5    0    this    Lcn/itcast/jvm/Test1;</init></p>
<p>public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=2, locals=4, args_size=1 0: iconst_2<br>1: istore_1<br>2: iconst_5<br>3: istore_2<br>4: iload_2<br>5: iload_1<br>6: isub<br>7: istore_3<br>8: getstatic    #2    // Field java/lang/System.out:Ljava/io/PrintStream;<br>11: iload_3</p>
<p>12: invokevirtual #3    // Method<br>java/io/PrintStream.println:(I)V<br>15: return LineNumberTable:<br>line    6:    0<br>line    7:    2<br>line    8:    4<br>line    9:    8<br>line 10: 15<br>LocalVariableTable:<br>Start<br>0    Length<br>16    Slot<br>0    Name<br>args    Signature<br>[Ljava/lang/String;<br>2    14    1    a    I<br>4    12    2    b    I<br>8    8    3    c    I<br>}<br>SourceFile: “Test1.java”<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>内容大致分为4个部分：<br>第一部分：显示了生成这个class的java源文件、版本信息、生成时间等。第二部分：显示了该类中所涉及到常量池，共35个常量。<br>第三部分：显示该类的构造器，编译器自动插入的。</p>
<p>第四部分：显示了main方的信息。（这个是需要我们重点关注的）</p>
<p>2.2、常量池<br>官网文档：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4-140" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4-140</a></p>
<p>Constant Type    Value    说明<br>CONSTANT_Class    7    类或接口的符号引用<br>CONSTANT_Fieldref    9    字段的符号引用<br>CONSTANT_Methodref    10    类中方法的符号引用<br>CONSTANT_InterfaceMethodref    11    接口中方法的符号引用<br>CONSTANT_String    8    字符串类型常量<br>CONSTANT_Integer    3    整形常量<br>CONSTANT_Float    4    浮点型常量<br>CONSTANT_Long    5    长整型常量<br>CONSTANT_Double    6    双精度浮点型常量<br>CONSTANT_NameAndType    12    字段或方法的符号引用<br>CONSTANT_Utf8    1    UTF-8编码的字符串<br>CONSTANT_MethodHandle    15    表示方法句柄<br>CONSTANT_MethodType    16    标志方法类型<br>CONSTANT_InvokeDynamic    18    表示一个动态方法调用点<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>2.3、描述符<br>2.3.1、字段描述符<br>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2</a></p>
<p>FieldType term<br>Type<br>Interpretation<br>B    byte    signed byte</p>
<p>C<br>char    Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16<br>D    double    double-precision floating-point value<br>F    float    single-precision floating-point value<br>I    int    integer<br>J    long    long integer<br>LClassName;    reference    an instance of class ClassName<br>S    short    signed short<br>Z    boolean    true or false<br>[    reference    one array dimension<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>2.3.2、方法描述符<br>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3</a></p>
<p>示例：</p>
<p>The method descriptor for the method:</p>
<p>Object m(int i, double d, Thread t) {…}<br>1<br>is:</p>
<p>(IDLjava/lang/Thread;)Ljava/lang/Object;<br>1<br>2.4、解读方法字节码</p>
<p>public static void main(java.lang.String[]);<br>descriptor: ([Ljava/lang/String;)V    //方法描述，V表示该方法的放回值为void<br>flags: ACC_PUBLIC, ACC_STATIC    // 方法修饰符，public、static的<br>Code:<br>// stack=2,操作栈的大小为2、locals=4，本地变量表大小，args_size=1, 参数</p>
<p>的个数</p>
<p>stack=2, locals=4, args_size=1<br>0: iconst_2    //将数字2值压入操作栈，位于栈的最上面<br>1: istore_1    //从操作栈中弹出一个元素(数字2)，放入到本地变量表中，位</p>
<p>于下标为1的位置（下标为0的是this）<br>2: iconst_5    //将数字5值压入操作栈，位于栈的最上面<br>3: istore_2    //从操作栈中弹出一个元素(5)，放入到本地变量表中，位于第下标为2个位置<br>4: iload_2    //将本地变量表中下标为2的位置元素压入操作栈（5）<br>5: iload_1    //将本地变量表中下标为1的位置元素压入操作栈（2）<br>6: isub    //操作栈中的2个数字相减<br>7: istore_3 // 将相减的结果压入到本地本地变量表中，位于下标为3的位置<br>// 通过#2号找到对应的常量，即可找到对应的引用<br>8: getstatic    #2    // Field java/lang/System.out:Ljava/io/PrintStream;<br>11: iload_3 //将本地变量表中下标为3的位置元素压入操作栈（3）<br>// 通过#3号找到对应的常量，即可找到对应的引用，进行方法调用<br>12: invokevirtual #3    // Method java/io/PrintStream.println:(I)V<br>15: return //返回<br>LineNumberTable:    //行号的列表</p>
<p>line    6:    0<br>line    7:    2<br>line    8:    4<br>line    9:    8<br>line 10: 15 LocalVariableTable: // 本地变量表<br>Start<br>0    Length<br>16    Slot<br>0    Name<br>args    Signature<br>[Ljava/lang/String;<br>2    14    1    a    I<br>4    12    2    b    I<br>8    8    3    c    I<br>}</p>
<p>SourceFile: “Test1.java”</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>2.4.1、图解</p>
<p>2.5、研究 i++ 与 ++i 的不同<br>我们都知道，i++表示，先返回再+1，++i表示，先+1再返回。它的底层是怎么样的呢? 我们一起探究下。</p>
<p>编写测试代码：</p>
<p>public class Test2 {</p>
<p>public static void main(String[] args) {<br>new Test2().method1();<br> new Test2().method2();<br>}<br>public void method1(){<br>int i = 1; int a = i++;<br>System.out.println(a); //打印1<br>}<br>public void method2(){<br>int i = 1; int a = ++i;<br>System.out.println(a);//打印2<br>}<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>2.5.1、查看class字节码</p>
<p>Classfile /F:/code/itcast‐jvm/itcast‐jvm‐ test/target/classes/cn/itcast/jvm/Test2.class<br>MD5 checksum 901660fc11c43b6daadd0942150960ed Compiled from “Test2.java”<br>public class cn.itcast.jvm.Test2 minor version: 0<br>major version: 52<br>flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:</p>
<h1 id="1-Methodref-8-27-java-lang-Object-”“-V"><a href="#1-Methodref-8-27-java-lang-Object-”“-V" class="headerlink" title="1 = Methodref    #8.#27    // java/lang/Object.”“: ()V"></a>1 = Methodref    #8.#27    // java/lang/Object.”<init>“: ()V</init></h1><h1 id="2-Class-28-cn-itcast-jvm-Test2"><a href="#2-Class-28-cn-itcast-jvm-Test2" class="headerlink" title="2 = Class    #28    // cn/itcast/jvm/Test2"></a>2 = Class    #28    // cn/itcast/jvm/Test2</h1><h1 id="3-Methodref-2-27-cn-itcast-jvm-Test2-”"><a href="#3-Methodref-2-27-cn-itcast-jvm-Test2-”" class="headerlink" title="3 = Methodref    #2.#27    // cn/itcast/jvm/Test2.”"></a>3 = Methodref    #2.#27    // cn/itcast/jvm/Test2.”</h1><p><init>“:()V</init></p>
<h1 id="4-Methodref-2-29-cn-itcast-jvm-Test2-method1-V"><a href="#4-Methodref-2-29-cn-itcast-jvm-Test2-method1-V" class="headerlink" title="4 = Methodref    #2.#29    // cn/itcast/jvm/Test2.method1: ()V"></a>4 = Methodref    #2.#29    // cn/itcast/jvm/Test2.method1: ()V</h1><h1 id="5-Methodref-2-30-cn-itcast-jvm-Test2-method2-V"><a href="#5-Methodref-2-30-cn-itcast-jvm-Test2-method2-V" class="headerlink" title="5 = Methodref    #2.#30    // cn/itcast/jvm/Test2.method2: ()V"></a>5 = Methodref    #2.#30    // cn/itcast/jvm/Test2.method2: ()V</h1><h1 id="6-Fieldref-31-32-java-lang-System-out-Ljava-io-PrintStream"><a href="#6-Fieldref-31-32-java-lang-System-out-Ljava-io-PrintStream" class="headerlink" title="6 = Fieldref    #31.#32    // java/lang/System.out:Ljava/io/PrintStream;"></a>6 = Fieldref    #31.#32    // java/lang/System.out:Ljava/io/PrintStream;</h1><h1 id="7-Methodref-33-34-java-io-PrintStream-println-I-V"><a href="#7-Methodref-33-34-java-io-PrintStream-println-I-V" class="headerlink" title="7 = Methodref    #33.#34    // java/io/PrintStream.println: (I)V"></a>7 = Methodref    #33.#34    // java/io/PrintStream.println: (I)V</h1><h1 id="26-Utf8-Test2-java"><a href="#26-Utf8-Test2-java" class="headerlink" title="26    =    Utf8    Test2.java"></a>26    =    Utf8    Test2.java</h1><h1 id="27-NameAndType-9-10-““-V"><a href="#27-NameAndType-9-10-““-V" class="headerlink" title="27    =    NameAndType    #9:#10    // ““:()V"></a>27    =    NameAndType    #9:#10    // “<init>“:()V</init></h1><h1 id="28-Utf8-cn-itcast-jvm-Test2"><a href="#28-Utf8-cn-itcast-jvm-Test2" class="headerlink" title="28    =    Utf8    cn/itcast/jvm/Test2"></a>28    =    Utf8    cn/itcast/jvm/Test2</h1><h1 id="29-NameAndType-20-10-method1-V"><a href="#29-NameAndType-20-10-method1-V" class="headerlink" title="29    =    NameAndType    #20:#10    // method1:()V"></a>29    =    NameAndType    #20:#10    // method1:()V</h1><h1 id="30-NameAndType-24-10-method2-V"><a href="#30-NameAndType-24-10-method2-V" class="headerlink" title="30    =    NameAndType    #24:#10    // method2:()V"></a>30    =    NameAndType    #24:#10    // method2:()V</h1><h1 id="31-Class-36-java-lang-System"><a href="#31-Class-36-java-lang-System" class="headerlink" title="31    =    Class    #36    // java/lang/System"></a>31    =    Class    #36    // java/lang/System</h1><h1 id="32-NameAndType-37-38-out-Ljava-io-PrintStream"><a href="#32-NameAndType-37-38-out-Ljava-io-PrintStream" class="headerlink" title="32    =    NameAndType    #37:#38    // out:Ljava/io/PrintStream;"></a>32    =    NameAndType    #37:#38    // out:Ljava/io/PrintStream;</h1><h1 id="33-Class-39-java-io-PrintStream"><a href="#33-Class-39-java-io-PrintStream" class="headerlink" title="33    =    Class    #39    // java/io/PrintStream"></a>33    =    Class    #39    // java/io/PrintStream</h1><h1 id="34-NameAndType-40-41-println-I-V"><a href="#34-NameAndType-40-41-println-I-V" class="headerlink" title="34    =    NameAndType    #40:#41    // println:(I)V"></a>34    =    NameAndType    #40:#41    // println:(I)V</h1><h1 id="35-Utf8-java-lang-Object"><a href="#35-Utf8-java-lang-Object" class="headerlink" title="35    =    Utf8    java/lang/Object"></a>35    =    Utf8    java/lang/Object</h1><h1 id="36-Utf8-java-lang-System"><a href="#36-Utf8-java-lang-System" class="headerlink" title="36    =    Utf8    java/lang/System"></a>36    =    Utf8    java/lang/System</h1><h1 id="37-Utf8-out"><a href="#37-Utf8-out" class="headerlink" title="37    =    Utf8    out"></a>37    =    Utf8    out</h1><h1 id="38-Utf8-Ljava-io-PrintStream"><a href="#38-Utf8-Ljava-io-PrintStream" class="headerlink" title="38    =    Utf8    Ljava/io/PrintStream;"></a>38    =    Utf8    Ljava/io/PrintStream;</h1><h1 id="39-Utf8-java-io-PrintStream"><a href="#39-Utf8-java-io-PrintStream" class="headerlink" title="39    =    Utf8    java/io/PrintStream"></a>39    =    Utf8    java/io/PrintStream</h1><h1 id="40-Utf8-println"><a href="#40-Utf8-println" class="headerlink" title="40    =    Utf8    println"></a>40    =    Utf8    println</h1><h1 id="41-Utf8-I-V"><a href="#41-Utf8-I-V" class="headerlink" title="41    =    Utf8    (I)V"></a>41    =    Utf8    (I)V</h1><p>{<br>public cn.itcast.jvm.Test2(); descriptor: ()V<br>flags: ACC_PUBLIC Code:<br>stack=1, locals=1, args_size=1 0: aload_0<br>1: invokespecial #1    // Method java/lang/Object.”<init>“:()V<br>4: return LineNumberTable:<br>line 3: 0 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    5    0    this    Lcn/itcast/jvm/Test2;</init></p>
<p>public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: new    #2    // class cn/itcast/jvm/Test2<br>3: dup</p>
<p>4: invokespecial #3    // Method “<init>“:()V<br>7: invokevirtual #4    // Method method1:()V<br>10: new    #2    // class cn/itcast/jvm/Test2<br>13: dup<br>14: invokespecial #3    // Method “<init>“:()V<br>17: invokevirtual #5    // Method method2:()V<br>20: return LineNumberTable:<br>line 6: 0<br>line 7: 10<br>line 8: 20 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    21    0    args    [Ljava/lang/String;</init></init></p>
<p>public void method1(); descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=2, locals=3, args_size=1 0: iconst_1<br>1: istore_1<br>2: iload_1<br>3: iinc    1, 1<br>6: istore_2<br>7: getstatic    #6    // Field java/lang/System.out:Ljava/io/PrintStream;<br>10: iload_2<br>11: invokevirtual #7    // Method java/io/PrintStream.println:(I)V<br>14: return LineNumberTable:<br>line 11: 0<br>line 12: 2<br>line 13: 7<br>line 14: 14 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    15    0    this    Lcn/itcast/jvm/Test2; 2    13    1        i    I<br>7    8    2    a    I</p>
<p>public void method2(); descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=2, locals=3, args_size=1 0: iconst_1<br>1: istore_1<br>2: iinc    1, 1<br>5: iload_1<br>6: istore_2<br>7: getstatic    #6    // Field java/lang/System.out:Ljava/io/PrintStream;<br>10: iload_2<br>11: invokevirtual #7    // Method java/io/PrintStream.println:(I)V<br>14: return LineNumberTable:<br>line 17: 0<br>line 18: 2<br>line 19: 7<br>line 20: 14 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    15    0    this    Lcn/itcast/jvm/Test2; 2    13    1        i    I<br>7    8    2    a    I<br>}<br>SourceFile: “Test2.java”</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>2.5.2、对比<br>i++：</p>
<p>0: iconst_1    //将数字1压入到操作栈<br>1: istore_1    //将数字1从操作栈弹出，压入到本地变量表中，下标为1<br>2: iload_1    //从本地变量表中获取下标为1的数据，压入到操作栈中<br>3: iinc    1, 1 // 将本地变量中的1，再+1<br>6: istore_2    // 将数字1从操作栈弹出，压入到本地变量表中，下标为2 7: getstatic        #6    // Field<br>java/lang/System.out:Ljava/io/PrintStream;<br>10: iload_2    //从本地变量表中获取下标为2的数据，压入到操作栈中<br>11: invokevirtual #7    // Method java/io/PrintStream.println:(I)V<br>14: return<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>++i：</p>
<p>0: iconst_1    //将数字1压入到操作栈<br>1: istore_1    //将数字1从操作栈弹出，压入到本地变量表中，下标为1<br>2: iinc    1, 1// 将本地变量中的1，再+1<br>5: iload_1    //从本地变量表中获取下标为1的数据（2），压入到操作栈中<br>6: istore_2 //将数字2从操作栈弹出，压入到本地变量表中，下标为2<br>7: getstatic    #6    // Field java/lang/System.out:Ljava/io/PrintStream;<br>10: iload_2 //从本地变量表中获取下标为2的数据（2），压入到操作栈中<br>11: invokevirtual #7    // Method java/io/PrintStream.println:(I)V<br>14: return<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>区别：</p>
<p>i++<br>只是在本地变量中对数字做了相加，并没有将数据压入到操作栈<br>将前面拿到的数字1，再次从操作栈中拿到，压入到本地变量中<br>++i<br>将本地变量中的数字做了相加，并且将数据压入到操作栈将操作栈中的数据，再次压入到本地变量中<br>小结：可以通过查看字节码的方式对代码的底层做研究，探究其原理。</p>
<p>2.6、字符串拼接<br>字符串的拼接在开发过程中使用是非常频繁的，常用的方式有三种：</p>
<p>+号拼接： str+“456”<br>StringBuilder拼接<br>StringBuffer拼接</p>
<p>StringBuffer是保证线程安全的，效率是比较低的，我们更多的是使用场景是不会涉及到 线程安全的问题的，所以更多的时候会选择StringBuilder，效率会高一些。<br>那么，问题来了，StringBuilder和“+”号拼接，哪个效率高呢？接下来我们通过字节码的 方式进行探究。</p>
<p>首先，编写个示例：</p>
<p>package cn.itcast.jvm;<br>public class Test3 {<br>public static void main(String[] args) {<br>new Test3().m1();<br>new Test3().m2();<br>public void m1(){<br>String s1 = “123”; String s2 = “456”; String s3 = s1 + s2; System.out.println(s3);<br>}</p>
<p>public void m2(){<br>String s1 = “123”; String s2 = “456”;<br>StringBuilder sb = new StringBuilder(); sb.append(s1);<br>sb.append(s2);<br>String s3 = sb.toString(); System.out.println(s3);<br>}<br>}<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>查看Test3.class的字节码</p>
<p>Classfile /F:/code/itcast‐jvm/itcast‐jvm‐ test/target/classes/cn/itcast/jvm/Test3.class<br>MD5 checksum b3f7629e7e37768b9b5581be01df40d6 Compiled from “Test3.java”<br>public class cn.itcast.jvm.Test3 minor version: 0<br>major version: 52<br>flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:</p>
<h1 id="1-Methodref-14-36-java-lang-Object-”“-V"><a href="#1-Methodref-14-36-java-lang-Object-”“-V" class="headerlink" title="1 = Methodref    #14.#36    // java/lang/Object.”“: ()V"></a>1 = Methodref    #14.#36    // java/lang/Object.”<init>“: ()V</init></h1><h1 id="2-Class-37-cn-itcast-jvm-Test3"><a href="#2-Class-37-cn-itcast-jvm-Test3" class="headerlink" title="2 = Class    #37    // cn/itcast/jvm/Test3"></a>2 = Class    #37    // cn/itcast/jvm/Test3</h1><h1 id="3-Methodref-2-36-cn-itcast-jvm-Test3-”"><a href="#3-Methodref-2-36-cn-itcast-jvm-Test3-”" class="headerlink" title="3 = Methodref    #2.#36    // cn/itcast/jvm/Test3.”"></a>3 = Methodref    #2.#36    // cn/itcast/jvm/Test3.”</h1><p><init>“:()V</init></p>
<h1 id="4-Methodref-2-38-cn-itcast-jvm-Test3-m1-V"><a href="#4-Methodref-2-38-cn-itcast-jvm-Test3-m1-V" class="headerlink" title="4 = Methodref    #2.#38    // cn/itcast/jvm/Test3.m1:()V"></a>4 = Methodref    #2.#38    // cn/itcast/jvm/Test3.m1:()V</h1><h1 id="5-Methodref-2-39-cn-itcast-jvm-Test3-m2-V"><a href="#5-Methodref-2-39-cn-itcast-jvm-Test3-m2-V" class="headerlink" title="5 = Methodref    #2.#39    // cn/itcast/jvm/Test3.m2:()V"></a>5 = Methodref    #2.#39    // cn/itcast/jvm/Test3.m2:()V</h1><h1 id="6-String-40-123"><a href="#6-String-40-123" class="headerlink" title="6 = String    #40    // 123"></a>6 = String    #40    // 123</h1><h1 id="7-String-41-456"><a href="#7-String-41-456" class="headerlink" title="7 = String    #41    // 456"></a>7 = String    #41    // 456</h1><h1 id="8-Class-42-java-lang-StringBuilder"><a href="#8-Class-42-java-lang-StringBuilder" class="headerlink" title="8 = Class    #42    // java/lang/StringBuilder"></a>8 = Class    #42    // java/lang/StringBuilder</h1><h1 id="9-Methodref-8-36-java-lang-StringBuilder-”"><a href="#9-Methodref-8-36-java-lang-StringBuilder-”" class="headerlink" title="9 = Methodref    #8.#36    // java/lang/StringBuilder.”"></a>9 = Methodref    #8.#36    // java/lang/StringBuilder.”</h1><p><init>“:()V</init></p>
<h1 id="10-Methodref-8-43-java-lang-StringBuilder-append-Ljava-lang-String-Ljava-lang-StringBuilder"><a href="#10-Methodref-8-43-java-lang-StringBuilder-append-Ljava-lang-String-Ljava-lang-StringBuilder" class="headerlink" title="10 = Methodref    #8.#43    // java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;"></a>10 = Methodref    #8.#43    // java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;</h1><h1 id="11-Methodref-8-44-java-lang-StringBuilder-toString-Ljava-lang-String"><a href="#11-Methodref-8-44-java-lang-StringBuilder-toString-Ljava-lang-String" class="headerlink" title="11 = Methodref    #8.#44    // java/lang/StringBuilder.toString:()Ljava/lang/String;"></a>11 = Methodref    #8.#44    // java/lang/StringBuilder.toString:()Ljava/lang/String;</h1><h1 id="12-Fieldref-45-46-java-lang-System-out-Ljava-io-PrintStream"><a href="#12-Fieldref-45-46-java-lang-System-out-Ljava-io-PrintStream" class="headerlink" title="12 = Fieldref    #45.#46    // java/lang/System.out:Ljava/io/PrintStream;"></a>12 = Fieldref    #45.#46    // java/lang/System.out:Ljava/io/PrintStream;</h1><h1 id="13-Methodref-47-48-java-io-PrintStream-println-Ljava-lang-String-V"><a href="#13-Methodref-47-48-java-io-PrintStream-println-Ljava-lang-String-V" class="headerlink" title="13 = Methodref    #47.#48    // java/io/PrintStream.println: (Ljava/lang/String;)V"></a>13 = Methodref    #47.#48    // java/io/PrintStream.println: (Ljava/lang/String;)V</h1><h1 id="14-Class-49-java-lang-Object"><a href="#14-Class-49-java-lang-Object" class="headerlink" title="14 = Class    #49    // java/lang/Object"></a>14 = Class    #49    // java/lang/Object</h1><h1 id="15-Utf8"><a href="#15-Utf8" class="headerlink" title="15 = Utf8    "></a>15 = Utf8    <init></init></h1><h1 id="16-Utf8-V"><a href="#16-Utf8-V" class="headerlink" title="16 = Utf8    ()V"></a>16 = Utf8    ()V</h1><h1 id="17-Utf8-Code"><a href="#17-Utf8-Code" class="headerlink" title="17 = Utf8    Code"></a>17 = Utf8    Code</h1><h1 id="18-Utf8-LineNumberTable"><a href="#18-Utf8-LineNumberTable" class="headerlink" title="18 = Utf8    LineNumberTable"></a>18 = Utf8    LineNumberTable</h1><h1 id="19-Utf8-LocalVariableTable"><a href="#19-Utf8-LocalVariableTable" class="headerlink" title="19 = Utf8    LocalVariableTable"></a>19 = Utf8    LocalVariableTable</h1><h1 id="20-Utf8-this"><a href="#20-Utf8-this" class="headerlink" title="20 = Utf8    this"></a>20 = Utf8    this</h1><h1 id="21-Utf8-Lcn-itcast-jvm-Test3"><a href="#21-Utf8-Lcn-itcast-jvm-Test3" class="headerlink" title="21 = Utf8    Lcn/itcast/jvm/Test3;"></a>21 = Utf8    Lcn/itcast/jvm/Test3;</h1><h1 id="22-Utf8-main"><a href="#22-Utf8-main" class="headerlink" title="22 = Utf8    main"></a>22 = Utf8    main</h1><h1 id="23-Utf8-Ljava-lang-String-V"><a href="#23-Utf8-Ljava-lang-String-V" class="headerlink" title="23 = Utf8    ([Ljava/lang/String;)V"></a>23 = Utf8    ([Ljava/lang/String;)V</h1><h1 id="24-Utf8-args"><a href="#24-Utf8-args" class="headerlink" title="24    =    Utf8    args"></a>24    =    Utf8    args</h1><h1 id="25-Utf8-Ljava-lang-String"><a href="#25-Utf8-Ljava-lang-String" class="headerlink" title="25    =    Utf8    [Ljava/lang/String;"></a>25    =    Utf8    [Ljava/lang/String;</h1><h1 id="26-Utf8-m1"><a href="#26-Utf8-m1" class="headerlink" title="26    =    Utf8    m1"></a>26    =    Utf8    m1</h1><h1 id="27-Utf8-s1"><a href="#27-Utf8-s1" class="headerlink" title="27    =    Utf8    s1"></a>27    =    Utf8    s1</h1><h1 id="28-Utf8-Ljava-lang-String"><a href="#28-Utf8-Ljava-lang-String" class="headerlink" title="28    =    Utf8    Ljava/lang/String;"></a>28    =    Utf8    Ljava/lang/String;</h1><h1 id="29-Utf8-s2"><a href="#29-Utf8-s2" class="headerlink" title="29    =    Utf8    s2"></a>29    =    Utf8    s2</h1><h1 id="30-Utf8-s3"><a href="#30-Utf8-s3" class="headerlink" title="30    =    Utf8    s3"></a>30    =    Utf8    s3</h1><h1 id="31-Utf8-m2"><a href="#31-Utf8-m2" class="headerlink" title="31    =    Utf8    m2"></a>31    =    Utf8    m2</h1><h1 id="32-Utf8-sb"><a href="#32-Utf8-sb" class="headerlink" title="32    =    Utf8    sb"></a>32    =    Utf8    sb</h1><h1 id="33-Utf8-Ljava-lang-StringBuilder"><a href="#33-Utf8-Ljava-lang-StringBuilder" class="headerlink" title="33    =    Utf8    Ljava/lang/StringBuilder;"></a>33    =    Utf8    Ljava/lang/StringBuilder;</h1><h1 id="34-Utf8-SourceFile"><a href="#34-Utf8-SourceFile" class="headerlink" title="34    =    Utf8    SourceFile"></a>34    =    Utf8    SourceFile</h1><h1 id="35-Utf8-Test3-java"><a href="#35-Utf8-Test3-java" class="headerlink" title="35    =    Utf8    Test3.java"></a>35    =    Utf8    Test3.java</h1><h1 id="36-NameAndType-15-16-““-V"><a href="#36-NameAndType-15-16-““-V" class="headerlink" title="36    =    NameAndType    #15:#16    // ““:()V"></a>36    =    NameAndType    #15:#16    // “<init>“:()V</init></h1><h1 id="37-Utf8-cn-itcast-jvm-Test3"><a href="#37-Utf8-cn-itcast-jvm-Test3" class="headerlink" title="37    =    Utf8    cn/itcast/jvm/Test3"></a>37    =    Utf8    cn/itcast/jvm/Test3</h1><h1 id="38-NameAndType-26-16-m1-V"><a href="#38-NameAndType-26-16-m1-V" class="headerlink" title="38    =    NameAndType    #26:#16    // m1:()V"></a>38    =    NameAndType    #26:#16    // m1:()V</h1><h1 id="39-NameAndType-31-16-m2-V"><a href="#39-NameAndType-31-16-m2-V" class="headerlink" title="39    =    NameAndType    #31:#16    // m2:()V"></a>39    =    NameAndType    #31:#16    // m2:()V</h1><h1 id="40-Utf8-123"><a href="#40-Utf8-123" class="headerlink" title="40    =    Utf8    123"></a>40    =    Utf8    123</h1><h1 id="41-Utf8-456"><a href="#41-Utf8-456" class="headerlink" title="41    =    Utf8    456"></a>41    =    Utf8    456</h1><h1 id="42-Utf8-java-lang-StringBuilder"><a href="#42-Utf8-java-lang-StringBuilder" class="headerlink" title="42    =    Utf8    java/lang/StringBuilder"></a>42    =    Utf8    java/lang/StringBuilder</h1><h1 id="43-NameAndType-50-51-append"><a href="#43-NameAndType-50-51-append" class="headerlink" title="43    =    NameAndType    #50:#51    // append:"></a>43    =    NameAndType    #50:#51    // append:</h1><p>(Ljava/lang/String;)Ljava/lang/StringBuilder;</p>
<h1 id="44-NameAndType-52-53-toString"><a href="#44-NameAndType-52-53-toString" class="headerlink" title="44 = NameAndType    #52:#53    //    toString:"></a>44 = NameAndType    #52:#53    //    toString:</h1><p>()Ljava/lang/String;            </p>
<h1 id="45-Class-54-java-lang-System"><a href="#45-Class-54-java-lang-System" class="headerlink" title="45 = Class    #54    //    java/lang/System"></a>45 = Class    #54    //    java/lang/System</h1><h1 id="46-NameAndType-55-56-out-Ljava-io-PrintStream"><a href="#46-NameAndType-55-56-out-Ljava-io-PrintStream" class="headerlink" title="46 = NameAndType    #55:#56    //    out:Ljava/io/PrintStream;"></a>46 = NameAndType    #55:#56    //    out:Ljava/io/PrintStream;</h1><h1 id="47-Class-57-java-io-PrintStream"><a href="#47-Class-57-java-io-PrintStream" class="headerlink" title="47 = Class    #57    //    java/io/PrintStream"></a>47 = Class    #57    //    java/io/PrintStream</h1><h1 id="48-NameAndType-58-59-println"><a href="#48-NameAndType-58-59-println" class="headerlink" title="48 = NameAndType    #58:#59    //    println:"></a>48 = NameAndType    #58:#59    //    println:</h1><p>(Ljava/lang/String;)V</p>
<pre><code>#49    =    Utf8    java/lang/Object
#50    =    Utf8    append
#51    =    Utf8    (Ljava/lang/String;)Ljava/lang/StringBuilder;
#52    =    Utf8    toString
#53    =    Utf8    ()Ljava/lang/String;
#54    =    Utf8    java/lang/System
#55    =    Utf8    out
#56    =    Utf8    Ljava/io/PrintStream;
#57    =    Utf8    java/io/PrintStream
#58    =    Utf8    println
#59    =    Utf8    (Ljava/lang/String;)V
</code></pre><p>{<br>public cn.itcast.jvm.Test3();<br>descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=1, locals=1, args_size=1 0: aload_0<br>1: invokespecial #1    // Method java/lang/Object.”<init>“:()V<br>4: return LineNumberTable:<br>line 3: 0 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    5    0    this    Lcn/itcast/jvm/Test3;</init></p>
<p>public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: new    #2    // class cn/itcast/jvm/Test3<br>3: dup<br>4: invokespecial #3    // Method “<init>“:()V<br>7: invokevirtual #4    // Method m1:()V<br>10: new    #2    // class cn/itcast/jvm/Test3<br>13: dup<br>14: invokespecial #3    // Method “<init>“:()V<br>17: invokevirtual #5    // Method m2:()V<br>20: return LineNumberTable:<br>line 6: 0<br>line 7: 10<br>line 8: 20 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    21    0    args    [Ljava/lang/String;</init></init></p>
<p>public void m1(); descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack=2, locals=4, args_size=1</p>
<p>0:    ldc    #6    //    String    123<br>2:    astore_1<br>3:    ldc    #7    //    String    456<br>5:    astore_2<br>6:    new    #8    //    class<br>java/lang/StringBuilder 9: dup<br>10: invokespecial #9    // Method java/lang/StringBuilder.”<init>“:()V<br>13: aload_1<br>14: invokevirtual #10    // Method java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>17: aload_2<br>18: invokevirtual #10    // Method java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>21: invokevirtual #11    // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>24: astore_3<br>25: getstatic    #12    // Field java/lang/System.out:Ljava/io/PrintStream;<br>28: aload_3<br>29: invokevirtual #13    // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>32: return LineNumberTable:<br>line 11: 0<br>line 12: 3<br>line 13: 6<br>line 14: 25<br>line 15: 32 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    33    0    this    Lcn/itcast/jvm/Test3;<br>3    30    1    s1    Ljava/lang/String;<br>6    27    2    s2    Ljava/lang/String;<br>25    8    3    s3    Ljava/lang/String;<br>public void m2(); descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=2, locals=5, args_size=1<br>0: ldc    #6    // String 123<br>2: astore_1<br>3: ldc    #7    // String 456<br>5: astore_2<br>6: new    #8    // class java/lang/StringBuilder<br>9: dup<br>10: invokespecial #9    // Method java/lang/StringBuilder.”<init>“:()V<br>13: astore_3<br>14: aload_3<br>15: aload_1<br>16: invokevirtual #10    // Method java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>19: pop<br>20: aload_3<br>21: aload_2<br>22: invokevirtual #10    // Method java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>25: pop<br>26: aload_3<br>27: invokevirtual #11    // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>30: astore    4<br>32: getstatic    #12    // Field java/lang/System.out:Ljava/io/PrintStream;<br>35: aload    4<br>37: invokevirtual #13    // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>40: return LineNumberTable:<br>line 18: 0<br>line 19: 3</init></init></p>
<p>line 20: 6<br>LocalVariableTable:<br>}<br>SourceFile: “Test3.java”</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>从解字节码中可以看出，m1()方法源码中是使用+号拼接，但是在字节码中也被编译成了<br>StringBuilder方式。<br>所以，可以得出结论，字符串拼接，+号和StringBuilder是相等的，效率一样。<br>接下来，我们再看一个案例：</p>
<p>package cn.itcast.jvm; public class Test4 {<br>public static void main(String[] args) { new Test4().m1();<br>new Test4().m2();<br>}</p>
<p>public void m1(){ String str = “”;<br>for (int i = 0; i &lt; 5; i++) { str = str + i;<br>}<br>System.out.println(str);<br>}</p>
<p>public void m2(){<br>StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 5; i++) {<br>sb.append(i);<br>}<br>System.out.println(sb.toString());<br>}<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>m1() 与 m2() 哪个方法的效率高？ 依然是通过字节码的方式进行探究。</p>
<p>Classfile /F:/code/itcast‐jvm/itcast‐jvm‐ test/target/classes/cn/itcast/jvm/Test4.class<br>MD5 checksum f87a55446b8b6cd88b6e54bd5edcc9dc Compiled from “Test4.java”<br>public class cn.itcast.jvm.Test4 minor version: 0<br>major version: 52<br>flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:</p>
<h1 id="1-Methodref-14-39-java-lang-Object-”“-V"><a href="#1-Methodref-14-39-java-lang-Object-”“-V" class="headerlink" title="1 = Methodref    #14.#39    // java/lang/Object.”“: ()V"></a>1 = Methodref    #14.#39    // java/lang/Object.”<init>“: ()V</init></h1><h1 id="2-Class-40-cn-itcast-jvm-Test4"><a href="#2-Class-40-cn-itcast-jvm-Test4" class="headerlink" title="2 = Class    #40    // cn/itcast/jvm/Test4"></a>2 = Class    #40    // cn/itcast/jvm/Test4</h1><h1 id="3-Methodref-2-39-cn-itcast-jvm-Test4-”"><a href="#3-Methodref-2-39-cn-itcast-jvm-Test4-”" class="headerlink" title="3 = Methodref    #2.#39    // cn/itcast/jvm/Test4.”"></a>3 = Methodref    #2.#39    // cn/itcast/jvm/Test4.”</h1><p><init>“:()V</init></p>
<h1 id="4-Methodref-2-41-cn-itcast-jvm-Test4-m1-V"><a href="#4-Methodref-2-41-cn-itcast-jvm-Test4-m1-V" class="headerlink" title="4 = Methodref    #2.#41    // cn/itcast/jvm/Test4.m1:()V"></a>4 = Methodref    #2.#41    // cn/itcast/jvm/Test4.m1:()V</h1><h1 id="5-Methodref-2-42-cn-itcast-jvm-Test4-m2-V"><a href="#5-Methodref-2-42-cn-itcast-jvm-Test4-m2-V" class="headerlink" title="5 = Methodref    #2.#42    // cn/itcast/jvm/Test4.m2:()V"></a>5 = Methodref    #2.#42    // cn/itcast/jvm/Test4.m2:()V</h1><h1 id="6-String-43"><a href="#6-String-43" class="headerlink" title="6 = String    #43    //"></a>6 = String    #43    //</h1><h1 id="7-Class-44-java-lang-StringBuilder"><a href="#7-Class-44-java-lang-StringBuilder" class="headerlink" title="7 = Class    #44    // java/lang/StringBuilder"></a>7 = Class    #44    // java/lang/StringBuilder</h1><h1 id="8-Methodref-7-39-java-lang-StringBuilder-”"><a href="#8-Methodref-7-39-java-lang-StringBuilder-”" class="headerlink" title="8 = Methodref    #7.#39    // java/lang/StringBuilder.”"></a>8 = Methodref    #7.#39    // java/lang/StringBuilder.”</h1><p><init>“:()V</init></p>
<h1 id="9-Methodref-7-45-java-lang-StringBuilder-append-Ljava-lang-String-Ljava-lang-StringBuilder"><a href="#9-Methodref-7-45-java-lang-StringBuilder-append-Ljava-lang-String-Ljava-lang-StringBuilder" class="headerlink" title="9 = Methodref    #7.#45    // java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;"></a>9 = Methodref    #7.#45    // java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;</h1><h1 id="10-Methodref-7-46-java-lang-StringBuilder-append-I-Ljava-lang-StringBuilder"><a href="#10-Methodref-7-46-java-lang-StringBuilder-append-I-Ljava-lang-StringBuilder" class="headerlink" title="10 = Methodref    #7.#46    // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;"></a>10 = Methodref    #7.#46    // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</h1><h1 id="11-Methodref-7-47-java-lang-StringBuilder-toString-Ljava-lang-String"><a href="#11-Methodref-7-47-java-lang-StringBuilder-toString-Ljava-lang-String" class="headerlink" title="11 = Methodref    #7.#47    // java/lang/StringBuilder.toString:()Ljava/lang/String;"></a>11 = Methodref    #7.#47    // java/lang/StringBuilder.toString:()Ljava/lang/String;</h1><h1 id="12-Fieldref-48-49-java-lang-System-out-Ljava-io-PrintStream"><a href="#12-Fieldref-48-49-java-lang-System-out-Ljava-io-PrintStream" class="headerlink" title="12 = Fieldref    #48.#49    // java/lang/System.out:Ljava/io/PrintStream;"></a>12 = Fieldref    #48.#49    // java/lang/System.out:Ljava/io/PrintStream;</h1><h1 id="13-Methodref-50-51-java-io-PrintStream-println-Ljava-lang-String-V"><a href="#13-Methodref-50-51-java-io-PrintStream-println-Ljava-lang-String-V" class="headerlink" title="13 = Methodref    #50.#51    // java/io/PrintStream.println: (Ljava/lang/String;)V"></a>13 = Methodref    #50.#51    // java/io/PrintStream.println: (Ljava/lang/String;)V</h1><h1 id="14-Class-52-java-lang-Object"><a href="#14-Class-52-java-lang-Object" class="headerlink" title="14 = Class    #52    // java/lang/Object"></a>14 = Class    #52    // java/lang/Object</h1><h1 id="15-Utf8-1"><a href="#15-Utf8-1" class="headerlink" title="15 = Utf8    "></a>15 = Utf8    <init></init></h1><h1 id="16-Utf8-V-1"><a href="#16-Utf8-V-1" class="headerlink" title="16 = Utf8    ()V"></a>16 = Utf8    ()V</h1><h1 id="17-Utf8-Code-1"><a href="#17-Utf8-Code-1" class="headerlink" title="17 = Utf8    Code"></a>17 = Utf8    Code</h1><h1 id="18-Utf8-LineNumberTable-1"><a href="#18-Utf8-LineNumberTable-1" class="headerlink" title="18 = Utf8    LineNumberTable"></a>18 = Utf8    LineNumberTable</h1><h1 id="19-Utf8-LocalVariableTable-1"><a href="#19-Utf8-LocalVariableTable-1" class="headerlink" title="19 = Utf8    LocalVariableTable"></a>19 = Utf8    LocalVariableTable</h1><h1 id="20-Utf8-this-1"><a href="#20-Utf8-this-1" class="headerlink" title="20 = Utf8    this"></a>20 = Utf8    this</h1><h1 id="21-Utf8-Lcn-itcast-jvm-Test4"><a href="#21-Utf8-Lcn-itcast-jvm-Test4" class="headerlink" title="21 = Utf8    Lcn/itcast/jvm/Test4;"></a>21 = Utf8    Lcn/itcast/jvm/Test4;</h1><h1 id="22-Utf8-main-1"><a href="#22-Utf8-main-1" class="headerlink" title="22 = Utf8    main"></a>22 = Utf8    main</h1><h1 id="23-Utf8-Ljava-lang-String-V-1"><a href="#23-Utf8-Ljava-lang-String-V-1" class="headerlink" title="23    =    Utf8    ([Ljava/lang/String;)V"></a>23    =    Utf8    ([Ljava/lang/String;)V</h1><h1 id="24-Utf8-args-1"><a href="#24-Utf8-args-1" class="headerlink" title="24    =    Utf8    args"></a>24    =    Utf8    args</h1><h1 id="25-Utf8-Ljava-lang-String-1"><a href="#25-Utf8-Ljava-lang-String-1" class="headerlink" title="25    =    Utf8    [Ljava/lang/String;"></a>25    =    Utf8    [Ljava/lang/String;</h1><h1 id="26-Utf8-m1-1"><a href="#26-Utf8-m1-1" class="headerlink" title="26    =    Utf8    m1"></a>26    =    Utf8    m1</h1><h1 id="27-Utf8-i"><a href="#27-Utf8-i" class="headerlink" title="27    =    Utf8    i"></a>27    =    Utf8    i</h1><h1 id="28-Utf8-I"><a href="#28-Utf8-I" class="headerlink" title="28    =    Utf8    I"></a>28    =    Utf8    I</h1><h1 id="29-Utf8-str"><a href="#29-Utf8-str" class="headerlink" title="29    =    Utf8    str"></a>29    =    Utf8    str</h1><h1 id="30-Utf8-Ljava-lang-String"><a href="#30-Utf8-Ljava-lang-String" class="headerlink" title="30    =    Utf8    Ljava/lang/String;"></a>30    =    Utf8    Ljava/lang/String;</h1><h1 id="31-Utf8-StackMapTable"><a href="#31-Utf8-StackMapTable" class="headerlink" title="31    =    Utf8    StackMapTable"></a>31    =    Utf8    StackMapTable</h1><h1 id="32-Class-53-java-lang-String"><a href="#32-Class-53-java-lang-String" class="headerlink" title="32    =    Class    #53    // java/lang/String"></a>32    =    Class    #53    // java/lang/String</h1><h1 id="33-Utf8-m2"><a href="#33-Utf8-m2" class="headerlink" title="33    =    Utf8    m2"></a>33    =    Utf8    m2</h1><h1 id="34-Utf8-sb"><a href="#34-Utf8-sb" class="headerlink" title="34    =    Utf8    sb"></a>34    =    Utf8    sb</h1><h1 id="35-Utf8-Ljava-lang-StringBuilder"><a href="#35-Utf8-Ljava-lang-StringBuilder" class="headerlink" title="35    =    Utf8    Ljava/lang/StringBuilder;"></a>35    =    Utf8    Ljava/lang/StringBuilder;</h1><h1 id="36-Class-44-java-lang-StringBuilder"><a href="#36-Class-44-java-lang-StringBuilder" class="headerlink" title="36    =    Class    #44    // java/lang/StringBuilder"></a>36    =    Class    #44    // java/lang/StringBuilder</h1><h1 id="37-Utf8-SourceFile"><a href="#37-Utf8-SourceFile" class="headerlink" title="37    =    Utf8    SourceFile"></a>37    =    Utf8    SourceFile</h1><h1 id="38-Utf8-Test4-java"><a href="#38-Utf8-Test4-java" class="headerlink" title="38    =    Utf8    Test4.java"></a>38    =    Utf8    Test4.java</h1><h1 id="39-NameAndType-15-16-““-V"><a href="#39-NameAndType-15-16-““-V" class="headerlink" title="39    =    NameAndType    #15:#16    // ““:()V"></a>39    =    NameAndType    #15:#16    // “<init>“:()V</init></h1><h1 id="40-Utf8-cn-itcast-jvm-Test4"><a href="#40-Utf8-cn-itcast-jvm-Test4" class="headerlink" title="40    =    Utf8    cn/itcast/jvm/Test4"></a>40    =    Utf8    cn/itcast/jvm/Test4</h1><h1 id="41-NameAndType-26-16-m1-V"><a href="#41-NameAndType-26-16-m1-V" class="headerlink" title="41    =    NameAndType    #26:#16    // m1:()V"></a>41    =    NameAndType    #26:#16    // m1:()V</h1><h1 id="42-NameAndType-33-16-m2-V"><a href="#42-NameAndType-33-16-m2-V" class="headerlink" title="42    =    NameAndType    #33:#16    // m2:()V"></a>42    =    NameAndType    #33:#16    // m2:()V</h1><h1 id="43-Utf8"><a href="#43-Utf8" class="headerlink" title="43    =    Utf8"></a>43    =    Utf8</h1><h1 id="44-Utf8-java-lang-StringBuilder"><a href="#44-Utf8-java-lang-StringBuilder" class="headerlink" title="44    =    Utf8    java/lang/StringBuilder"></a>44    =    Utf8    java/lang/StringBuilder</h1><h1 id="45-NameAndType-54-55-append"><a href="#45-NameAndType-54-55-append" class="headerlink" title="45    =    NameAndType    #54:#55    // append:"></a>45    =    NameAndType    #54:#55    // append:</h1><p>(Ljava/lang/String;)Ljava/lang/StringBuilder;</p>
<h1 id="46-NameAndType-54-56-append-I-Ljava-lang-StringBuilder"><a href="#46-NameAndType-54-56-append-I-Ljava-lang-StringBuilder" class="headerlink" title="46 = NameAndType    #54:#56    // append: (I)Ljava/lang/StringBuilder;"></a>46 = NameAndType    #54:#56    // append: (I)Ljava/lang/StringBuilder;</h1><h1 id="47-NameAndType-57-58-toString"><a href="#47-NameAndType-57-58-toString" class="headerlink" title="47 = NameAndType    #57:#58    //    toString:"></a>47 = NameAndType    #57:#58    //    toString:</h1><p>()Ljava/lang/String;            </p>
<h1 id="48-Class-59-java-lang-System"><a href="#48-Class-59-java-lang-System" class="headerlink" title="48 = Class    #59    //    java/lang/System"></a>48 = Class    #59    //    java/lang/System</h1><h1 id="49-NameAndType-60-61-out-Ljava-io-PrintStream"><a href="#49-NameAndType-60-61-out-Ljava-io-PrintStream" class="headerlink" title="49 = NameAndType    #60:#61    //    out:Ljava/io/PrintStream;"></a>49 = NameAndType    #60:#61    //    out:Ljava/io/PrintStream;</h1><h1 id="50-Class-62-java-io-PrintStream"><a href="#50-Class-62-java-io-PrintStream" class="headerlink" title="50 = Class    #62    //    java/io/PrintStream"></a>50 = Class    #62    //    java/io/PrintStream</h1><h1 id="51-NameAndType-63-64-println"><a href="#51-NameAndType-63-64-println" class="headerlink" title="51 = NameAndType    #63:#64    //    println:"></a>51 = NameAndType    #63:#64    //    println:</h1><p>(Ljava/lang/String;)V</p>
<h1 id="52-Utf8-java-lang-Object"><a href="#52-Utf8-java-lang-Object" class="headerlink" title="52 = Utf8    java/lang/Object"></a>52 = Utf8    java/lang/Object</h1><h1 id="53-Utf8-java-lang-String"><a href="#53-Utf8-java-lang-String" class="headerlink" title="53 = Utf8    java/lang/String"></a>53 = Utf8    java/lang/String</h1><h1 id="54-Utf8-append"><a href="#54-Utf8-append" class="headerlink" title="54 = Utf8    append"></a>54 = Utf8    append</h1><h1 id="55-Utf8-Ljava-lang-String-Ljava-lang-StringBuilder"><a href="#55-Utf8-Ljava-lang-String-Ljava-lang-StringBuilder" class="headerlink" title="55 = Utf8    (Ljava/lang/String;)Ljava/lang/StringBuilder;"></a>55 = Utf8    (Ljava/lang/String;)Ljava/lang/StringBuilder;</h1><h1 id="56-Utf8-I-Ljava-lang-StringBuilder"><a href="#56-Utf8-I-Ljava-lang-StringBuilder" class="headerlink" title="56 = Utf8    (I)Ljava/lang/StringBuilder;"></a>56 = Utf8    (I)Ljava/lang/StringBuilder;</h1><h1 id="57-Utf8-toString"><a href="#57-Utf8-toString" class="headerlink" title="57 = Utf8    toString"></a>57 = Utf8    toString</h1><h1 id="58-Utf8-Ljava-lang-String"><a href="#58-Utf8-Ljava-lang-String" class="headerlink" title="58 = Utf8    ()Ljava/lang/String;"></a>58 = Utf8    ()Ljava/lang/String;</h1><h1 id="59-Utf8-java-lang-System"><a href="#59-Utf8-java-lang-System" class="headerlink" title="59 = Utf8    java/lang/System"></a>59 = Utf8    java/lang/System</h1><h1 id="60-Utf8-out"><a href="#60-Utf8-out" class="headerlink" title="60 = Utf8    out"></a>60 = Utf8    out</h1><h1 id="61-Utf8-Ljava-io-PrintStream"><a href="#61-Utf8-Ljava-io-PrintStream" class="headerlink" title="61 = Utf8    Ljava/io/PrintStream;"></a>61 = Utf8    Ljava/io/PrintStream;</h1><h1 id="62-Utf8-java-io-PrintStream"><a href="#62-Utf8-java-io-PrintStream" class="headerlink" title="62 = Utf8    java/io/PrintStream"></a>62 = Utf8    java/io/PrintStream</h1><h1 id="63-Utf8-println"><a href="#63-Utf8-println" class="headerlink" title="63 = Utf8    println"></a>63 = Utf8    println</h1><h1 id="64-Utf8-Ljava-lang-String-V"><a href="#64-Utf8-Ljava-lang-String-V" class="headerlink" title="64 = Utf8    (Ljava/lang/String;)V"></a>64 = Utf8    (Ljava/lang/String;)V</h1><p>{<br>public cn.itcast.jvm.Test4(); descriptor: ()V<br>flags: ACC_PUBLIC Code:<br>stack=1, locals=1, args_size=1 0: aload_0<br>1: invokespecial #1    // Method<br>java/lang/Object.”<init>“:()V<br>4: return LineNumberTable:<br>line 3: 0 LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    5    0    this    Lcn/itcast/jvm/Test4;</init></p>
<p>public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=2, locals=1, args_size=1<br>0: new    #2    // class cn/itcast/jvm/Test4<br>3: dup<br>4: invokespecial #3    // Method “<init>“:()V<br>7: invokevirtual #4    // Method m1:()V<br>10: new    #2    // class cn/itcast/jvm/Test4<br>13: dup<br>14: invokespecial #3    // Method “<init>“:()V<br>17: invokevirtual #5    // Method m2:()V<br>20: return LineNumberTable:<br>line 6: 0<br>line 7: 10</init></init></p>
<p>line 8: 20</p>
<p>LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>0    21    0    args    [Ljava/lang/String;<br>public void m1(); descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=2, locals=3, args_size=1<br>0: ldc    #6    // String<br>2: astore_1    // 将空字符串压入到本地变量表中的下标为1的位置<br>3: iconst_0    // 将数字0压入操作栈顶<br>4: istore_2    // 将栈顶数字0压入到本地变量表中的下标为2的位置<br>5: iload_2    // 将本地变量中下标为2的数字0压入操作栈顶<br>6: iconst_5 // 将数字5压入操作栈顶<br>7: if_icmpge    35    //比较栈顶两int型数值大小，当结果大于等于0时跳</p>
<p>转到35</p>
<p>10: new    #7    // class</p>
<p>java/lang/StringBuilder<br>13: dup    //复制栈顶数值并将复制值压入栈顶(数字5)<br>14: invokespecial #8    // Method java/lang/StringBuilder.”<init>“:()V<br>17: aload_1<br>18: invokevirtual #9    // Method java/lang/StringBuilder.append: (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>21: iload_2 //将本地变量中下标为2的数字0压入操作栈顶<br>22: invokevirtual #10    // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;<br>25: invokevirtual #11    // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>28:    astore_1<br>29:    iinc    2, 1<br>32:    goto    5<br>35:    getstatic    #12    // Field<br>java/lang/System.out:Ljava/io/PrintStream; 38: aload_1<br>39: invokevirtual #13    // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>42: return LineNumberTable:</init></p>
<p>line    11:    0<br>line    12:    3<br>line    13:    10<br>line    12:    29<br>line    15:    35<br>line    16:    42<br>LocalVariableTable:<br>Start    Length    Slot    Name    Signature<br>5    30    2    i    I<br>0    43    0    this    Lcn/itcast/jvm/Test4;<br>3    40    1    str    Ljava/lang/String;<br>StackMapTable: number_of_entries = 2 frame_type = 253 /<em> append </em>/<br>offset_delta = 5<br>locals = [ class java/lang/String, int ] frame_type = 250 /<em> chop </em>/<br>offset_delta = 29</p>
<p>public void m2(); descriptor: ()V flags: ACC_PUBLIC Code:<br>stack=2, locals=3, args_size=1<br>0: new    #7    // class java/lang/StringBuilder<br>3: dup<br>4: invokespecial #8    // Method java/lang/StringBuilder.”<init>“:()V<br>7: astore_1<br>8: iconst_0<br>9: istore_2<br>10: iload_2<br>11: iconst_5<br>12: if_icmpge    27<br>15: aload_1<br>16: iload_2<br>17: invokevirtual #10    // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;<br>20: pop<br>21: iinc    2, 1<br>24: goto    10<br>27: getstatic    #12    // Field java/lang/System.out:Ljava/io/PrintStream;<br>30: aload_1<br>31: invokevirtual #11    // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>34: invokevirtual #13    // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>37: return LineNumberTable:<br>line 19: 0<br>line 20: 8<br>line 21: 15<br>line 20: 21<br>line 23: 27<br>line 24: 37 LocalVariableTable:<br>Start    Length    Slot    Name    Signature 10        17        2        i    I<br>0    38    0    this    Lcn/itcast/jvm/Test4;<br>8    30    1    sb    Ljava/lang/StringBuilder;<br>StackMapTable: number_of_entries = 2 frame_type = 253 /<em> append </em>/<br>offset_delta = 10<br>locals = [ class java/lang/StringBuilder, int ] frame_type = 250 /<em> chop </em>/<br>offset_delta = 16<br>}<br>SourceFile: “Test4.java”</init></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>可以看到，m1()方法中的循环体内，每一次循环都会创建StringBuilder对象，效率低于<br>m2()方法。</p>
<p>2.7、小结<br>使用字节码的方式可以很好查看代码底层的执行，从而可以看出哪些实现效率高，哪些 实现效率低。可以更好的对我们的代码做优化。让程序执行效率更高。</p>
<p>3、代码优化<br>优化，不仅仅是在运行环境进行优化，还需要在代码本身做优化，如果代码本身存在性 能问题，那么在其他方面再怎么优化也不可能达到效果最优的。</p>
<p>3.1、尽可能使用局部变量<br>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变 量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随 着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<p>3.2、尽量减少对变量的重复计算<br>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的。所以例如下 面的操作：</p>
<p>for (int i = 0; i &lt; list.size(); i++)<br>{…}<br>1<br>2<br>建议替换为：</p>
<p>int length = list.size();<br>for (int i = 0,    i &lt; length; i++)<br>{…}</p>
<p>1<br>2<br>3<br>4<br>这样，在list.size()很大的时候，就减少了很多的消耗。</p>
<p>3.3、尽量采用懒加载的策略，即在需要的时候才创建<br>String str = “aaa”;<br>if (i == 1){<br>list.add(str);<br>}<br>//建议替换成<br>if (i == 1){<br>String str = “aaa”; list.add(str);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>3.4、异常不应该用来控制程序流程<br>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用 名为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p>
<p>3.5、不要将数组声明为public static final<br>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的， 将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p>
<p>3.6、不要创建一些不使用的对象，不要导入一些不使用的类<br>这毫无意义，如果代码中出现”The value of the local variable i is not used”、“The import java.util is never used”，那么请删除这些无用的内容</p>
<p>3.7、程序运行过程中避免使用反射<br>反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method的invoke方法。<br>如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候 通过反射实例化出一个对象并放入内存。</p>
<p>3.8、使用数据库连接池和线程池<br>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频 繁地创建和销毁线程。</p>
<p>3.9、容器初始化时尽可能指定长度<br>容器初始化时尽可能指定长度，如：new ArrayList&lt;&gt;(10); new HashMap&lt;&gt;(32); 避免容器长度不足时，扩容带来的性能损耗。</p>
<p>3.10、ArrayList随机遍历快，LinkedList添加删除快<br>3.11、使用Entry遍历Map<br>Map<string,string> map = new HashMap&lt;&gt;();<br>for (Map.Entry<string,string> entry : map.entrySet()) { String key = entry.getKey();<br>String value = entry.getValue();<br>}<br>1<br>2<br>3<br>4<br>避免使用这种方式：</string,string></string,string></p>
<p>Map<string,string> map = new HashMap&lt;&gt;(); for (String key : map.keySet()) {<br>String value = map.get(key);<br>}<br>1<br>2<br>3<br>3.12、不要手动调用System.gc();<br>3.13、String尽量少用正则表达式<br>正则表达式虽然功能强大，但是其效率较低，除非是有需要，否则尽可能少用。</string,string></p>
<p>replace() 不支持正则<br>replaceAll() 支持正则<br>如果仅仅是字符的替换建议使用replace()。</p>
<p>3.14、日志的输出要注意级别<br>// 当 前 的 日 志 级 别 是 error LOGGER.info(“保存出错！” + user);<br>1<br>3.15、对资源的close()建议分开操作<br>try{<br>XXX.close();<br>YYY.close();<br>}<br>catch (Exception e){<br>…<br>}<br>// 建议改为<br>try{<br>XXX.close();<br>}<br>catch (Exception e){<br>…<br>}<br>try{<br>YYY.close();<br>}<br>catch (Exception e){<br>…<br>}</p>
</connector></executor></connector>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/" itemprop="url">
                  架构与优化之JVM优化第02篇垃圾回收
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-20 00:03:11" itemprop="dateCreated datePublished" datetime="2019-12-20T00:03:11+08:00">2019-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-27 14:07:48" itemprop="dateModified" datetime="2019-12-27T14:07:48+08:00">2019-12-27</time>
              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>了解什么是垃圾回收</li>
<li>掌握垃圾会回收的常见算法</li>
<li>学习串行、并行、并发、G1垃圾收集器</li>
<li>学习GC日志的可视化查看</li>
</ul>
<h1 id="1、什么是垃圾回收？"><a href="#1、什么是垃圾回收？" class="headerlink" title="1、什么是垃圾回收？"></a>1、什么是垃圾回收？</h1><p>程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存 资源，最终将导致内存溢出，所以对内存资源的管理是非常重要了。</p>
<p><strong>通俗的理解java对象的这一辈子</strong></p>
<p>　　我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
<p><img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\image-20191227111522922.png" alt="image-20191227111522922"></p>
<p>GC策略解决了哪些问题？</p>
<p>既然是要进行自动GC，那必然会有相应的策略，而这些策略解决了哪些问题呢，粗略的来说，主要有以下几点。</p>
<p>​    <strong>1、哪些对象可以被回收。（ 根搜索算法解决）</strong></p>
<p>​    <strong>2、何时回收这些对象。</strong></p>
<p>​    <strong>3、采用什么样的方式回收。</strong></p>
<p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\18021456-60fcf6f4303e4facbb2a6b57d99b3a6d.jpg" alt="img"> </p>
<p>根搜索算法</p>
<p>​     由于引用计数算法的缺陷，所以JVM一般会采用一种新的算法，叫做<strong>根搜索算法</strong>。它的处理方式就是，<strong>设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的</strong>。</p>
<p> 就拿上图来说，ObjectD和ObjectE是互相关联的，但是由于GC roots到这两个对象不可达，所以最终D和E还是会被当做GC的对象，上图若是采用引用计数法，则A-E五个对象都不会被回收。</p>
<p>​     说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：</p>
<p>​     <strong>1、虚拟机栈中的引用的对象。</strong></p>
<p>​     <strong>2、方法区中的类静态属性引用的对象。</strong></p>
<p>​     <strong>3、方法区中的常量引用的对象。</strong></p>
<p>​     <strong>4、本地方法栈中JNI的引用的对象。</strong></p>
<p>​     第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</p>
<p>​        HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>　　因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>　　在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\young_gc.png" alt="young_gc"> </p>
<h2 id="1-1、C-C-语言的垃圾回收"><a href="#1-1、C-C-语言的垃圾回收" class="headerlink" title="1.1、C/C++语言的垃圾回收"></a>1.1、C/C++语言的垃圾回收</h2><p>在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete 关键字释放内存资源。</p>
<p>如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源， 最终可能会导致内存溢出。</p>
<h2 id="1-2、Java语言的垃圾回收"><a href="#1-2、Java语言的垃圾回收" class="headerlink" title="1.2、Java语言的垃圾回收"></a>1.2、Java语言的垃圾回收</h2><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别 完成。<br>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致 内存资源一直没有释放，同样也可能会导致内存溢出的。</p>
<p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p>
<h1 id="2、垃圾回收的常见算法"><a href="#2、垃圾回收的常见算法" class="headerlink" title="2、垃圾回收的常见算法"></a>2、垃圾回收的常见算法</h1><p>自动化的管理内存资源，垃圾回收机制必须要有一套算法来进行计算，哪些是有效的对 象，哪些是无效的对象，对于无效的对象就要进行回收处理。</p>
<p>常见的垃圾回收算法有：引用计数法、标记清除法、标记压缩法、复制算法、分代算法 等。</p>
<h2 id="2-1、引用计数法"><a href="#2-1、引用计数法" class="headerlink" title="2.1、引用计数法"></a>2.1、引用计数法</h2><p>引用计数是历史最悠久的一种算法，最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。</p>
<h3 id="2-1-1、原理"><a href="#2-1-1、原理" class="headerlink" title="2.1.1、原理"></a>2.1.1、原理</h3><p>假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败 时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了， 可以被回收。</p>
<h3 id="2-1-2、优缺点"><a href="#2-1-2、优缺点" class="headerlink" title="2.1.2、优缺点"></a>2.1.2、优缺点</h3><p>优点：</p>
<ul>
<li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li>
<li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报<br>outofmember 错误。</li>
<li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li>
<li>浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。</li>
<li>无法解决循环引用问题。（最大的缺点）</li>
</ul>
<p>什么是循环引用？</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TestA &#123;</span><br><span class="line">    public TestB b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestB &#123;</span><br><span class="line">    public TestA a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        B b = new B();</span><br><span class="line">        a.b = b;</span><br><span class="line">        b.a = a;</span><br><span class="line">        a = null;</span><br><span class="line">        b = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Object &#123;</span><br><span class="line"></span><br><span class="line">    Object field = null;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Object objectA = new Object();</span><br><span class="line">                Object objectB = new Object();//1</span><br><span class="line">                objectA.field = objectB;</span><br><span class="line">                objectB.field = objectA;//2</span><br><span class="line">                //to do something</span><br><span class="line">                objectA = null;</span><br><span class="line">                objectB = null;//3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 这段代码看起来有点刻意为之，但其实在实际编程过程当中，是经常出现的，比如两个一对一关系的数据库对象，各自保持着对方的引用。最后一个无限循环只是为了保持JVM不退出，没什么实际意义。</p>
<p>​     对于我们现在使用的GC来说，当thread线程运行结束后，会将objectA和objectB全部作为待回收的对象。而如果我们的GC采用上面所说的引用计数算法，则这两个对象永远不会被回收，即便我们在使用后显示的将对象归为空值也毫无作用。</p>
<p>​     这里LZ大致解释一下，在代码中LZ标注了1、2、3三个数字，当第1个地方的语句执行完以后，两个对象的引用计数全部为1。当第2个地方的语句执行完以后，两个对象的引用计数就全部变成了2。当第3个地方的语句执行完以后，也就是将二者全部归为空值以后，二者的引用计数仍然为1。根据引用计数算法的回收规则，引用计数没有归0的时候是不会被回收的。</p>
<h2 id="2-2、标记清除法（五分钟让你彻底明白标记-清除算法）"><a href="#2-2、标记清除法（五分钟让你彻底明白标记-清除算法）" class="headerlink" title="2.2、标记清除法（五分钟让你彻底明白标记/清除算法）"></a>2.2、标记清除法（五分钟让你彻底明白标记/清除算法）</h2><p>​        首先，我们通过根搜索算法知道，它可以解决我们应该回收哪些对象的问题，但是它显然还不能承担垃圾搜集的重任，<strong>因为我们在程序（程序也就是指我们运行在JVM上的JAVA程序）运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收</strong>。</p>
<p>​        为了达到这个目的，标记/清除算法就应运而生了。<strong>它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</strong>。</p>
<p>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。</p>
<ul>
<li>标记：从根节点开始标记引用的对象。( <strong>标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</strong> )</li>
<li>清除：未被标记引用的对象就是垃圾对象，可以被清理。( <strong>清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</strong> )</li>
</ul>
<p><strong>通俗的话解释一下标记/清除算法：</strong></p>
<p>​        就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 </p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\19222114-6435e25e050f4a2ea3230879392bdfb3.jpg" alt="img"> </p>
<p>这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记， 以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根(root)搜索算法，标记完以后， 对象的状态如下图。</p>
<p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\19222543-1da7fb7bc5d24fd18872a267b65e939e.jpg" alt="img"> </p>
<p>可以看到，按照根(root)搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。</p>
<p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\19222820-8eca1c1518754d8fac6da532b13f746b.jpg" alt="img"> </p>
<p>可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。</p>
<p>为什么非要停止程序的运行呢？</p>
<p>​     这个其实也不难理解，LZ举个最简单的例子，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。</p>
<p>​     假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。</p>
<p>​     上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？</p>
<h3 id="2-2-2、优缺点"><a href="#2-2-2、优缺点" class="headerlink" title="2.2.2、优缺点"></a>2.2.2、优缺点</h3><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引 用的对象都会被回收。</p>
<p>同样，标记清除算法也是有缺点的：<br>1、效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。</p>
<p> <strong>（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</strong>，尤其对于交互式的应用程序来说简直是无法接受。试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？ </p>
<p>2、 第二点主要的缺点，则是<strong>这种方式清理出来的空闲内存是不连续的</strong>通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</p>
<p> 第二点主要的缺点，则是<strong>这种方式清理出来的空闲内存是不连续的</strong>，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 </p>
<h2 id="2-3、标记压缩算法"><a href="#2-3、标记压缩算法" class="headerlink" title="2.3、标记压缩算法"></a>2.3、标记压缩算法</h2><p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一 样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标 记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决 了碎片化的问题。</p>
<p>2.3.1、原理</p>
<h3 id="2-3-2、优缺点"><a href="#2-3-2、优缺点" class="headerlink" title="2.3.2、优缺点"></a>2.3.2、优缺点</h3><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p>
<h2 id="2-4、复制算法"><a href="#2-4、复制算法" class="headerlink" title="2.4、复制算法"></a>2.4、复制算法</h2><p>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。<br>如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</p>
<p><img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\image-20191227105028340.png" alt="image-20191227105028340"></p>
<h3 id="2-4-1、JVM中年轻代内存空间"><a href="#2-4-1、JVM中年轻代内存空间" class="headerlink" title="2.4.1、JVM中年轻代内存空间"></a>2.4.1、JVM中年轻代内存空间</h3><p> <img src="/2019/12/20/架构与优化之JVM优化第02篇垃圾回收/blog\jygBlog\source\_posts\架构与优化之JVM优化第02篇垃圾回收\young_gc.png" alt="young_gc">  </p>
<p>1.在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor 区“To”是空的。</p>
<p>2.紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍 存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过- XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对 象会被复制到“To”区域。</p>
<p>3.经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他 们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。</p>
<p>4.GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>2.4.2、优缺点<br>优点：</p>
<p>在垃圾对象多的情况下，效率较高清理后，内存无碎片<br>缺点：</p>
<p>在垃圾对象少的情况下，不适用，如：老年代内存<br>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</p>
<p>2.5、分代算法<br>前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所 以根据垃圾回收对象的特点进行选择，才是明智的选择。<br>分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复 制算法，老年代适合使用标记清除或标记压缩算法。</p>
<p>3、垃圾收集器以及内存分配<br>前面我们讲了垃圾回收的算法，还需要有具体的实现，在jvm中，实现了多种垃圾收集 器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器，接下来，我们一个个的了解学习。</p>
<p>3.1、串行垃圾收集器<br>串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作， 并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。<br>对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。一般在Javaweb应用中是不会采用该收集器的。<br>3.1.1、编写测试代码</p>
<p>package cn.itcast.jvm;</p>
<p>import java.util.ArrayList; import java.util.List; import java.util.Properties; import java.util.Random;</p>
<p>public class TestGC {</p>
<p>public static void main(String[] args) throws Exception { List<object> list = new ArrayList<object>();<br>while (true){<br>int sleep = new Random().nextInt(100); if(System.currentTimeMillis() % 2 ==0){<br>list.clear();<br>}else{<br>for (int i = 0; i &lt; 10000; i++) {<br>Properties properties = new Properties(); properties.put(“key_”+i, “value_” +<br>System.currentTimeMillis() + i);<br>list.add(properties);<br>}<br>}</object></object></p>
<p>// System.out.println(“list大小为：” + list.size());</p>
<p>Thread.sleep(sleep);<br>}<br>}<br>}</p>
<p>3.1.2、设置垃圾回收为串行收集器<br>在程序运行参数中添加2个参数，如下：<br>-XX:+UseSerialGC<br>指定年轻代和老年代都使用串行垃圾收集器<br>-XX:+PrintGCDetails<br>打印垃圾回收的详细信息</p>
<p>为了测试GC，将堆的初始和最大内存都设置为16M<br>‐XX:+UseSerialGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<p>启动程序，可以看到下面信息：</p>
<p>[GC (Allocation Failure) [DefNew: 4416K‐&gt;512K(4928K), 0.0046102 secs]<br>4416K‐&gt;1973K(15872K), 0.0046533 secs] [Times: user=0.00 sys=0.00,<br>real=0.00 secs]</p>
<p>[Full GC (Allocation Failure) [Tenured: 10944K‐&gt;3107K(10944K), 0.0085637<br>secs] 15871K‐&gt;3107K(15872K), [Metaspace: 3496K‐&gt;3496K(1056768K)],<br>0.0085974 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</p>
<p>GC日志信息解读：<br>年轻代的内存GC前后的大小：<br>DefNew<br>表示使用的是串行垃圾收集器。<br>4416K-&gt;512K(4928K)<br>表示，年轻代GC前，占有4416K内存，GC后，占有512K内存，总大小4928K 0.0046102 secs<br>表示，GC所用的时间，单位为毫秒。<br>4416K-&gt;1973K(15872K)<br>表示，GC前，堆内存占有4416K，GC后，占有1973K，总大小为15872K Full GC<br>表示，内存空间全部进行GC</p>
<p>3.2、并行垃圾收集器<br>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃 圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）<br>当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是 一样的，只是并行执行，速度更快些，暂停的时间更短一些。</p>
<p>3.2.1、ParNew垃圾收集器<br>ParNew垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。<br>通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器。</p>
<p>测试：</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>‐XX:+UseParNewGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<h1 id="打印出的信息"><a href="#打印出的信息" class="headerlink" title="打印出的信息"></a>打印出的信息</h1><p>[GC (Allocation Failure) [ParNew: 4416K‐&gt;512K(4928K), 0.0032106 secs] 4416K‐&gt;1988K(15872K), 0.0032697 secs] [Times: user=0.00 sys=0.00,<br>real=0.00 secs]</p>
<p>由以上信息可以看出， 致。</p>
<p>使用的是ParNew收集器。其他信息和串行收集器一</p>
<p>3.2.2、ParallelGC垃圾收集器<br>ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和 系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。</p>
<p>相关参数如下：</p>
<p>-XX:+UseParallelGC<br>年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器。<br>-XX:+UseParallelOldGC<br>年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC垃圾回收器。<br>-XX:MaxGCPauseMillis<br>设置最大的垃圾收集时的停顿时间，单位为毫秒<br>需要注意的时，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他 的参数，如果堆的大小设置的较小，就会导致GC工作变得很频繁，反而可能会 影响到性能。<br>该参数使用需谨慎。<br>-XX:GCTimeRatio<br>设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。<br>它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1%<br>-XX:UseAdaptiveSizePolicy<br>自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。<br>一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。<br>测试：</p>
<h1 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h1><p>‐XX:+UseParallelGC ‐XX:+UseParallelOldGC ‐XX:MaxGCPauseMillis=100 ‐ XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<h1 id="打印的信息"><a href="#打印的信息" class="headerlink" title="打印的信息"></a>打印的信息</h1><p>[GC (Allocation Failure) [PSYoungGen: 4096K‐&gt;480K(4608K)] 4096K‐</p>
<blockquote>
<p>1840K(15872K), 0.0034307 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
</blockquote>
<p>[Full GC (Ergonomics) [PSYoungGen: 505K‐&gt;0K(4608K)] [ParOldGen: 10332K‐</p>
<blockquote>
<p>10751K(11264K)] 10837K‐&gt;10751K(15872K), [Metaspace: 3491K‐<br>3491K(1056768K)], 0.0793622 secs] [Times: user=0.13 sys=0.00, real=0.08<br>secs]</p>
<p>有以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器。</p>
</blockquote>
<p>3.3、CMS垃圾收集器<br>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器， 该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。<br>CMS垃圾回收器的执行过程如下：初始化标记(CMS-initial-mark) ,标记root，会导致stw；<br>并发标记(CMS-concurrent-mark)，与用户线程同时运行；<br>预清理（CMS-concurrent-preclean），与用户线程同时运行； 重新标记(CMS-remark) ，会导致stw；<br>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；<br>调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；<br>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；<br>3.3.1、测试</p>
<h1 id="设置启动参数"><a href="#设置启动参数" class="headerlink" title="设置启动参数"></a>设置启动参数</h1><p>‐XX:+UseConcMarkSweepGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<h1 id="运行日志"><a href="#运行日志" class="headerlink" title="运行日志"></a>运行日志</h1><p>[GC (Allocation Failure) [ParNew: 4926K‐&gt;512K(4928K), 0.0041843 secs] 9424K‐&gt;6736K(15872K), 0.0042168 secs] [Times: user=0.00 sys=0.00,<br>real=0.00 secs]</p>
<h1 id="第一步，初始标记"><a href="#第一步，初始标记" class="headerlink" title="第一步，初始标记"></a>第一步，初始标记</h1><p>[GC (CMS Initial Mark) [1 CMS‐initial‐mark: 6224K(10944K)] 6824K(15872K), 0.0004209 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<h1 id="第二步，并发标记"><a href="#第二步，并发标记" class="headerlink" title="第二步，并发标记"></a>第二步，并发标记</h1><p>[CMS‐concurrent‐mark‐start]<br>[CMS‐concurrent‐mark: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<h1 id="第三步，预处理"><a href="#第三步，预处理" class="headerlink" title="第三步，预处理"></a>第三步，预处理</h1><p>[CMS‐concurrent‐preclean‐start]<br>[CMS‐concurrent‐preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<h1 id="第四步，重新标记"><a href="#第四步，重新标记" class="headerlink" title="第四步，重新标记"></a>第四步，重新标记</h1><p>[GC (CMS Final Remark) [YG occupancy: 1657 K (4928 K)][Rescan (parallel) , 0.0005811 secs][weak refs processing, 0.0000136 secs][class unloading, 0.0003671 secs][scrub symbol table, 0.0006813 secs][scrub string table, 0.0001216 secs][1 CMS‐remark: 6224K(10944K)] 7881K(15872K), 0.0018324<br>secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第五步，并发清理<br>[CMS‐concurrent‐sweep‐start]<br>[CMS‐concurrent‐sweep: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<h1 id="第六步，重置"><a href="#第六步，重置" class="headerlink" title="第六步，重置"></a>第六步，重置</h1><p>[CMS‐concurrent‐reset‐start]<br>[CMS‐concurrent‐reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<p>由以上日志信息，可以看出CMS执行的过程。</p>
<p>3.4、G1垃圾收集器（重点）<br>G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器，oracle官方计划在jdk9中将 G1变成默认的垃圾收集器，以替代CMS。<br>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：<br>1.第一步，开启G1垃圾收集器<br>2.第二步，设置堆的最大内存<br>3.第三步，设置最大的停顿时间<br>G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<p>3.4.1、原理<br>G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理 划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的 年轻代、老年代区域。</p>
<p>这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内 存是否足够。<br>在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区 域，完成了清理工作。</p>
<p>这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。<br>在G1中，有一种特殊的区域，叫Humongous区域。<br>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。<br>这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。<br>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果<br>一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。<br>3.4.2、Young GC<br>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。<br>Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分 数据会直接晋升到年老代空间。<br>Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。 最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p>
<p>3.4.2.1、Remembered Set（已记忆集合）<br>在GC年轻代的对象时，我们如何找到年轻代中对象的根对象呢？<br>根对象可能是在年轻代中，也可以在老年代中，那么老年代中的所有对象都是根么？ 如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。<br>于是，G1引进了RSet的概念。它的全称是Remembered Set，其作用是跟踪指向某个堆<br>内的对象引用。每个Region初始化时，会初始化一个RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录 的东西应该是 xx Region的 xx Card。<br>3.4.3、Mixed GC<br>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC 并不是 Full GC。<br>MixedGC什么时候触发？ 由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。<br>它的GC步骤分2步：<br>1.全局并发标记（global concurrent marking）<br>2.拷贝存活对象（evacuation）<br>3.4.3.1、全局并发标记<br>全局并发标记，执行过程分为五个步骤：<br>初始标记（initial mark，STW）<br>标记从根节点直接可达的对象，这个阶段会执行一次年轻代GC，会产生全局停顿。<br>根区域扫描（root region scan）<br>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。<br>该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。<br>并发标记（Concurrent Marking）<br>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行， 可以被 STW 年轻代垃圾回收中断。<br>重新标记（Remark，STW）<br>该阶段是 STW 回收，因为程序在运行，针对上一次的标记进行修正。清除垃圾（Cleanup，STW）<br>清点和重置标记状态，该阶段会STW，这个阶段并不会实际上去做垃圾的收集， 等待evacuation阶段来回收。<br>3.4.3.2、拷贝存活对象<br>Evacuation阶段是全暂停的。该阶段把一部分Region里的活对象拷贝到另一部分Region<br>中，从而实现垃圾的回收清理。</p>
<p>3.4.4、G1收集器相关参数<br>-XX:+UseG1GC<br>使用 G1 垃圾收集器<br>-XX:MaxGCPauseMillis<br>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是 200 毫秒。<br>-XX:G1HeapRegionSize=n<br>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。<br>默认是堆内存的1/2000。<br>-XX:ParallelGCThreads=n<br>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。<br>-XX:ConcGCThreads=n<br>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads)<br>的 1/4 左右。<br>-XX:InitiatingHeapOccupancyPercent=n<br>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。<br>3.4.5、测试</p>
<p>‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=100 ‐XX:+PrintGCDetails ‐Xmx256m</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>[GC pause (G1 Evacuation Pause) (young), 0.0044882 secs] [Parallel Time: 3.7 ms, GC Workers: 3]<br>[GC Worker Start (ms): Min: 14763.7, Avg: 14763.8, Max: 14763.8, Diff: 0.1]</p>
<h1 id="扫描根节点"><a href="#扫描根节点" class="headerlink" title="扫描根节点"></a>扫描根节点</h1><p>[Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.3, Diff: 0.1,<br>Sum: 0.8]</p>
<h1 id="更新RS区域所消耗的时间"><a href="#更新RS区域所消耗的时间" class="headerlink" title="更新RS区域所消耗的时间"></a>更新RS区域所消耗的时间</h1><p>[Update RS (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.2, Sum: 5.6]<br>[Processed Buffers: Min: 1, Avg: 1.7, Max: 3, Diff: 2, Sum: 5]<br>[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]<br>[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0,<br>Sum: 0.0]</p>
<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><p>[Object Copy (ms): Min: 1.1, Avg: 1.2, Max: 1.3, Diff: 0.2, Sum:</p>
<p>3.6]</p>
<p>0.2]</p>
<p>3]</p>
<p>[Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum:</p>
<p>[Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum:</p>
<p>[GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0,</p>
<p>Sum: 0.0]<br>[GC Worker Total (ms): Min: 3.4, Avg: 3.4, Max: 3.5, Diff: 0.1,<br>Sum: 10.3]<br>[GC Worker End (ms): Min: 14767.2, Avg: 14767.2, Max: 14767.3,<br>Diff: 0.1]<br>[Code Root Fixup: 0.0 ms] [Code Root Purge: 0.0 ms]<br>[Clear CT: 0.0 ms] #清空CardTable<br>[Other: 0.7 ms]<br>[Choose CSet: 0.0 ms] #选取CSet<br>[Ref Proc: 0.5 ms] #弱引用、软引用的处理耗时[Ref Enq: 0.0 ms] #弱引用、软引用的入队耗时[Redirty Cards: 0.0 ms]<br>[Humongous Register: 0.0 ms] #大对象区域注册耗时[Humongous Reclaim: 0.0 ms] #大对象区域回收耗时</p>
<p>[Free CSet: 0.0 ms]<br>[Eden: 7168.0K(7168.0K)‐&gt;0.0B(13.0M) Survivors: 2048.0K‐&gt;2048.0K Heap: 55.5M(192.0M)‐&gt;48.5M(192.0M)] #年轻代的大小统计<br>[Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<p>3.4.6、对于G1垃圾收集器优化建议</p>
<p>年轻代大小<br>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p>
<p>暂停时间目标不要太过严苛<br>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。<br>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意<br>承受更多的垃圾回收开销，而这会直接影响到吞吐量。</p>
<p>4、可视化GC日志分析工具<br>4.1、GC日志输出参数<br>前面通过-XX:+PrintGCDetails可以对GC日志进行打印，我们就可以在控制台查看，这样 虽然可以查看GC的信息，但是并不直观，可以借助于第三方的GC日志分析工具进行查 看。</p>
<p>在日志打印输出涉及到的参数如下：</p>
<p>‐XX:+PrintGC 输出GC日志<br>‐XX:+PrintGCDetails 输出GC的详细日志<br>‐XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）<br>‐XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013‐05‐ 04T21:53:59.234+0800）<br>‐XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>‐Xloggc:../logs/gc.log 日志文件的输出路径</p>
<p>测试：</p>
<p>‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=100 ‐Xmx256m ‐XX:+PrintGCDetails ‐ XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐XX:+PrintHeapAtGC ‐ Xloggc:F://test//gc.log<br>1<br>运行后就可以在E盘下生成gc.log文件。如下：</p>
<p>Java HotSpot(TM) 64‐Bit Server VM (25.144‐b01) for windows‐amd64 JRE (1.8.0_144‐b01), built on Jul 21 2017 21:57:33 by “java_re” with MS VC++ 10.0 (VS2010)<br>Memory: 4k page, physical 12582392k(1939600k free), swap 17300984k(5567740k free)<br>CommandLine flags: ‐XX:InitialHeapSize=201318272 ‐XX:MaxGCPauseMillis=100<br>‐XX:MaxHeapSize=268435456 ‐XX:+PrintGC ‐XX:+PrintGCDateStamps ‐ XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintHeapAtGC ‐ XX:+UseCompressedClassPointers ‐XX:+UseCompressedOops ‐XX:+UseG1GC ‐XX:‐ UseLargePagesIndividualAllocation<br>{Heap before GC invocations=0 (full 0):<br>garbage‐first heap    total 196608K, used 9216K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)<br>region size 1024K, 9 young (9216K), 0 survivors (0K)<br>Metaspace    used 3491K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 381K, capacity 388K, committed 512K, reserved 1048576K<br>2018‐09‐24T23:06:02.230+0800: 0.379: [GC pause (G1 Evacuation Pause) (young), 0.0031038 secs]<br>[Parallel Time: 2.8 ms, GC Workers: 3]<br>[GC Worker Start (ms): Min: 378.6, Avg: 378.8, Max: 379.0, Diff:<br>0.3]<br>[Ext Root Scanning (ms): Min: 0.0, Avg: 0.4, Max: 0.8, Diff: 0.8,<br>Sum: 1.3]<br>[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]<br>[Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]<br>[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]<br>[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1,<br>Sum: 0.1]<br>[Object Copy (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.1, Sum:</p>
<p>5.6]</p>
<p>0.0]</p>
<p>3]</p>
<p>[Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum:</p>
<p>[Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum:</p>
<p>[GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.6, Diff: 0.6,</p>
<p>Sum: 0.6]</p>
<p>[GC Worker Total (ms): Min: 2.4, Avg: 2.5, Max: 2.7, Diff: 0.3,<br>Sum: 7.6]<br>[GC Worker End (ms): Min: 381.4, Avg: 381.4, Max: 381.4, Diff: 0.0] [Code Root Fixup: 0.0 ms]<br>[Code Root Purge: 0.0 ms] [Clear CT: 0.0 ms] [Other: 0.2 ms]<br>[Choose CSet: 0.0 ms] [Ref Proc: 0.1 ms] [Ref Enq: 0.0 ms]<br>[Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms]<br>[Eden: 9216.0K(9216.0K)‐&gt;0.0B(7168.0K) Survivors: 0.0B‐&gt;2048.0K Heap: 9216.0K(192.0M)‐&gt;1888.0K(192.0M)]<br>Heap after GC invocations=1 (full 0):<br>garbage‐first heap    total 196608K, used 1888K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)<br>region size 1024K, 2 young (2048K), 2 survivors (2048K)<br>Metaspace    used 3491K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 381K, capacity 388K, committed 512K, reserved 1048576K<br>}<br>[Times: user=0.00 sys=0.00, real=0.00 secs]<br>{Heap before GC invocations=1 (full 0):<br>garbage‐first heap    total 196608K, used 9056K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)<br>region size 1024K, 9 young (9216K), 2 survivors (2048K)<br>Metaspace    used 3492K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 381K, capacity 388K, committed 512K, reserved 1048576K<br>2018‐09‐24T23:06:02.310+0800: 0.458: [GC pause (G1 Evacuation Pause) (young), 0.0070126 secs]<br>。。。。。。。。。。。。。。。。。。。</p>
<p>4.2、GC Easy 可视化工具<br>GC Easy是一款在线的可视化工具，易用、功能强大，网站：</p>
<p><a href="http://gceasy.io/上传后，点击“Analyze”按钮，即可查看报告" target="_blank" rel="noopener">http://gceasy.io/上传后，点击“Analyze”按钮，即可查看报告</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/19/架构与优化之JVM优化第01篇JVM基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/" itemprop="url">
                  架构与优化之JVM优化第01篇JVM基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-19 00:03:11" itemprop="dateCreated datePublished" datetime="2019-12-19T00:03:11+08:00">2019-12-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-22 23:50:39" itemprop="dateModified" datetime="2019-12-22T23:50:39+08:00">2019-12-22</time>
              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li><p>了解下我们为什么要学习JVM优化 </p>
</li>
<li><p>掌握jvm的运行参数以及参数的设置 </p>
</li>
<li><p>掌握jvm的内存模型（堆内存） </p>
</li>
<li><p>掌握jamp命令的使用以及通过MAT工具进行分析 </p>
</li>
<li><p>掌握定位分析内存溢出的方法 </p>
</li>
<li><p>掌握jstack命令的使用 </p>
</li>
<li><p>掌握VisualJVM工具的使用 </p>
</li>
</ul>
<h1 id="1、我们为什么要对jvm做优化？"><a href="#1、我们为什么要对jvm做优化？" class="headerlink" title="1、我们为什么要对jvm做优化？"></a>1、我们为什么要对jvm做优化？</h1><p>在本地开发环境中我们很少会遇到需要对jvm进行优化的需求，但是到了生产环境，我们 可能将有下面的需求： </p>
<ul>
<li><p>运行的应用“卡住了”，日志不输出，程序没有反应 </p>
</li>
<li><p>服务器的CPU负载突然升高 在多线程应用下，如何分配线程的数量？</p>
</li>
<li><p>…… </p>
</li>
</ul>
<p>我们将对jvm有更深入的学习，我们不仅要让程序能跑起来，而且是可以 跑的更快！可以分析解决在生产环境中所遇到的各种“棘手”的问题。 </p>
<h1 id="2、jvm的运行参数"><a href="#2、jvm的运行参数" class="headerlink" title="2、jvm的运行参数"></a>2、jvm的运行参数</h1><p>在jvm中有很多的参数可以进行设置，这样可以让jvm在各种环境中都能够高效的运行。 绝大部分的参数保持默认即可。</p>
<h2 id="2-1、三种参数类型"><a href="#2-1、三种参数类型" class="headerlink" title="2.1、三种参数类型"></a>2.1、三种参数类型</h2><p>jvm的参数类型分为三类，分别是：</p>
<blockquote>
<p><strong>标准参数</strong></p>
</blockquote>
<ul>
<li>-help </li>
<li>-version</li>
</ul>
<blockquote>
<p><strong> -X参数 （非标准参数）</strong></p>
</blockquote>
<ul>
<li>-Xint </li>
<li>-Xcomp </li>
</ul>
<blockquote>
<p><strong>-XX参数（使用率较高）</strong> </p>
</blockquote>
<ul>
<li>-XX:newSize </li>
<li>-XX:+UseSerialGC</li>
</ul>
<h2 id="2-2、标准参数"><a href="#2-2、标准参数" class="headerlink" title="2.2、标准参数"></a><strong>2.2</strong>、标准参数</h2><p> jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help检索出所有的标准参数。 </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# java ‐help</span><br><span class="line">用法: java [‐options] class [args...]</span><br><span class="line">(执行类)</span><br><span class="line">或	java [‐options] ‐jar jarfile [args...] (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">‐d32	使用 32 位数据模型 (如果可用)</span><br><span class="line">‐d64	使用 64 位数据模型 (如果可用)</span><br><span class="line">‐server	选择 &quot;server&quot; VM</span><br><span class="line">默认 VM 是 server,</span><br><span class="line">因为您是在服务器类计算机上运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">‐cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">‐classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">用 : 分隔的目录, JAR 档案</span><br><span class="line">和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line"></span><br><span class="line">‐D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置系统属性</span><br><span class="line"></span><br><span class="line">‐verbose:[class|gc|jni]</span><br><span class="line">启用详细输出</span><br><span class="line">‐version	输出产品版本并退出</span><br><span class="line">‐version:&lt;值&gt;</span><br><span class="line">警告: 此功能已过时, 将在未来发行版中删除。</span><br><span class="line">需要指定的版本才能运行</span><br><span class="line">‐showversion	输出产品版本并继续</span><br><span class="line">‐jre‐restrict‐search | ‐no‐jre‐restrict‐search</span><br><span class="line">警告: 此功能已过时, 将在未来发行版中删除。</span><br><span class="line">在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">‐? ‐help	输出此帮助消息</span><br><span class="line">‐X	输出非标准选项的帮助</span><br><span class="line">‐ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">‐enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">按指定的粒度启用断言</span><br><span class="line">‐da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">‐disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">禁用具有指定粒度的断言</span><br><span class="line"></span><br><span class="line">‐esa | ‐enablesystemassertions</span><br><span class="line">启用系统断言</span><br><span class="line">‐dsa | ‐disablesystemassertions</span><br><span class="line">禁用系统断言</span><br><span class="line">‐agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">加载本机代理库 &lt;libname&gt;, 例如 ‐agentlib:hprof</span><br><span class="line">另请参阅 ‐agentlib:jdwp=help 和 ‐agentlib:hprof=help</span><br><span class="line">‐agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">按完整路径名加载本机代理库</span><br><span class="line">‐javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">‐splash:&lt;imagepath&gt;</span><br><span class="line">使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-1、实战"><a href="#2-2-1、实战" class="headerlink" title="2.2.1、实战"></a>2.2.1、实战</h3><blockquote>
<p>实战1：查看jvm版本</p>
</blockquote>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# java ‐version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode)</span><br><span class="line"></span><br><span class="line"># ‐showversion参数是表示，先打印版本信息，再执行后面的命令，在调试时非常有用，后面会使用到。</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>实战2：通过-D设置系统属性参数</p>
</blockquote>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestJVM &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = System.getProperty(&quot;str&quot;);</span><br><span class="line">        if(str == null)&#123;</span><br><span class="line">            System.out.println(&quot;itcast&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>进行编译、测试：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#编译</span><br><span class="line">[root@node01 test]# javac TestJVM.java</span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">[root@node01 test]# java TestJVM </span><br><span class="line">itcast</span><br><span class="line">[root@node01 test]# java ‐Dstr=123 TestJVM</span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-2、-server与-client参数"><a href="#2-2-2、-server与-client参数" class="headerlink" title="2.2.2、-server与-client参数"></a>2.2.2、-server与-client参数</h3><p>可以通过-server或-client设置jvm的运行参数。</p>
<ul>
<li>它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。</li>
<li>Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Serverm模式慢些。</li>
<li>JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的 JVM。</li>
<li>32位操作系统<ul>
<li>如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。</li>
<li>如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server模式，否则使用client模式。</li>
</ul>
</li>
<li>64位操作系统<ul>
<li>只有server类型，不支持client类型。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java ‐client ‐showversion TestJVM</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode)</span><br><span class="line">itcast</span><br><span class="line">[root@node01 test]# java ‐server ‐showversion TestJVM</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode)</span><br><span class="line">itcast</span><br><span class="line">#由于机器是64位系统，所以不支持client模式</span><br></pre></td></tr></table></figure></div>
<h2 id="2-3、-X参数"><a href="#2-3、-X参数" class="headerlink" title="2.3、-X参数"></a>2.3、-X参数</h2><p>jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java - X查看非标准参数。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java ‐X</span><br><span class="line">‐Xmixed	混合模式执行 (默认)</span><br><span class="line">‐Xint	仅解释模式执行</span><br><span class="line">‐Xbootclasspath:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">设置搜索路径以引导类和资源</span><br><span class="line">‐Xbootclasspath/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">附加在引导类路径末尾</span><br><span class="line">‐Xbootclasspath/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">置于引导类路径之前</span><br><span class="line">‐Xdiag	显示附加诊断消息</span><br><span class="line">‐Xnoclassgc	禁用类垃圾收集</span><br><span class="line">‐Xincgc	启用增量垃圾收集</span><br><span class="line">‐Xloggc:&lt;file&gt;	将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">‐Xbatch	禁用后台编译</span><br><span class="line">‐Xms&lt;size&gt;	设置初始 Java 堆大小</span><br><span class="line">‐Xmx&lt;size&gt;	设置最大 Java 堆大小</span><br><span class="line">‐Xss&lt;size&gt;	设置 Java 线程堆栈大小</span><br><span class="line">‐Xprof	输出 cpu 配置文件数据</span><br><span class="line">‐Xfuture	启用最严格的检查, 预期将来的默认值</span><br><span class="line">‐Xrs	减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">‐Xcheck:jni	对 JNI 函数执行其他检查</span><br><span class="line">‐Xshare:off	不尝试使用共享类数据</span><br><span class="line">‐Xshare:auto	在可能的情况下使用共享类数据 (默认)</span><br><span class="line">‐Xshare:on	要求使用共享类数据, 否则将失败。</span><br><span class="line">‐XshowSettings	显示所有设置并继续</span><br><span class="line">‐XshowSettings:all</span><br><span class="line">显示所有设置并继续</span><br><span class="line">‐XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">‐XshowSettings:properties</span><br><span class="line">显示所有属性设置并继续</span><br><span class="line">‐XshowSettings:locale</span><br><span class="line">显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">‐X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure></div>
<p>2.3.1、-Xint、-Xcomp、-Xmixed</p>
<ul>
<li>在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。</li>
<li>-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。<ul>
<li>然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是— xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代码都进行编译的话，对于一些只执行一次的代码就<br>没有意义了。</li>
</ul>
</li>
<li>-Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模式，也是推荐使用的模式。</li>
</ul>
<p>示例：强制设置运行模式</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#强制设置为解释模式</span><br><span class="line">[root@node01 test]# java	‐showversion ‐Xint TestJVM java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, interpreted mode) itcast</span><br><span class="line"></span><br><span class="line">#强制设置为编译模式</span><br><span class="line">[root@node01 test]# java	‐showversion ‐Xcomp TestJVM java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, compiled mode)</span><br><span class="line"></span><br><span class="line">itcast</span><br><span class="line">#注意：编译模式下，第一次执行会比解释模式下执行慢一些，注意观察。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#默认的混合模式</span><br><span class="line">[root@node01 test]# java	‐showversion TestJVM java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode) itcast</span><br></pre></td></tr></table></figure></div>
<h2 id="2-4、-XX参数"><a href="#2-4、-XX参数" class="headerlink" title="2.4、-XX参数"></a>2.4、-XX参数</h2><p>-XX参数也是非标准参数，主要用于jvm的调优和debug操作。<br>-XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型： boolean类型<br>格式：-XX:[±]<br>如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用<br>System.gc()无效<br>非boolean类型格式：-XX:<br>如：-XX:NewRatio=1 表示新生代和老年代的比值<br>用法：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java ‐showversion ‐XX:+DisableExplicitGC TestJVM</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode)</span><br><span class="line"></span><br><span class="line">itcast</span><br></pre></td></tr></table></figure></div>
<h2 id="2-5、-Xms与-Xmx参数"><a href="#2-5、-Xms与-Xmx参数" class="headerlink" title="2.5、-Xms与-Xmx参数"></a>2.5、-Xms与-Xmx参数</h2><p>Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。<br>-Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。<br>-Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。适当的调整jvm的内存大小，可以充分利用服务器资源，让程序跑的更快。示例：[root@node01 test]# java ‐Xms512m ‐Xmx2048m TestJVM itcast</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java ‐Xms512m ‐Xmx2048m TestJVM </span><br><span class="line"></span><br><span class="line">itcast</span><br></pre></td></tr></table></figure></div>
<h2 id="2-6、查看jvm的运行参数"><a href="#2-6、查看jvm的运行参数" class="headerlink" title="2.6、查看jvm的运行参数"></a>2.6、查看jvm的运行参数</h2><p>有些时候我们需要查看jvm的运行参数，这个需求可能会存在2种情况：</p>
<p>第一，运行java命令时打印出运行参数； </p>
<p>第二，查看正在运行的java进程的参数；</p>
<h3 id="2-6-1、运行java命令时打印参数"><a href="#2-6-1、运行java命令时打印参数" class="headerlink" title="2.6.1、运行java命令时打印参数"></a>2.6.1、运行java命令时打印参数</h3><p>运行java命令时打印参数，需要添加-XX:+PrintFlagsFinal参数即可。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java ‐XX:+PrintFlagsFinal ‐version [Global flags]</span><br><span class="line">uintx AdaptiveSizeDecrementScaleFactor	= 4</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizeMajorGCDecayTimeScale	= 10</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePausePolicy	= 0</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePolicyCollectionCostMargin	= 50</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePolicyInitializingSteps	= 20</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePolicyOutputInterval	= 0</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePolicyWeight	= 10</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveSizeThroughPutPolicy	= 0</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx AdaptiveTimeWeight	= 25</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool AdjustConcurrency	= false</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool AggressiveOpts	= false</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx AliasLevel	= 3</span><br><span class="line">&#123;C2 product&#125;</span><br><span class="line">bool AlignVector	= true</span><br><span class="line">&#123;C2 product&#125;</span><br><span class="line">intx AllocateInstancePrefetchLines	= 1</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx AllocatePrefetchDistance	= 256</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx AllocatePrefetchInstr	= 0</span><br><span class="line">&#123;product&#125;</span><br><span class="line"></span><br><span class="line">…………………………略…………………………………………</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool UseXmmI2D	= false</span><br><span class="line">&#123;C1 product&#125;</span><br><span class="line">intx ValueSearchLimit	= 1000</span><br><span class="line">&#123;C2 product&#125;</span><br><span class="line">bool VerifyMergedCPBytecodes	= true</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool VerifySharedSpaces	= false</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx WorkAroundNPTLTimedWaitHang	= 1</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeIncrement	= 20</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeSupplement	= 80</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeSupplementDecay	= 8</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungPLABSize	= 4096</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool ZeroTLAB	= false</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx hashCode	= 5</span><br><span class="line">&#123;product&#125;          java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode)</span><br></pre></td></tr></table></figure></div>
<p>由上述的信息可以看出，参数有boolean类型和数字类型，值的操作符是=或:=，分别代 表默认值和被修改的值。</p>
<p>示例：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">java ‐XX:+PrintFlagsFinal ‐XX:+VerifySharedSpaces ‐version</span><br><span class="line"></span><br><span class="line">intx ValueMapInitialSize	= 11</span><br><span class="line">&#123;C1 product&#125;</span><br><span class="line">intx ValueMapMaxLoopSize	= 8</span><br><span class="line">&#123;C1 product&#125;</span><br><span class="line">intx ValueSearchLimit	= 1000</span><br><span class="line">&#123;C2 product&#125;</span><br><span class="line">bool VerifyMergedCPBytecodes	= true</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool VerifySharedSpaces	:= true</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx WorkAroundNPTLTimedWaitHang	= 1</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeIncrement	= 20</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeSupplement	= 80</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungGenerationSizeSupplementDecay	= 8</span><br><span class="line">&#123;product&#125;</span><br><span class="line">uintx YoungPLABSize	= 4096</span><br><span class="line">&#123;product&#125;</span><br><span class="line">bool ZeroTLAB	= false</span><br><span class="line">&#123;product&#125;</span><br><span class="line">intx hashCode	= 5</span><br><span class="line">&#123;product&#125;          java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141‐b15)</span><br><span class="line">Java HotSpot(TM) 64‐Bit Server VM (build 25.141‐b15, mixed mode) </span><br><span class="line"></span><br><span class="line">#可以看到VerifySharedSpaces这个参数已经被修改了。</span><br></pre></td></tr></table></figure></div>
<h3 id="2-6-2、查看正在运行的jvm参数"><a href="#2-6-2、查看正在运行的jvm参数" class="headerlink" title="2.6.2、查看正在运行的jvm参数"></a>2.6.2、查看正在运行的jvm参数</h3><p>如果想要查看正在运行的jvm就需要借助于jinfo命令查看。<br>首先，启动一个tomcat用于测试，来观察下运行的jvm参数。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/</span><br><span class="line">rz 上传</span><br><span class="line">tar ‐xvf apache‐tomcat‐7.0.57.tar.gz cd apache‐tomcat‐7.0.57</span><br><span class="line">cd bin/</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line">#http://122.51.193.216:8080/ 进行访问</span><br></pre></td></tr></table></figure></div>
<p>访问成功：</p>
<p> <img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219155258725.png" alt="image-20191219155258725"></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#查看所有的参数，用法：jinfo ‐flags &lt;进程id&gt;</span><br><span class="line"></span><br><span class="line">#通过jps 或者	jps ‐l 查看java进程</span><br><span class="line">[root@node01 bin]# jps 6346 Jps</span><br><span class="line">6219 Bootstrap [root@node01 bin]# jps ‐l 6358 sun.tools.jps.Jps</span><br><span class="line">6219 org.apache.catalina.startup.Bootstrap [root@node01 bin]#</span><br><span class="line"></span><br><span class="line">[root@node01 bin]# jinfo ‐flags 6219 Attaching to process ID 6219, please wait... Debugger attached successfully.</span><br><span class="line">Server compiler detected. JVM version is 25.141‐b15</span><br><span class="line">Non‐default VM flags: ‐XX:CICompilerCount=2 ‐XX:InitialHeapSize=31457280</span><br><span class="line">‐XX:MaxHeapSize=488636416 ‐XX:MaxNewSize=162529280 ‐ XX:MinHeapDeltaBytes=524288 ‐XX:NewSize=10485760 ‐XX:OldSize=20971520 ‐ XX:+UseCompressedClassPointers ‐XX:+UseCompressedOops ‐ XX:+UseFastUnorderedTimeStamps ‐XX:+UseParallelGC</span><br><span class="line">Command line:	‐Djava.util.logging.config.file=/tmp/apache‐tomcat‐ 7.0.57/conf/logging.properties ‐ Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager ‐ Djava.endorsed.dirs=/tmp/apache‐tomcat‐7.0.57/endorsed ‐ Dcatalina.base=/tmp/apache‐tomcat‐7.0.57 ‐Dcatalina.home=/tmp/apache‐ tomcat‐7.0.57 ‐Djava.io.tmpdir=/tmp/apache‐tomcat‐7.0.57/temp</span><br><span class="line"></span><br><span class="line">#查看某一参数的值，用法：jinfo ‐flag &lt;参数名&gt; &lt;进程id&gt; [root@node01 bin]# jinfo ‐flag MaxHeapSize 6219</span><br><span class="line">‐XX:MaxHeapSize=488636416</span><br></pre></td></tr></table></figure></div>
<h1 id="3、jvm的内存模型"><a href="#3、jvm的内存模型" class="headerlink" title="3、jvm的内存模型"></a>3、jvm的内存模型</h1><p>jvm的内存模型在1.7和1.8有较大的区别，虽然本套课程是以1.8为例进行讲解，但是我们 也是需要对1.7的内存模型有所了解，所以接下里，我们将先学习1.7再学习1.8的内存模 型。</p>
<h2 id="3-1、jdk1-7的堆内存模型"><a href="#3-1、jdk1-7的堆内存模型" class="headerlink" title="3.1、jdk1.7的堆内存模型"></a>3.1、jdk1.7的堆内存模型</h2><p>  <img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219155224831.png" alt="image-20191219155224831"></p>
<ul>
<li>Young 年轻区（代）<br>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中， Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制 对象用，在Eden区间变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</li>
<li>Tenured 年老区<br>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young 复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</li>
<li>Perm 永久区<br>Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性 加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造 成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以 解决问题。</li>
<li>Virtual区：<ul>
<li>最大内存和初始内存的差值，就是Virtual区。</li>
</ul>
</li>
</ul>
<p>3.2、jdk1.8的堆内存模型</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219155636643.png" alt="image-20191219155636643"></p>
<p>由上图可以看出，jdk1.8的内存模型是由2部分组成，年轻代 + 年老代。</p>
<p>年轻代：Eden + 2*Survivor<br>年老代：OldGen<br>在jdk1.8中变化最大的Perm区，用Metaspace（元数据空间）进行了替换。</p>
<p>需要特别说明的是：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存 空间中，这也是与1.7的永久代最大的区别所在。</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219155940784.png" alt="image-20191219155940784"></p>
<p>其中：CodeCache存放的是一些类和class。CCS代表的是一些压缩指针。</p>
<p>3.3、为什么要废弃1.7中的永久区？<br>官网给出了解释：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is part of the JRockit and Hotspot convergence effort. JRockit</span><br><span class="line">customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</span><br><span class="line"></span><br><span class="line">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，</span><br><span class="line">不需要配置永久代。</span><br></pre></td></tr></table></figure></div>
<p>现实使用中，由于永久代内存经常不够用或发生内存泄露，爆出异常<br>java.lang.OutOfMemoryError: PermGen。<br>基于此，将永久区废弃，而改用元空间，改为了使用本地内存空间。</p>
<p>3.4、通过jstat命令进行查看堆内存使用情况<br>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下： jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]<br>3.4.1、查看class加载统计</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jps</span><br><span class="line">7080 Jps</span><br><span class="line">6219 Bootstrap</span><br><span class="line">[root@node01 ~]# jstat ‐class 6219</span><br><span class="line"></span><br><span class="line">Loaded	Bytes	Unloaded	Bytes	Time</span><br><span class="line">3273	7122.3	0	0.0	3.98</span><br></pre></td></tr></table></figure></div>
<p>说明：</p>
<p>Loaded：加载class的数量<br>Bytes：所占用空间大小<br>Unloaded：未加载数量<br>Bytes：未加载占用空间<br>Time：时间<br><strong>3.4.2、查看编译统计</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstat ‐compiler 6219</span><br><span class="line">Compiled Failed Invalid	Time	FailedType FailedMethod 2376	1	0		8.04	1</span><br><span class="line">org/apache/tomcat/util/IntrospectionUtils setProperty</span><br></pre></td></tr></table></figure></div>
<p>说明：</p>
<p>Compiled：编译数量。<br>Failed：失败数量<br>Invalid：不可用数量<br>Time：时间<br>FailedType：失败类型<br>FailedMethod：失败的方法<br><strong>3.4.3、垃圾回收统计</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstat ‐gc 6219</span><br><span class="line">S0C	S1C	S0U	S1U	EC	EU	OC	OU	MC</span><br><span class="line">MU	CCSC	CCSU	YGC	YGCT	FGC	FGCT	GCT	</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3560.4	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br></pre></td></tr></table></figure></div>
<p> #也可以指定打印的间隔和次数，每1秒中打印一次，共打印5次 </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstat ‐gc 6219 1000 5</span><br><span class="line">S0C	S1C	S0U	S1U	EC		EU		OC		OU	MC        MU		CCSC		CCSU		YGC		YGCT	FGC	FGCT	GCT</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3917.3	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3917.3	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3917.3	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3917.3	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br><span class="line">9216.0 8704.0	0.0	6127.3 62976.0	3917.3	33792.0	20434.9</span><br><span class="line">23808.0 23196.1 2560.0 2361.6	7	1.078	1	0.244	1.323</span><br></pre></td></tr></table></figure></div>
<p>说明：</p>
<p>S0C：第一个Survivor区的大小（KB）<br>S1C：第二个Survivor区的大小（KB）<br>S0U：第一个Survivor区的使用大小（KB）<br>S1U：第二个Survivor区的使用大小（KB） EC：Eden区的大小（KB）<br>EU：Eden区的使用大小（KB）<br>OC：Old 区 大 小 （KB）<br>OU：Old 使 用 大 小 （KB）<br>MC：方法区大小（KB）<br>MU：方法区使用大小（KB）<br>CCSC：压缩类空间大小（KB）<br>CCSU：压缩类空间使用大小（KB）<br>YGC：年轻代垃圾回收次数<br>YGCT：年轻代垃圾回收消耗时间<br>FGC：老年代垃圾回收次数<br>FGCT：老年代垃圾回收消耗时间<br>GCT：垃圾回收消耗总时间</p>
<h1 id="4、jmap的使用以及内存溢出分析"><a href="#4、jmap的使用以及内存溢出分析" class="headerlink" title="4、jmap的使用以及内存溢出分析"></a>4、jmap的使用以及内存溢出分析</h1><p>前面通过jstat可以对jvm堆的内存进行统计分析，而jmap可以获取到更加详细的内容， 如：内存使用情况的汇总、对内存溢出的定位与分析。</p>
<h2 id="4-1、查看内存使用情况"><a href="#4-1、查看内存使用情况" class="headerlink" title="4.1、查看内存使用情况"></a>4.1、查看内存使用情况</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@# jmap ‐heap 6219</span><br><span class="line">Attaching to process ID 6219, please wait... Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.141‐b15</span><br><span class="line"></span><br><span class="line">using thread‐local object allocation. Parallel GC with 2 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration: #堆内存配置信息MinHeapFreeRatio	= 0</span><br><span class="line">MaxHeapFreeRatio	= 100</span><br><span class="line">MaxHeapSize	= 488636416 (466.0MB)</span><br><span class="line">NewSize	= 10485760 (10.0MB)</span><br><span class="line">MaxNewSize	= 162529280 (155.0MB)</span><br><span class="line">OldSize	= 20971520 (20.0MB)</span><br><span class="line">NewRatio	= 2</span><br><span class="line">SurvivorRatio	= 8</span><br><span class="line">MetaspaceSize	= 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize	= 17592186044415 MB</span><br><span class="line">G1HeapRegionSize	= 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage: # 堆内存的使用情况PS Young Generation #年轻代Eden Space:</span><br><span class="line">capacity = 123731968 (118.0MB)</span><br><span class="line">used	= 1384736 (1.320587158203125MB) free	= 122347232 (116.67941284179688MB) 1.1191416594941737% used</span><br><span class="line">From Space:</span><br><span class="line">capacity = 9437184 (9.0MB) used	= 0 (0.0MB)</span><br><span class="line">free	= 9437184 (9.0MB)</span><br><span class="line">0.0% used To Space:</span><br><span class="line">capacity = 9437184 (9.0MB) used	= 0 (0.0MB)</span><br><span class="line">free	= 9437184 (9.0MB)</span><br><span class="line"></span><br><span class="line">0.0% used</span><br><span class="line">PS Old Generation #年老代</span><br><span class="line">capacity = 28311552 (27.0MB)</span><br><span class="line">used = 13698672 (13.064071655273438MB) free = 14612880 (13.935928344726562MB) 48.38545057508681% used</span><br><span class="line">13648 interned Strings occupying 1866368 bytes.</span><br></pre></td></tr></table></figure></div>
<h2 id="4-2、查看内存中对象数量及大小"><a href="#4-2、查看内存中对象数量及大小" class="headerlink" title="4.2、查看内存中对象数量及大小"></a>4.2、查看内存中对象数量及大小</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#查看所有对象，包括活跃以及非活跃的jmap ‐histo &lt;pid&gt; | more</span><br><span class="line"></span><br><span class="line">#查看活跃对象</span><br><span class="line">jmap ‐histo:live &lt;pid&gt; | more</span><br><span class="line">[root@node01 ~]# jmap ‐histo:live 6219 | more num	#instances	#bytes	class name</span><br><span class="line">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ 1:	37437	7914608	[C</span><br><span class="line">2:	34916	837984	java.lang.String</span><br><span class="line">3:	884	654848	[B</span><br><span class="line">4:	17188	550016	java.util.HashMap$Node</span><br><span class="line">5:	3674	424968	java.lang.Class</span><br><span class="line">6:	6322	395512	[Ljava.lang.Object;</span><br><span class="line">7:	3738	328944	java.lang.reflect.Method</span><br><span class="line">8:	1028	208048	[Ljava.util.HashMap$Node;</span><br><span class="line">9:	2247	144264	[I</span><br><span class="line">10:	4305	137760</span><br><span class="line">java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">11:	1270	109080	[Ljava.lang.String;</span><br><span class="line">12:	64	84128</span><br><span class="line">[Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class="line">13:	1714	82272	java.util.HashMap</span><br><span class="line">14:	3285	70072	[Ljava.lang.Class;</span><br><span class="line">15:	2888	69312	java.util.ArrayList</span><br><span class="line">16:	3983	63728	java.lang.Object</span><br><span class="line">17:	1271	61008</span><br><span class="line">org.apache.tomcat.util.digester.CallMethodRule</span><br><span class="line">18:	1518	60720	java.util.LinkedHashMap$Entry</span><br><span class="line">19:	1671	53472</span><br><span class="line">com.sun.org.apache.xerces.internal.xni.QName</span><br><span class="line">20:	88	50880	[Ljava.util.WeakHashMap$Entry;</span><br><span class="line">21:	618	49440	java.lang.reflect.Constructor</span><br><span class="line">22:	1545	49440	java.util.Hashtable$Entry</span><br><span class="line">23:	1027	41080	java.util.TreeMap$Entry</span><br><span class="line">24:	846	40608</span><br><span class="line">org.apache.tomcat.util.modeler.AttributeInfo 25:	142	38032	[S</span><br><span class="line">26:	946	37840	java.lang.ref.SoftReference</span><br><span class="line">27:	226	36816	[[C</span><br><span class="line">。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line"></span><br><span class="line">#对象说明</span><br><span class="line">B	byte</span><br><span class="line">C	char</span><br><span class="line">D	double</span><br><span class="line">F	float</span><br><span class="line">I	int</span><br><span class="line">J	long</span><br><span class="line">Z	boolean</span><br><span class="line">[ 数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure></div>
<h2 id="4-3、将内存使用情况dump到文件中"><a href="#4-3、将内存使用情况dump到文件中" class="headerlink" title="4.3、将内存使用情况dump到文件中"></a>4.3、将内存使用情况dump到文件中</h2><p>有些时候我们需要将jvm当前内存中的情况dump到文件中，然后对它进行分析，jmap也 是支持dump到文件中的。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用法：</span><br><span class="line">jmap ‐dump:format=b,file=dumpFileName &lt;pid&gt;</span><br><span class="line">#示例</span><br><span class="line">jmap ‐dump:format=b,file=/tmp/dump.dat 6219</span><br></pre></td></tr></table></figure></div>
<p> <img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/20190619215656739.png" alt="img"> </p>
<p>可以看到已经在/tmp下生成了dump.dat的文件。</p>
<h2 id="4-4、通过jhat对dump文件进行分析"><a href="#4-4、通过jhat对dump文件进行分析" class="headerlink" title="4.4、通过jhat对dump文件进行分析"></a>4.4、通过jhat对dump文件进行分析</h2><p>在上一小节中，我们将jvm的内存dump到文件中，这个文件是一个二进制的文件，不方 便查看，这时我们可以借助于jhat工具进行查看。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#用法：</span><br><span class="line">jhat ‐port &lt;port&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line">#示例：</span><br><span class="line">[root@node01 tmp]# jhat ‐port 9999 /tmp/dump.dat Reading from /tmp/dump.dat...</span><br><span class="line">Dump file created Mon Sep 10 01:04:21 CST 2018 Snapshot read, resolving...</span><br><span class="line">Resolving 204094 objects...</span><br><span class="line">Chasing references, expect 40 dots........................................</span><br><span class="line">Eliminating duplicate references........................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000 Server is ready.</span><br></pre></td></tr></table></figure></div>
<p>打开浏览器进行访问：<a href="http://192.168.40.133:7000/" target="_blank" rel="noopener">http://192.168.40.133:7000/</a> </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219173358911.png" alt="image-20191219173358911"></p>
<p> 在最后面有OQL查询功能。 </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219173557859.png" alt="image-20191219173557859"></p>
<p>如：查询字符长度大于100的内容。</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219173901648.png" alt="image-20191219173901648"></p>
<h2 id="4-5、通过MAT工具对dump文件进行分析"><a href="#4-5、通过MAT工具对dump文件进行分析" class="headerlink" title="4.5、通过MAT工具对dump文件进行分析"></a>4.5、通过MAT工具对dump文件进行分析</h2><p>4.5.1、MAT工具介绍<br>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止 了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p>
<p> 官网地址：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a> </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219175033119.png" alt="image-20191219175033119"></p>
<p> <strong>4.5.2、下载安装</strong><br>下载地址：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219175208607.png" alt="image-20191219175208607"></p>
<p> 将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压 </p>
<p>​    <img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219175951080.png" alt="image-20191219175951080"></p>
<p> <strong>4.5.3、使用</strong> </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219180326233.png" alt="image-20191219180326233"></p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219181250853.png" alt="image-20191219181250853"></p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219181317573.png" alt="image-20191219181317573"></p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219181348201.png" alt="image-20191219181348201"></p>
<p>查看对象以及它的依赖： </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219181413557.png" alt="image-20191219181413557"></p>
<p> 查看可能存在内存泄露  的分析： </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219181441422.png" alt="image-20191219181441422"></p>
<h1 id="5、实战：内存溢出的定位与分析"><a href="#5、实战：内存溢出的定位与分析" class="headerlink" title="5、实战：内存溢出的定位与分析"></a>5、实战：内存溢出的定位与分析</h1><p>内存溢出在实际的生产环境中经常会遇到，比如，不断的将数据写入到一个集合中，出现了死循环，读取超大的文件等等，都可能会造成内存溢出。<br>如果出现了内存溢出，首先我们需要定位到发生内存溢出的环节，并且进行分析，是正常还是非正常情况，如果是正常的需求，就应该考虑加大内存的设置，如果是非正常需求，那么就要对代码进行修改，修复这个bug。<br>首先，我们得先学会如何定位问题，然后再进行分析。如何定位问题呢，我们需要借助于jmap与MAT工具进行定位分析。<br>接下来，我们模拟内存溢出的场景。</p>
<h2 id="5-1、模拟内存溢出"><a href="#5-1、模拟内存溢出" class="headerlink" title="5.1、模拟内存溢出"></a>5.1、模拟内存溢出</h2><p>编写代码，向List集合中添加100万个字符串，每个字符串由1000个UUID组成。如果程 序能够正常执行，最后打印ok。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class TestJvmOutOfMemory &#123;</span><br><span class="line"></span><br><span class="line">    // 实现，向集合中添加100万个字符串，每个字符串由1000个UUID组成</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            String str = &quot;&quot;;</span><br><span class="line">            for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                str += UUID.randomUUID().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 为了演示效果，我们将设置执行的参数，这里使用的是Idea编辑器。 </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219221555326.png" alt="image-20191219221555326"></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#参数如下：</span><br><span class="line">‐Xms8m ‐Xmx8m ‐XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure></div>
<h2 id="5-2、运行测试"><a href="#5-2、运行测试" class="headerlink" title="5.2、运行测试"></a>5.2、运行测试</h2><p>测试结果如下：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid5348.hprof ...</span><br><span class="line">Heap dump file created [8137186 bytes in 0.032 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuil der.java:124)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:136)</span><br><span class="line">at cn.itcast.jvm.TestJvmOutOfMemory.main(TestJvmOutOfMemory.java:14) Process finished with exit code 1</span><br></pre></td></tr></table></figure></div>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219221823077.png" alt="image-20191219221823077"></p>
<p> 可以看到，当发生内存溢出时，会dump文件到java_pid5348.hprof。 </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219221736582.png" alt="image-20191219221736582"></p>
<h2 id="5-3、导入到MAT工具中进行分析"><a href="#5-3、导入到MAT工具中进行分析" class="headerlink" title="5.3、导入到MAT工具中进行分析"></a>5.3、导入到MAT工具中进行分析</h2><p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219221936015.png" alt="image-20191219221936015"></p>
<p> 可以看到，有91.03%的内存由Object[]数组占有，所以比较可疑。<br>分析：这个可疑是正确的，因为已经有超过90%的内存都被它占有，这是非常有可能出现内存溢出的。 </p>
<p> 查看详情：</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219222053874.png" alt="image-20191219222053874"></p>
<p>可以看到集合中存储了大量的uuid字符串。 </p>
<h1 id="6、jstack的使用"><a href="#6、jstack的使用" class="headerlink" title="6、jstack的使用"></a>6、jstack的使用</h1><p>有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等，我们该如何分析呢？</p>
<p>由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要 看下jvm的内部线程的执行情况，然后再进行分析查找出原因。<br>这个时候，就需要借助于jstack命令了，jstack的作用是将正在运行的jvm的线程情况进 行快照，并且打印出来：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#用法：jstack &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">[root@node01 bin]# jstack 2203</span><br><span class="line">Full thread dump Java HotSpot(TM) 64‐Bit Server VM (25.141‐b15 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #24 daemon prio=9 os_prio=0 tid=0x00007fabb4001000 nid=0x906 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐exec‐5&quot; #23 daemon prio=5 os_prio=0 tid=0x00007fabb057c000 nid=0x8e1 waiting on condition [0x00007fabd05b8000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">‐ parking to wait for	&lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa it(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 2)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1 074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java</span><br><span class="line">:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav a:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread</span><br><span class="line">.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐exec‐4&quot; #22 daemon prio=5 os_prio=0 tid=0x00007fab9c113800</span><br><span class="line">nid=0x8e0 waiting on condition [0x00007fabd06b9000] java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">‐ parking to wait for	&lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa it(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 2)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1 074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java</span><br><span class="line">:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav a:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread</span><br><span class="line">.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐exec‐3&quot; #21 daemon prio=5 os_prio=0 tid=0x0000000001aeb800 nid=0x8df waiting on condition [0x00007fabd09ba000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">‐ parking to wait for	&lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa it(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">at</span><br><span class="line">java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 2)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1 074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java</span><br><span class="line">:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav a:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread</span><br><span class="line">.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐exec‐2&quot; #20 daemon prio=5 os_prio=0 tid=0x0000000001aea000 nid=0x8de waiting on condition [0x00007fabd0abb000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">‐ parking to wait for	&lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa it(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 2)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1 074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java</span><br><span class="line">:1134)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav a:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread</span><br><span class="line">.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐exec‐1&quot; #19 daemon prio=5 os_prio=0 tid=0x0000000001ae8800 nid=0x8dd waiting on condition [0x00007fabd0bbc000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">‐ parking to wait for	&lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa it(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 2)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1 074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java</span><br><span class="line">:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav a:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread</span><br><span class="line">.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;ajp‐bio‐8009‐AsyncTimeout&quot; #17 daemon prio=5 os_prio=0 tid=0x00007fabe8128000 nid=0x8d0 waiting on condition [0x00007fabd0ece000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java: 152)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;ajp‐bio‐8009‐Acceptor‐0&quot; #16 daemon prio=5 os_prio=0 tid=0x00007fabe82d4000 nid=0x8cf runnable [0x00007fabd0fcf000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method) at</span><br><span class="line">java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513) at</span><br><span class="line">org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(Defaul tServerSocketFactory.java:60)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐AsyncTimeout&quot; #15 daemon prio=5 os_prio=0 tid=0x00007fabe82d1800 nid=0x8ce waiting on condition [0x00007fabd10d0000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java: 152)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;http‐bio‐8080‐Acceptor‐0&quot; #14 daemon prio=5 os_prio=0 tid=0x00007fabe82d0000 nid=0x8cd runnable [0x00007fabd11d1000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method) at</span><br><span class="line">java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">at</span><br><span class="line">org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(Defaul tServerSocketFactory.java:60)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&quot; #13 daemon prio=5 os_prio=0 tid=0x00007fabe82ce000 nid=0x8cc waiting on condition [0x00007fabd12d2000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(C ontainerBase.java:1513)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;GC Daemon&quot; #10 daemon prio=2 os_prio=0 tid=0x00007fabe83b4000 nid=0x8b3 in Object.wait() [0x00007fabd1c2f000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor) at java.lang.Object.wait(Native Method)</span><br><span class="line">‐waiting on &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock) at sun.misc.GC$Daemon.run(GC.java:117)</span><br><span class="line">‐locked &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #7 daemon prio=9 os_prio=0 tid=0x00007fabe80c3800 nid=0x8a5 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os_prio=0 tid=0x00007fabe80b6800 nid=0x8a4 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=0 tid=0x00007fabe80b3800 nid=0x8a3 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=0 tid=0x00007fabe80b2000 nid=0x8a2 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007fabe807f000 nid=0x8a1</span><br><span class="line">in Object.wait() [0x00007fabd2a67000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method)</span><br><span class="line">‐ waiting on &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">‐ locked &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007fabe807a800 nid=0x8a0 in Object.wait() [0x00007fabd2b68000]</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method)</span><br><span class="line">‐waiting on &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">‐locked &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007fabe8009000 nid=0x89c runnable [0x00007fabed210000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method) at</span><br><span class="line">java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513) at</span><br><span class="line">org.apache.catalina.core.StandardServer.await(StandardServer.java:453) at org.apache.catalina.startup.Catalina.await(Catalina.java:777) at org.apache.catalina.startup.Catalina.start(Catalina.java:723) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java</span><br><span class="line">:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorI mpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line"></span><br><span class="line">at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321)</span><br><span class="line">at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455)</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; os_prio=0 tid=0x00007fabe8073000 nid=0x89f runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007fabe801e000</span><br><span class="line">nid=0x89d runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007fabe8020000</span><br><span class="line">nid=0x89e runnable</span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007fabe80d6800 nid=0x8a6</span><br><span class="line">waiting on condition</span><br><span class="line">JNI global references: 43</span><br></pre></td></tr></table></figure></div>
<h2 id="6-1、线程的状态"><a href="#6-1、线程的状态" class="headerlink" title="6.1、线程的状态"></a>6.1、线程的状态</h2><p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219222439231.png" alt="image-20191219222439231"></p>
<p>在Java中线程的状态一共被分成6种：</p>
<ul>
<li>初始态（NEW）<br>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</li>
<li><p>运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。</p>
<ul>
<li>就绪态<ul>
<li>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</li>
<li>所有就绪态的线程存放在就绪队列中。</li>
</ul>
</li>
<li>运行态<ul>
<li>获得CPU执行权，正在执行的线程。</li>
<li>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条<br>运行态的线程。</li>
</ul>
</li>
</ul>
</li>
<li><p>阻塞态（BLOCKED）</p>
<ul>
<li>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</li>
<li>而在Java中，阻塞态专指请求锁失败时进入的状态。</li>
<li>由一个阻塞队列存放所有阻塞态的线程。</li>
<li>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</li>
</ul>
</li>
<li><p>等待态（WAITING）</p>
<ul>
<li>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。 </li>
<li>也有一个等待队列存放所有等待态的线程。</li>
<li>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</li>
<li>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</li>
</ul>
</li>
<li><p>超时等待态（TIMED_WAITING）</p>
<ul>
<li>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；</li>
<li>它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；</li>
<li>进入该状态后释放CPU执行权 和 占有的资源。</li>
<li>与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</li>
</ul>
</li>
<li><p>终止态（TERMINATED）</p>
<pre><code>     线程执行结束后的状态。
</code></pre></li>
</ul>
<h2 id="6-2、实战：死锁问题"><a href="#6-2、实战：死锁问题" class="headerlink" title="6.2、实战：死锁问题"></a>6.2、实战：死锁问题</h2><p>如果在生产环境发生了死锁，我们将看到的是部署的程序没有任何反应了，这个时候我 们可以借助jstack进行分析，下面我们实战下查找死锁的原因。</p>
<h3 id="6-2-1、构造死锁"><a href="#6-2-1、构造死锁" class="headerlink" title="6.2.1、构造死锁"></a>6.2.1、构造死锁</h3><p>编写代码，启动2个线程，Thread1拿到了obj1锁，准备去拿obj2锁时，obj2已经被Thread2锁定，所以发送了死锁。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm;</span><br><span class="line"></span><br><span class="line">public class TestDeadLock &#123;</span><br><span class="line"></span><br><span class="line">    private static Object obj1 = new Object();</span><br><span class="line"></span><br><span class="line">    private static Object obj2 = new Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Thread1()).start();</span><br><span class="line">        new Thread(new Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Thread1 implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (obj1)&#123;</span><br><span class="line">                System.out.println(&quot;Thread1 拿到了 obj1 的锁！&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 停顿2秒的意义在于，让Thread2线程拿到obj2的锁</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (obj2)&#123;</span><br><span class="line">                    System.out.println(&quot;Thread1 拿到了 obj2 的锁！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Thread2 implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (obj2)&#123;</span><br><span class="line">                System.out.println(&quot;Thread2 拿到了 obj2 的锁！&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 停顿2秒的意义在于，让Thread1线程拿到obj1的锁</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (obj1)&#123;</span><br><span class="line">                    System.out.println(&quot;Thread2 拿到了 obj1 的锁！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> <strong>6.2.2、在linux上运行</strong> </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# javac TestDeadLock.java</span><br><span class="line">[root@node01 test]# ll</span><br><span class="line">总用量 28</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	184 9月	11	10:39	TestDeadLock$1.class</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	843 9月	11	10:39	TestDeadLock.class</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	1567 9月	11	10:39	TestDeadLock.java</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	1078 9月	11	10:39	TestDeadLock$Thread1.class</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	1078 9月	11	10:39	TestDeadLock$Thread2.class</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	573 9月	9	10:21	TestJVM.class</span><br><span class="line">‐rw‐r‐‐r‐‐.	1	root	root	261 9月	9	10:21	TestJVM.java</span><br><span class="line"></span><br><span class="line"> [root@node01 test]# java TestDeadLock</span><br><span class="line">Thread1 拿到了 obj1 的锁！</span><br><span class="line">Thread2 拿到了 obj2 的锁！</span><br><span class="line">#这里发生了死锁，程序一直将等待下去</span><br></pre></td></tr></table></figure></div>
<p><strong>6.2.3、使用jstack进行分析</strong> </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstack 3256</span><br><span class="line">Full thread dump Java HotSpot(TM) 64‐Bit Server VM (25.141‐b15 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #11 daemon prio=9 os_prio=0 tid=0x00007f5bfc001000 nid=0xcff waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #10 prio=5 os_prio=0 tid=0x00007f5c2c008800 nid=0xcb9 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Thread‐1&quot; #9 prio=5 os_prio=0 tid=0x00007f5c2c0e9000 nid=0xcc5 waiting for monitor entry [0x00007f5c1c7f6000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor) at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Thread‐0&quot; #8 prio=5 os_prio=0 tid=0x00007f5c2c0e7000 nid=0xcc4 waiting for monitor entry [0x00007f5c1c8f7000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor) at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #7 daemon prio=9 os_prio=0 tid=0x00007f5c2c0d3000 nid=0xcc2 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b6000 nid=0xcc1 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b3000 nid=0xcc0 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b1800 nid=0xcbf runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f5c2c07e800 nid=0xcbe in Object.wait() [0x00007f5c1cdfc000]</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method)</span><br><span class="line">‐ waiting on &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">‐ locked &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f5c2c07a000 nid=0xcbd in Object.wait() [0x00007f5c1cefd000]</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method)</span><br><span class="line">‐waiting on &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">‐locked &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153) &quot;VM Thread&quot; os_prio=0 tid=0x00007f5c2c072800 nid=0xcbc runnable</span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f5c2c01d800 nid=0xcba runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f5c2c01f800 nid=0xcbb runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f5c2c0d6800 nid=0xcc3 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java‐level deadlock:</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">&quot;Thread‐1&quot;:</span><br><span class="line">waiting to lock monitor 0x00007f5c080062c8 (object 0x00000000f655dc40, a java.lang.Object),</span><br><span class="line">which is held by &quot;Thread‐0&quot; &quot;Thread‐0&quot;:</span><br><span class="line">waiting to lock monitor 0x00007f5c08004e28 (object 0x00000000f655dc50, a java.lang.Object),</span><br><span class="line">which is held by &quot;Thread‐1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread‐1&quot;:</span><br><span class="line">at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread‐0&quot;:</span><br><span class="line">at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure></div>
<p> 在输出的信息中，已经看到，发现了1个死锁，关键看这个： </p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread‐1&quot;:</span><br><span class="line">at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread‐0&quot;:</span><br><span class="line">at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">‐waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">‐locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></div>
<p>可以清晰的看到：</p>
<ul>
<li>Thread2获取了 <0x00000000f655dc50> 的锁，等待获取 <0x00000000f655dc40><br>这个锁</0x00000000f655dc40></0x00000000f655dc50></li>
<li>Thread1获取了 <0x00000000f655dc40> 的锁，等待获取 <0x00000000f655dc50><br>这个锁</0x00000000f655dc50></0x00000000f655dc40></li>
<li>由此可见，发生了死锁</li>
</ul>
<h1 id="7、VisualVM工具的使用"><a href="#7、VisualVM工具的使用" class="headerlink" title="7、VisualVM工具的使用"></a>7、VisualVM工具的使用</h1><p>VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。</p>
<p>VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。</p>
<ul>
<li>内存信息线程信息</li>
<li>Dump堆（本地进程）</li>
<li>Dump线程（本地进程）</li>
<li>打开堆Dump。堆Dump可以用jmap来生成。打开线程Dump</li>
<li>生成应用快照（包含内存信息、线程信息等等）</li>
<li>性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内存，检查哪些类占用内存多）</li>
<li>……</li>
</ul>
<p>7.1、启动<br>在jdk的安装目录的bin目录下，找到jvisualvm.exe，双击打开即可。</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219223821746.png" alt="image-20191219223821746"></p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219224901088.png" alt="image-20191219224901088"></p>
<h2 id="7-2、查看本地进程"><a href="#7-2、查看本地进程" class="headerlink" title="7.2、查看本地进程"></a>7.2、查看本地进程</h2><p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219225126244.png" alt="image-20191219225126244"></p>
<h2 id="7-3、查看CPU、内存、类、线程运行信息"><a href="#7-3、查看CPU、内存、类、线程运行信息" class="headerlink" title="7.3、查看CPU、内存、类、线程运行信息"></a>7.3、查看CPU、内存、类、线程运行信息</h2><p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219225226502.png" alt="image-20191219225226502"></p>
<h2 id="7-4、查看线程详情"><a href="#7-4、查看线程详情" class="headerlink" title="7.4、查看线程详情"></a>7.4、查看线程详情</h2><p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219225513677.png" alt="image-20191219225513677"></p>
<p> 也可以点击右上角Dump按钮，将线程的信息导出，其实就是执行的jstack命令。 </p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219225624456.png" alt="image-20191219225624456"></p>
<p>发现，显示的内容是一样的。</p>
<h2 id="7-5、抽样器"><a href="#7-5、抽样器" class="headerlink" title="7.5、抽样器"></a>7.5、抽样器</h2><p>抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219225744090.png" alt="image-20191219225744090"></p>
<h2 id="7-6、监控远程的jvm"><a href="#7-6、监控远程的jvm" class="headerlink" title="7.6、监控远程的jvm"></a>7.6、监控远程的jvm</h2><p>VisualJVM不仅是可以监控本地jvm进程，还可以监控远程的jvm进程，需要借助于JMX技术实现。</p>
<h3 id="7-6-1、什么是JMX？"><a href="#7-6-1、什么是JMX？" class="headerlink" title="7.6.1、什么是JMX？"></a>7.6.1、什么是JMX？</h3><p>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</p>
<h3 id="7-6-2、监控远程的tomcat"><a href="#7-6-2、监控远程的tomcat" class="headerlink" title="7.6.2、监控远程的tomcat"></a>7.6.2、监控远程的tomcat</h3><p>想要监控远程的tomcat，就需要在远程的tomcat进行对JMX配置，方法如下：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在tomcat的bin目录下，修改catalina.sh，添加如下的参数</span><br><span class="line">JAVA_OPTS=&quot;‐Dcom.sun.management.jmxremote ‐</span><br><span class="line">Dcom.sun.management.jmxremote.port=9999 ‐ Dcom.sun.management.jmxremote.authenticate=false ‐ Dcom.sun.management.jmxremote.ssl=false&quot;</span><br><span class="line">#这几个参数的意思是：</span><br><span class="line">#‐Dcom.sun.management.jmxremote ：允许使用JMX远程管理#‐Dcom.sun.management.jmxremote.port=9999 ：JMX远程连接端口#‐Dcom.sun.management.jmxremote.authenticate=false ：不进行身份认证，任何用户都可以连接</span><br><span class="line">#‐Dcom.sun.management.jmxremote.ssl=false ：不使用ssl</span><br></pre></td></tr></table></figure></div>
<p> 保存退出，重启tomcat。</p>
<h3 id="7-6-3、使用VisualJVM连接远程tomcat"><a href="#7-6-3、使用VisualJVM连接远程tomcat" class="headerlink" title="7.6.3、使用VisualJVM连接远程tomcat"></a><strong>7.6.3、使用VisualJVM连接远程tomcat</strong></h3><p>添加远程主机：</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219230428372.png" alt="image-20191219230428372"></p>
<p> 在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的 jvm:</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219230618659.png" alt="image-20191219230618659"></p>
<p>图片中的9999 是前面在远程tomcat中JMX配置的远程连接端口 。</p>
<p><img src="/2019/12/19/架构与优化之JVM优化第01篇JVM基础/image-20191219230825758.png" alt="image-20191219230825758"></p>
<p>连接成功。使用方法和前面就一样了，就可以和监控本地jvm进程一样，监控远程的 tomcat进程。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/18/消息中间件之RabbitMQ及数据同步/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/消息中间件之RabbitMQ及数据同步/" itemprop="url">
                  消息中间件之rabbitmq及数据同步
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-18 10:16:00 / 修改时间：14:25:24" itemprop="dateCreated datePublished" datetime="2019-12-18T10:16:00+08:00">2019-12-18</time>
            

            
              

              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/消息中间件/" itemprop="url" rel="index"><span itemprop="name">消息中间件</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/18/消息中间件之RabbitMQ及数据同步/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/18/消息中间件之RabbitMQ及数据同步/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>了解常见的MQ产品</li>
<li>了解RabbitMQ的5种消息模型</li>
<li>会使用Spring AMQP</li>
<li>利用MQ实现搜索和静态页的数据同步</li>
</ul>
<h1 id="1-RabbitMQ"><a href="#1-RabbitMQ" class="headerlink" title="1.RabbitMQ"></a>1.RabbitMQ</h1><h2 id="1-1-搜索与商品服务的问题"><a href="#1-1-搜索与商品服务的问题" class="headerlink" title="1.1.搜索与商品服务的问题"></a>1.1.搜索与商品服务的问题</h2><p>目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？</p>
<ul>
<li>商品的原始数据保存在数据库中，增删改查都在数据库中完成。</li>
<li>搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。</li>
<li>商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。</li>
</ul>
<p>如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？</p>
<p>这里有两种解决方案：</p>
<ul>
<li>方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面</li>
<li>方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口</li>
</ul>
<p>以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的<code>独立</code>原则。</p>
<p>所以，我们会通过另外一种方式来解决这个问题：消息队列</p>
<h2 id="1-2-消息队列（MQ）"><a href="#1-2-消息队列（MQ）" class="headerlink" title="1.2.消息队列（MQ）"></a>1.2.消息队列（MQ）</h2><h3 id="1-2-1-什么是消息队列"><a href="#1-2-1-什么是消息队列" class="headerlink" title="1.2.1.什么是消息队列"></a>1.2.1.什么是消息队列</h3><p>消息队列，即MQ，Message Queue。</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527063872737.png" alt="1527063872737"></p>
<p>消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<p>结合前面所说的问题：</p>
<ul>
<li>商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。</li>
<li>搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。</li>
</ul>
<p>如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。</p>
<h3 id="1-2-2-AMQP和JMS"><a href="#1-2-2-AMQP和JMS" class="headerlink" title="1.2.2.AMQP和JMS"></a>1.2.2.AMQP和JMS</h3><p>MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527064480681.png" alt="1527064480681"></p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527064487042.png" alt="1527064487042"></p>
<p>两者间的区别和联系：</p>
<ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</li>
</ul>
<h3 id="1-2-3-常见MQ产品"><a href="#1-2-3-常见MQ产品" class="headerlink" title="1.2.3.常见MQ产品"></a>1.2.3.常见MQ产品</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527064606029.png" alt="1527064606029"></p>
<ul>
<li>ActiveMQ：基于JMS</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li>
<li>Kafka：分布式消息系统，高吞吐量</li>
</ul>
<h3 id="1-2-4-RabbitMQ"><a href="#1-2-4-RabbitMQ" class="headerlink" title="1.2.4.RabbitMQ"></a>1.2.4.RabbitMQ</h3><p>RabbitMQ是基于AMQP的一款消息管理系统</p>
<p>官网： <a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<p>官方教程：<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532758972119.png" alt="1532758972119"></p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527064762982.png" alt="1527064762982"></p>
<h2 id="1-3-下载和安装"><a href="#1-3-下载和安装" class="headerlink" title="1.3.下载和安装"></a>1.3.下载和安装</h2><h3 id="1-3-1-下载"><a href="#1-3-1-下载" class="headerlink" title="1.3.1.下载"></a>1.3.1.下载</h3><p>官网下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532759070767.png" alt="1532759070767"></p>
<p>目前最新版本是：3.7.5</p>
<p>我们的课程中使用的是：3.4.1版本</p>
<p>课前资料提供了安装包：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532761948333.png" alt="1532761948333"></p>
<h3 id="1-3-2-安装"><a href="#1-3-2-安装" class="headerlink" title="1.3.2.安装"></a>1.3.2.安装</h3><p>详见课前资料中的：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532761916357.png" alt="1532761916357"></p>
<h1 id="2-五种消息模型"><a href="#2-五种消息模型" class="headerlink" title="2.五种消息模型"></a>2.五种消息模型</h1><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。</p>
<p>但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527068544487.png" alt="1527068544487"></p>
<p>我们通过一个demo工程来了解下RabbitMQ的工作方式：</p>
<p>导入工程：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532762038694.png" alt="1532762038694"></p>
<p>导入后：</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532762308507.png" alt="1532762308507"></p>
<p>依赖：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-rabbitmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立与RabbitMQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"192.168.56.101"</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/leyou"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"leyou"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"leyou"</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-1-基本消息模型"><a href="#2-1-基本消息模型" class="headerlink" title="2.1.基本消息模型"></a>2.1.基本消息模型</h2><p>官方介绍：</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532762961149.png" alt="1532762961149"></p>
<p>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。</p>
<p>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532762975546.png" alt="1532762975546"></p>
<p>P（producer/ publisher）：生产者，一个发送消息的用户应用程序。</p>
<p>C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序</p>
<p>队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
<p>总之：</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。</p>
<p>我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。</p>
<p>我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p>
<h3 id="2-1-1-生产者发送消息"><a href="#2-1-1-生产者发送消息" class="headerlink" title="2.1.1.生产者发送消息"></a>2.1.1.生产者发送消息</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道，这是完成大部分API的地方。</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span></span><br><span class="line">        <span class="comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>控制台：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532763328424.png" alt="1532763328424"></p>
<h3 id="2-1-2-管理工具中查看消息"><a href="#2-1-2-管理工具中查看消息" class="headerlink" title="2.1.2.管理工具中查看消息"></a>2.1.2.管理工具中查看消息</h3><p>进入队列页面，可以看到新建了一个队列：simple_queue</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532763817830.png" alt="1532763817830"></p>
<p>点击队列名称，进入详情页，可以查看消息：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532763489858.png" alt="1532763489858"></p>
<p>在控制台查看消息并不会将消息消费，所以消息还在。</p>
<h3 id="2-1-3-消费者获取消息"><a href="#2-1-3-消费者获取消息" class="headerlink" title="2.1.3.消费者获取消息"></a>2.1.3.消费者获取消息</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [x] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>控制台：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532763733443.png" alt="1532763733443"></p>
<p>这个时候，队列中的消息就没了：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532763773208.png" alt="1532763773208"></p>
<p>我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p>
<h3 id="2-1-4-消息确认机制（ACK）"><a href="#2-1-4-消息确认机制（ACK）" class="headerlink" title="2.1.4.消息确认机制（ACK）"></a>2.1.4.消息确认机制（ACK）</h3><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。</p>
<p>那么问题来了：RabbitMQ怎么知道消息被接收了呢？</p>
<p>如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！</p>
<p>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p>
<ul>
<li>自动ACK：消息一旦被接收，消费者自动发送ACK</li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li>
</ul>
<p>大家觉得哪种更好呢？</p>
<p>这需要看消息的重要性：</p>
<ul>
<li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便</li>
<li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li>
</ul>
<p>我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [x] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                <span class="comment">// 手动进行ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意到最后一行代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br></pre></td></tr></table></figure></div>
<p>如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764253019.png" alt="1532764253019"></p>
<h4 id="2-1-4-1-自动ACK存在的问题"><a href="#2-1-4-1-自动ACK存在的问题" class="headerlink" title="2.1.4.1.自动ACK存在的问题"></a>2.1.4.1.自动ACK存在的问题</h4><p>修改消费者，添加异常，如下：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764600849.png" alt="1532764600849"></p>
<p>生产者不做任何修改，直接运行，消息发送成功：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764694290.png" alt="1532764694290"></p>
<p>运行消费者，程序抛出异常。但是消息依然被消费：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764717995.png" alt="1532764717995"></p>
<p>管理界面：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764734232.png" alt="1532764734232"></p>
<h4 id="2-1-4-2-演示手动ACK"><a href="#2-1-4-2-演示手动ACK" class="headerlink" title="2.1.4.2.演示手动ACK"></a>2.1.4.2.演示手动ACK</h4><p>修改消费者，把自动改成手动（去掉之前制造的异常）</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764831241.png" alt="1532764831241"></p>
<p>生产者不变，再次运行：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764895239.png" alt="1532764895239"></p>
<p>运行消费者</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532764957092.png" alt="1532764957092"></p>
<p>但是，查看管理界面，发现：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765013834.png" alt="1532765013834"></p>
<p>停掉消费者的程序，发现：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765038088.png" alt="1532765038088"></p>
<p>这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。</p>
<p>当我们关掉这个消费者，消息的状态再次称为Ready</p>
<p>修改代码手动ACK：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765123282.png" alt="1532765123282"></p>
<p>执行：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765151039.png" alt="1532765151039"></p>
<p>消息消费成功！</p>
<h2 id="2-2-work消息模型"><a href="#2-2-work消息模型" class="headerlink" title="2.2.work消息模型"></a>2.2.work消息模型</h2><p>工作队列或者竞争消费者模式</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765197277.png" alt="1532765197277"></p>
<p>在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。</p>
<p>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是<strong>一个消息只能被一个消费者获取</strong>。</p>
<p>这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<pre><code>P：生产者：任务的发布者

C1：消费者，领取任务并且完成任务，假设完成速度较快

C2：消费者2：领取任务并完成任务，假设完成速度慢
</code></pre><p>面试题：避免消息堆积？</p>
<p>1）采用workqueue，多个消费者监听同一队列。</p>
<p>2）接收到消息以后，而是通过线程池，异步消费。</p>
<h3 id="2-2-1-生产者"><a href="#2-2-1-生产者" class="headerlink" title="2.2.1.生产者"></a>2.2.1.生产者</h3><p>生产者与案例1中的几乎一样：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">"task .. "</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>不过这里我们是循环发送50条消息。</p>
<h3 id="2-2-2-消费者1"><a href="#2-2-2-消费者1" class="headerlink" title="2.2.2.消费者1"></a>2.2.2.消费者1</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527085386747.png" alt="1527085386747"></p>
<h3 id="2-2-3-消费者2"><a href="#2-2-3-消费者2" class="headerlink" title="2.2.3.消费者2"></a>2.2.3.消费者2</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527085448377.png" alt="1527085448377"></p>
<p>与消费者1基本类似，就是没有设置消费耗时时间。</p>
<p>这里是模拟有些消费者快，有些比较慢。</p>
<p>接下来，两个消费者一同启动，然后发送50条消息：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527085826462.png" alt="1527085826462"></p>
<p>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。</p>
<h3 id="2-2-4-能者多劳"><a href="#2-2-4-能者多劳" class="headerlink" title="2.2.4.能者多劳"></a>2.2.4.能者多劳</h3><p>刚才的实现有问题吗？</p>
<ul>
<li>消费者1比消费者2的效率要低，一次任务的耗时较长</li>
<li>然而两人最终消费的消息数量是一样的</li>
<li>消费者2大量时间处于空闲状态，消费者1一直忙碌</li>
</ul>
<p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p>
<p>怎么实现呢？</p>
<p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532765689904.png" alt="1532765689904"></p>
<p>再次测试：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527086159534.png" alt="1527086159534"></p>
<h2 id="2-3-订阅模型分类"><a href="#2-3-订阅模型分类" class="headerlink" title="2.3.订阅模型分类"></a>2.3.订阅模型分类</h2><p>在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 </p>
<p>订阅模型示意图：</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527086284940.png" alt="1527086284940"></p>
<p>解读：</p>
<p>1、1个生产者，多个消费者</p>
<p>2、每一个消费者都有自己的一个队列</p>
<p>3、生产者没有将消息直接发送到队列，而是发送到了交换机</p>
<p>4、每个队列都要绑定到交换机</p>
<p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的</p>
<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange类型有以下几种：</p>
<pre><code>Fanout：广播，将消息交给所有绑定到交换机的队列

Direct：定向，把消息交给符合指定routing key 的队列 

Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
</code></pre><p>我们这里先学习</p>
<pre><code>Fanout：即广播模式
</code></pre><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="2-4-订阅模型-Fanout"><a href="#2-4-订阅模型-Fanout" class="headerlink" title="2.4.订阅模型-Fanout"></a>2.4.订阅模型-Fanout</h2><p>Fanout，也称为广播。</p>
<p>流程图：</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527086564505.png" alt="1527086564505"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个消费者</li>
<li>2）  每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>3）  每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li>4）  <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li>5）  交换机把消息发送给绑定过的所有队列</li>
<li>6）  队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li>
</ul>
<h3 id="2-4-1-生产者"><a href="#2-4-1-生产者" class="headerlink" title="2.4.1.生产者"></a>2.4.1.生产者</h3><p>两个变化：</p>
<ul>
<li>1）  声明Exchange，不再声明Queue</li>
<li>2）  发送消息到Exchange，不再发送到Queue</li>
</ul>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello everyone"</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [生产者] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-4-2-消费者1"><a href="#2-4-2-消费者1" class="headerlink" title="2.4.2.消费者1"></a>2.4.2.消费者1</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>要注意代码中：<strong>队列需要和交换机绑定</strong></p>
<h3 id="2-4-3-消费者2"><a href="#2-4-3-消费者2" class="headerlink" title="2.4.3.消费者2"></a>2.4.3.消费者2</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-4-4-测试"><a href="#2-4-4-测试" class="headerlink" title="2.4.4.测试"></a>2.4.4.测试</h3><p>我们运行两个消费者，然后发送1条消息：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766264386.png" alt="1532766264386"></p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766291204.png" alt="1532766291204"></p>
<h2 id="2-5-订阅模型-Direct"><a href="#2-5-订阅模型-Direct" class="headerlink" title="2.5.订阅模型-Direct"></a>2.5.订阅模型-Direct</h2><p>有选择性的接收消息</p>
<p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p>
<p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p>
<p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p>
<p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766437787.png" alt="1532766437787"></p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<h3 id="2-5-1-生产者"><a href="#2-5-1-生产者" class="headerlink" title="2.5.1.生产者"></a>2.5.1.生产者</h3><p>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"商品新增了， id = 1001"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"insert"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [商品服务：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-5-2-消费者1"><a href="#2-5-2-消费者1" class="headerlink" title="2.5.2.消费者1"></a>2.5.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-5-3-消费者2"><a href="#2-5-3-消费者2" class="headerlink" title="2.5.3.消费者2"></a>2.5.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"insert"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-5-4-测试"><a href="#2-5-4-测试" class="headerlink" title="2.5.4.测试"></a>2.5.4.测试</h3><p>我们分别发送增、删、改的RoutingKey，发现结果：</p>
<p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527088296131.png" alt="1527088296131"></p>
<h2 id="2-6-订阅模型-Topic"><a href="#2-6-订阅模型-Topic" class="headerlink" title="2.6.订阅模型-Topic"></a>2.6.订阅模型-Topic</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<pre><code>`#`：匹配一个或多个词

`*`：匹配不多不少恰好1个词
</code></pre><p>举例：</p>
<pre><code>`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`

`audit.*`：只能匹配`audit.irs`
</code></pre><p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766712166.png" alt="1532766712166"></p>
<p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p>
<p>我们创建了三个绑定：Q1绑定了绑定键“<em> .orange.</em>”，Q2绑定了“<em>.</em>.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<p>练习，生产者发送如下消息，会进入那个队列：</p>
<p>quick.orange.rabbit     Q1 Q2</p>
<p>lazy.orange.elephant     </p>
<p>quick.orange.fox      </p>
<p>lazy.pink.rabbit      </p>
<p>quick.brown.fox     </p>
<p>quick.orange.male.rabbit </p>
<p>orange </p>
<h3 id="2-6-1-生产者"><a href="#2-6-1-生产者" class="headerlink" title="2.6.1.生产者"></a>2.6.1.生产者</h3><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"新增商品 : id = 1001"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"item.insert"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [商品服务：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-6-2-消费者1"><a href="#2-6-2-消费者1" class="headerlink" title="2.6.2.消费者1"></a>2.6.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-6-3-消费者2"><a href="#2-6-3-消费者2" class="headerlink" title="2.6.3.消费者2"></a>2.6.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-7-持久化"><a href="#2-7-持久化" class="headerlink" title="2.7.持久化"></a>2.7.持久化</h2><p>如何避免消息丢失？</p>
<p>1）  消费者的ACK机制。可以防止消费者丢失消息。</p>
<p>2）  但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p>
<p>是可以将消息进行持久化呢？</p>
<p>要将消息持久化，前提是：队列、Exchange都持久化</p>
<h3 id="2-7-1-交换机持久化"><a href="#2-7-1-交换机持久化" class="headerlink" title="2.7.1.交换机持久化"></a>2.7.1.交换机持久化</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766951432.png" alt="1532766951432"></p>
<h3 id="2-7-2-队列持久化"><a href="#2-7-2-队列持久化" class="headerlink" title="2.7.2.队列持久化"></a>2.7.2.队列持久化</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532766981230.png" alt="1532766981230"></p>
<h3 id="2-7-3-消息持久化"><a href="#2-7-3-消息持久化" class="headerlink" title="2.7.3.消息持久化"></a>2.7.3.消息持久化</h3><p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532767057491.png" alt="1532767057491"></p>
<h1 id="3-Spring-AMQP"><a href="#3-Spring-AMQP" class="headerlink" title="3.Spring AMQP"></a>3.Spring AMQP</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>Sprin有很多不同的项目，其中就有对AMQP的支持：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532767136007.png" alt="1532767136007"></p>
<p>Spring AMQP的页面：<a href="http://spring.io/projects/spring-amqp" target="_blank" rel="noopener">http://spring.io/projects/spring-amqp</a></p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532767171063.png" alt="1532767171063"></p>
<p>注意这里一段描述：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532767227821.png" alt="1532767227821">                                             </p>
<pre><code>     Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。
</code></pre><h2 id="3-2-依赖和配置"><a href="#3-2-依赖和配置" class="headerlink" title="3.2.依赖和配置"></a>3.2.依赖和配置</h2><p>添加AMQP的启动器：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>在<code>application.yml</code>中添加RabbitMQ地址：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/leyou</span></span><br></pre></td></tr></table></figure></div>
<h2 id="3-3-监听者"><a href="#3-3-监听者" class="headerlink" title="3.3.监听者"></a>3.3.监听者</h2><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"spring.test.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"spring.test.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC</span><br><span class="line">            ),</span><br><span class="line">            key = &#123;<span class="string">"#.#"</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收到消息："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>@Componet</code>：类上的注解，注册到Spring容器</li>
<li><code>@RabbitListener</code>：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：<ul>
<li><code>bindings</code>：指定绑定关系，可以有多个。值是<code>@QueueBinding</code>的数组。<code>@QueueBinding</code>包含下面属性：<ul>
<li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li>
<li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li>
<li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p>
<h2 id="3-4-AmqpTemplate"><a href="#3-4-AmqpTemplate" class="headerlink" title="3.4.AmqpTemplate"></a>3.4.AmqpTemplate</h2><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p>
<p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1527090258083.png" alt="1527090258083"></p>
<p>红框圈起来的是比较常用的3个方法，分别是：</p>
<ul>
<li>指定交换机、RoutingKey和消息体</li>
<li>指定消息</li>
<li>指定RoutingKey和消息，会向默认的交换机发送消息</li>
</ul>
<h2 id="3-5-测试代码"><a href="#3-5-测试代码" class="headerlink" title="3.5.测试代码"></a>3.5.测试代码</h2><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = Application.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello, Spring boot amqp"</span>;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"spring.test.exchange"</span>,<span class="string">"a.b"</span>, msg);</span><br><span class="line">        <span class="comment">// 等待10秒后再结束</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行后查看日志：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532767726274.png" alt="1532767726274"></p>
<h1 id="3-项目改造"><a href="#3-项目改造" class="headerlink" title="3.项目改造"></a>3.项目改造</h1><p>接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。</p>
<h2 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1.思路分析"></a>3.1.思路分析</h2><blockquote>
<p>发送方：商品微服务</p>
</blockquote>
<ul>
<li><p>什么时候发？</p>
<p>当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。</p>
</li>
<li><p>发送什么内容？</p>
<p>对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们<strong>只发送商品id</strong>，其它服务可以根据id查询自己需要的信息。</p>
</li>
</ul>
<blockquote>
<p>接收方：搜索微服务、静态页微服务</p>
</blockquote>
<p>接收消息后如何处理？</p>
<ul>
<li>搜索微服务：<ul>
<li>增/改：添加新的数据到索引库 </li>
<li>删：删除索引库数据</li>
</ul>
</li>
<li>静态页微服务：<ul>
<li>增/改：创建新的静态页</li>
<li>删：删除原来的静态页</li>
</ul>
</li>
</ul>
<h2 id="3-2-商品服务发送消息"><a href="#3-2-商品服务发送消息" class="headerlink" title="3.2.商品服务发送消息"></a>3.2.商品服务发送消息</h2><p>我们先在商品微服务<code>leyou-item-service</code>中实现发送消息。</p>
<h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1.引入依赖"></a>3.2.1.引入依赖</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-2-2-配置文件"><a href="#3-2-2-配置文件" class="headerlink" title="3.2.2.配置文件"></a>3.2.2.配置文件</h3><p>我们在application.yml中添加一些有关RabbitMQ的配置：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/leyou</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      exchange:</span> <span class="string">leyou.item.exchange</span></span><br><span class="line"><span class="attr">    publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>template：有关<code>AmqpTemplate</code>的配置<ul>
<li>exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个</li>
</ul>
</li>
<li>publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试</li>
</ul>
<h3 id="3-2-3-改造GoodsService"><a href="#3-2-3-改造GoodsService" class="headerlink" title="3.2.3.改造GoodsService"></a>3.2.3.改造GoodsService</h3><p>在GoodsService中封装一个发送消息到mq的方法：<strong>（需要注入AmqpTemplate模板）</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Long id, String type)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"item."</span> + type, id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"&#123;&#125;商品消息发送异常，商品id：&#123;&#125;"</span>, type, id, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里没有指定交换机，因此默认发送到了配置中的：<code>leyou.item.exchange</code></p>
<p><strong>注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑</strong></p>
<p>然后在新增的时候调用：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532768930797.png" alt="1532768930797"></p>
<p>修改的时候调用：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532769005960.png" alt="1532769005960"></p>
<h2 id="3-3-搜索服务接收消息"><a href="#3-3-搜索服务接收消息" class="headerlink" title="3.3.搜索服务接收消息"></a>3.3.搜索服务接收消息</h2><p>搜索服务接收到消息后要做的事情：</p>
<ul>
<li>增：添加新的数据到索引库</li>
<li>删：删除索引库数据</li>
<li>改：修改索引库数据</li>
</ul>
<p>因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。</p>
<h3 id="3-3-1-引入依赖"><a href="#3-3-1-引入依赖" class="headerlink" title="3.3.1.引入依赖"></a>3.3.1.引入依赖</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-2-添加配置"><a href="#3-3-2-添加配置" class="headerlink" title="3.3.2.添加配置"></a>3.3.2.添加配置</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/leyou</span></span><br></pre></td></tr></table></figure></div>
<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-3-3-编写监听器"><a href="#3-3-3-编写监听器" class="headerlink" title="3.3.3.编写监听器"></a>3.3.3.编写监听器</h3><p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532769181819.png" alt="1532769181819"></p>
<p>代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchService searchService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理insert和update的消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"leyou.create.index.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"leyou.item.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = &#123;<span class="string">"item.insert"</span>, <span class="string">"item.update"</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenCreate</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建或更新索引</span></span><br><span class="line">        <span class="keyword">this</span>.searchService.createIndex(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理delete的消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"leyou.delete.index.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"leyou.item.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = <span class="string">"item.delete"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDelete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除索引</span></span><br><span class="line">        <span class="keyword">this</span>.searchService.deleteIndex(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-4-编写创建和删除索引方法"><a href="#3-3-4-编写创建和删除索引方法" class="headerlink" title="3.3.4.编写创建和删除索引方法"></a>3.3.4.编写创建和删除索引方法</h3><p>这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">(Long id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Spu spu = <span class="keyword">this</span>.goodsClient.querySpuById(id);</span><br><span class="line">    <span class="comment">// 构建商品</span></span><br><span class="line">    Goods goods = <span class="keyword">this</span>.buildGoods(spu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存数据到索引库</span></span><br><span class="line">    <span class="keyword">this</span>.goodsRepository.save(goods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.goodsRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>创建索引的方法可以从之前导入数据的测试类中拷贝和改造。</p>
<h2 id="3-4-静态页服务接收消息"><a href="#3-4-静态页服务接收消息" class="headerlink" title="3.4.静态页服务接收消息"></a>3.4.静态页服务接收消息</h2><p>商品静态页服务接收到消息后的处理：</p>
<ul>
<li>增：创建新的静态页</li>
<li>删：删除原来的静态页</li>
<li>改：创建新的静态页并覆盖原来的</li>
</ul>
<p>不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。</p>
<h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-2-添加配置"><a href="#3-4-2-添加配置" class="headerlink" title="3.4.2.添加配置"></a>3.4.2.添加配置</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">leyou</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/leyou</span></span><br></pre></td></tr></table></figure></div>
<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-4-3-编写监听器"><a href="#3-4-3-编写监听器" class="headerlink" title="3.4.3.编写监听器"></a>3.4.3.编写监听器</h3><p> <img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532769581964.png" alt="1532769581964"></p>
<p>代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsHtmlService goodsHtmlService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"leyou.create.web.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"leyou.item.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = &#123;<span class="string">"item.insert"</span>, <span class="string">"item.update"</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenCreate</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建页面</span></span><br><span class="line">        goodsHtmlService.createHtml(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"leyou.delete.web.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"leyou.item.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = <span class="string">"item.delete"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDelete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除页面</span></span><br><span class="line">        goodsHtmlService.deleteHtml(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-4-添加删除页面方法"><a href="#3-4-4-添加删除页面方法" class="headerlink" title="3.4.4.添加删除页面方法"></a>3.4.4.添加删除页面方法</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHtml</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"C:\\project\\nginx-1.14.0\\html\\item\\"</span>, id + <span class="string">".html"</span>);</span><br><span class="line">    file.deleteOnExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5.测试"></a>3.5.测试</h2><h3 id="3-5-1-查看RabbitMQ控制台"><a href="#3-5-1-查看RabbitMQ控制台" class="headerlink" title="3.5.1.查看RabbitMQ控制台"></a>3.5.1.查看RabbitMQ控制台</h3><p>重新启动项目，并且登录RabbitMQ管理界面：<a href="http://192.168.56.101:15672" target="_blank" rel="noopener">http://192.168.56.101:15672</a></p>
<p>可以看到，交换机已经创建出来了：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532772446520.png" alt="1532772446520"></p>
<p>队列也已经创建完毕：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532772471931.png" alt="1532772471931"></p>
<p>并且队列都已经绑定到交换机：</p>
<p><img src="/2019/12/18/消息中间件之RabbitMQ及数据同步/1532772521932.png" alt="1532772521932"></p>
<h3 id="3-5-2-修改数据试一试"><a href="#3-5-2-修改数据试一试" class="headerlink" title="3.5.2.修改数据试一试"></a>3.5.2.修改数据试一试</h3><p>在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/17/深入理解Java虚拟机之破坏双亲委派加载机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/深入理解Java虚拟机之破坏双亲委派加载机制/" itemprop="url">
                  深入理解Java虚拟机之破坏双亲委派加载机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-17 11:35:00" itemprop="dateCreated datePublished" datetime="2019-12-17T11:35:00+08:00">2019-12-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-18 14:25:11" itemprop="dateModified" datetime="2019-12-18T14:25:11+08:00">2019-12-18</time>
              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/17/深入理解Java虚拟机之破坏双亲委派加载机制/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/17/深入理解Java虚拟机之破坏双亲委派加载机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分类加载器都遵循这个原则，但是显然也有例外。</p>
<p>在《深入理解 JVM 虚拟机》一书中，作者提出双亲委派模型目前出现过 3 次较大规模的“被破坏”情况。</p>
<h1 id="1-第一次被破坏"><a href="#1-第一次被破坏" class="headerlink" title="1.第一次被破坏"></a>1.第一次被破坏</h1><p>第一次被破坏其实发生在双亲委派模型出现之前，也就是 JDK 1.2 发布之前，由于双亲委派模型在 JDK 1.2 之后才引入，而类加载器和抽象类 java.lang.ClassLoader 在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者在引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的 loadClass()。双亲委派的具体逻辑就在这个方法之中，JDK 1.2 之后已经不再提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载器逻辑写到 findClass() 方法来完成加载，这样就可以保证写出来的类加载器都是符合双亲委派规则的。</p>
<h1 id="2-第二次被破坏"><a href="#2-第二次被破坏" class="headerlink" title="2.第二次被破坏"></a>2.第二次被破坏</h1><p>第二次被破坏是由于这个模型自身的问题导致的，双亲委派很好地解决了各个类加载器的基础类统一的问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调回用户的代码，那该怎么办？</p>
<p>这不是没有可能的事情，比如 JNDI 服务，JNDI 目前已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊，那可怎么办？</p>
<p>为了解决这个问题，Java 设计团队只好引入另外一个不太优雅的设计：线程上下文加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader()（原文在这里写成 setContextLoaser） 方法进行设置，如果创建线程时还未设置，它将从父线程中继承一个，如果在应用程序的全局范围内没有设置过的话，那么这个类加载器默认就是应用程序类加载器。</p>
<p>通过这个线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载去加载所需要的 SPI 代码，也就是通过父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打破了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情，Java 中所有涉及 SPI 的加载动作都是采用的这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p>
<h1 id="3-第三次被破坏"><a href="#3-第三次被破坏" class="headerlink" title="3.第三次被破坏"></a>3.第三次被破坏</h1><p>第三次被破坏是由于用户对程序动态性追求而导致的，这里所说的“动态性”是指当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设一样，插上鼠标和 U 盘不用重启机器就能立即使用。鼠标有问题就升级或者换个鼠标，不用停机也不用重启。对于实际生产系统来说，关机重启一次可能就要被列为生产事故。因此这种情况下热部署就非常有吸引力。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。当接收到类加载请求时，OSGI 将按照下面的顺序进行类搜索：</p>
<p>1.将以 java.* 开头的类委派给父类加载器加载<br>2.否则，将委派列表名单内的类委派给父类加载器进行加载<br>3.否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载<br>4.否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载<br>5.否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载<br>6.否则，查找 Dynamic Import 列表的 Bundle，委派给对应的 Bundle 的类加载器加载<br>7.否则，类查找失败</p>
<p>上述的查找顺序只有开头两点仍然符合双亲委派模型，其余的类查找都是在平级的类加载器中进行的。</p>
<h1 id="4-破坏双亲委派的原理"><a href="#4-破坏双亲委派的原理" class="headerlink" title="4.破坏双亲委派的原理"></a>4.破坏双亲委派的原理</h1><p>针对书中介绍的三种情况，往往使用最多的是线程上下文类加载器（TCCL，ThreadContextClassLoader）来破坏双亲委派机制。</p>
<div class="note info"><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p><p>这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI 接口中的代码经常需要加载具体的实现类。那么问题来了，SPI 的接口是 Java 核心库的一部分，是由启动类加载器(Bootstrap Classloader)来加载的；SPI 的实现类是由系统类加载器(System ClassLoader)来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader 无法委派 AppClassLoader 来加载类。</p><p>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p></div>
<p>那么我们来以 JDBC 源码来看看是如何破坏双亲委派模型的。 JDBC 也属于 SPI，其 Driver 接口是 Java 核心类库的一部分，但是 Driver 的实现类却是由第三方实现，是需要使用系统类加载器进行加载的，符合上述说的情况。</p>
<h2 id="JDBC-案例分析"><a href="#JDBC-案例分析" class="headerlink" title="JDBC 案例分析"></a>JDBC 案例分析</h2><p>我们先来看平时是如何使用 MySQL 获取数据库连接的：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 加载Class到AppClassLoader（系统类加载器），然后注册驱动类</span><br><span class="line">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;).newInstance(); </span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/testdb&quot;;    </span><br><span class="line">// 通过java库获取数据库连接</span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, &quot;name&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure></div>
<p>以上就是 MySQL 注册驱动及获取 Connection 的过程，各位可以发现经常写的 Class.forName 被注释掉了，但依然可以正常运行，这是为什么呢？这是因为从 JDK 1.6 开始自带的 JDBC 4.0 版本已支持 SPI 服务加载机制，只要 MySQL 的 jar 包在类路径中，就可以注册 MySQL 驱动。</p>
<p>那到底是在哪一步自动注册了 MySQL Driver 的呢？重点就在 DriverManager.getConnection() 方法中。我们都知道调用一个类的静态方法会自动初始化该类（前提是该类还没有被初始化过），进而执行其静态代码块，DriverManager 中的静态代码块如下：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>初始化方法 loadInitialDrivers() 的代码如下：</p>
<p>​<br>    private static void loadInitialDrivers() {<br>        String drivers;<br>        try {<br>            // 先读取系统属性<br>            drivers = AccessController.doPrivileged(new PrivilegedAction<string>() {<br>                public String run() {<br>                    return System.getProperty(“jdbc.drivers”);<br>                }<br>            });<br>        } catch (Exception ex) {<br>            drivers = null;<br>        }<br>        // 通过SPI加载驱动类<br>        AccessController.doPrivileged(new PrivilegedAction<void>() {<br>            public Void run() {<br>                ServiceLoader<driver> loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator<driver> driversIterator = loadedDrivers.iterator();<br>                try{<br>                    while(driversIterator.hasNext()) {<br>                        driversIterator.next();<br>                    }<br>                } catch(Throwable t) {<br>                    // Do nothing<br>                }<br>                return null;<br>            }<br>        });<br>        // 继续加载系统属性中的驱动类<br>        if (drivers == null || drivers.equals(“”)) {<br>            return;<br>        }</driver></driver></void></string></p>
<p>​<br>    String[] driversList = drivers.split(“:”);<br>    println(“number of Drivers:” + driversList.length);<br>    for (String aDriver : driversList) {<br>        try {<br>            println(“DriverManager.Initialize: loading “ + aDriver);<br>            // 使用AppClassloader加载<br>            Class.forName(aDriver, true,<br>                    ClassLoader.getSystemClassLoader());<br>        } catch (Exception ex) {<br>            println(“DriverManager.Initialize: load failed: “ + ex);<br>        }<br>    }<br>}<br>从上面可以看出 JDBC 中的 DriverManager 的加载 Driver 的步骤顺序依次是：</p>
<p>通过 SPI 方式，读取 META-INF/services 下文件中的类名，使用 TCCL（线程上下文类加载器） 加载；<br>通过 System.getProperty(“jdbc.drivers”) 获取设置，然后通过系统类加载器加载。</p>
<p>下面详细分析 SPI 加载的那段代码。</p>
<h2 id="JDBC-中的-SPI"><a href="#JDBC-中的-SPI" class="headerlink" title="JDBC 中的 SPI"></a>JDBC 中的 SPI</h2><p>上面说了那么多 SPI，可能你还没弄懂什么是 SPI，所以先来看看什么是 SPI 机制，引用一段博文中的介绍：</p>
<div class="note info"><p><strong>SPI 机制简介</strong><br>SPI 的全名为 Service Provider Interface，主要是应用于厂商自定义组件或插件中。在java.util.ServiceLoader 的文档里有比较详细的介绍。简单的总结下 java SPI 机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml 解析模块、JDBC 模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 Java SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似 IOC 的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p><p><strong>SPI 具体约定</strong><br>Java SPI 的具体约定为：当服务的提供者提供了服务接口的一种实现之后，在 jar 包的 META-INF/services/ 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该 jar 包 META-INF/services/ 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。JDK 提供服务实现查找的一个工具类：java.util.ServiceLoader。</p></div>
<p>知道 SPI 的机制后，我们来看刚才的代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">    while(driversIterator.hasNext()) &#123;</span><br><span class="line">        driversIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch(Throwable t) &#123;</span><br><span class="line">	// Do nothing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意 driversIterator.next() 最终就是调用 Class.forName(DriverName, false, loader) 方法，也就是最开始我们注释掉的 Class.forName 加载驱动的方法。好，那句因 SPI 而省略的代码现在解释清楚了，那我们继续看给这个方法传的 loader 是怎么来的。</p>
<p>因为这句 Class.forName(DriverName, false, loader) 代码所在的类在 java.util.ServiceLoader 类中，而ServiceLoader.class 又加载在 BootrapLoader 中，因此传给 forName 的 loader 必然不能是 BootrapLoader。这时候只能使用 TCCL 了，也就是说把自己加载不了的类加载到 TCCL 中（通过 Thread.currentThread() 获取，简直作弊啊！）。</p>
<p>可以再看下 ServiceLoader.load(Class) 的代码，发现的确如此：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    return ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>ContextClassLoader 默认存放了 AppClassLoader 的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader 或是 ExtClassLoader 等），在任何需要的时候都可以用 Thread.currentThread().getContextClassLoader() 取出应用程序类加载器来完成需要的操作。</p>
<p>到这儿差不多把 SPI 机制解释清楚了。直白一点说就是，我（JDK）提供了一种帮你（第三方实现者）加载服务（如数据库驱动、日志库）的便捷方式，只要你遵循约定（把类名写在 /META-INF 里），那当我启动时我会去扫描所有 jar 包里符合约定的类名，再调用 forName 加载，但我的 ClassLoader 是没法加载的，那就把它加载到当前执行线程的 TCCL 里，后续你想怎么操作（驱动实现类的 static 代码块）就是你的事了。</p>
<p>好，刚才说的驱动实现类就是 com.mysql.jdbc.Driver，它的静态代码块里头又写了什么呢？是否又用到了 TCCL 呢？我们继续看下一个例子。</p>
<h2 id="校验实例的归属"><a href="#校验实例的归属" class="headerlink" title="校验实例的归属"></a>校验实例的归属</h2><p>com.mysql.jdbc.Driver 加载后运行的静态代码块:</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// Driver已经加载到TCCL中了，此时可以直接实例化</span><br><span class="line">		java.sql.DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span><br><span class="line">	&#125; catch (SQLException E) &#123;</span><br><span class="line">		throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>registerDriver 方法将 driver 实例注册到系统的 java.sql.DriverManager 类中，其实就是 add 到它的一个名为 registeredDrivers 的静态成员 CopyOnWriteArrayList 中 。</p>
<p>到此驱动注册基本完成，接下来我们回到最开始的那段样例代码：java.sql.DriverManager.getConnection()。它最终调用了以下方法：</p>
<pre><code> private static Connection getConnection(
     String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {
     /* 传入的caller由Reflection.getCallerClass()得到，该方法
      * 可获取到调用本方法的Class类，这儿获取到的是当前应用的类加载器
      */
     ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
     synchronized(DriverManager.class) {
         if (callerCL == null) {
             callerCL = Thread.currentThread().getContextClassLoader();
         }
     }
</code></pre><p>​<br>     if(url == null) {<br>         throw new SQLException(“The url cannot be null”, “08001”);<br>     }</p>
<pre><code> SQLException reason = null;
 // 遍历注册到registeredDrivers里的Driver类
 for(DriverInfo aDriver : registeredDrivers) {
     // 检查Driver类有效性
     if(isDriverAllowed(aDriver.driver, callerCL)) {
         try {
             println(&quot;    trying &quot; + aDriver.driver.getClass().getName());
             // 调用com.mysql.jdbc.Driver.connect方法获取连接
             Connection con = aDriver.driver.connect(url, info);
             if (con != null) {
                 // Success!
                 return (con);
             }
         } catch (SQLException ex) {
             if (reason == null) {
                 reason = ex;
             }
         }

     } else {
         println(&quot;    skipping: &quot; + aDriver.getClass().getName());
     }

 }
 throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);

}




private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {
    boolean result = false;
    if(driver != null) {
        Class&lt;?&gt; aClass = null;
        try {
        // 传入的classLoader为调用getConnetction的当前类加载器，从中寻找driver的class对象
            aClass =  Class.forName(driver.getClass().getName(), true, classLoader);
        } catch (Exception ex) {
            result = false;
        }
    // 注意，只有同一个类加载器中的Class使用==比较时才会相等，此处就是校验用户注册Driver时该Driver所属的类加载器与调用时的是否同一个
    // driver.getClass()拿到就是当初执行Class.forName(&quot;com.mysql.jdbc.Driver&quot;)时的应用AppClassLoader
        result = ( aClass == driver.getClass() ) ? true : false;
    }

    return result;
}
</code></pre><p>由于 TCCL 本质就是当前应用类加载器，所以之前的初始化就是加载在当前的类加载器中，这一步就是校验存放的 driver 是否属于调用者的 Classloader。例如在下文中的 Tomcat 里，多个 webapp 都有自己的 Classloader，如果它们都自带 mysql-connect.jar 包，那底层 Classloader 的 DriverManager 里将注册多个不同类加载器的 Driver 实例，想要区分只能靠 TCCL 了。</p>
<h1 id="Tomcat与Spring的类加载案例"><a href="#Tomcat与Spring的类加载案例" class="headerlink" title="Tomcat与Spring的类加载案例"></a>Tomcat与Spring的类加载案例</h1><h2 id="Tomcat-中的类加载器"><a href="#Tomcat-中的类加载器" class="headerlink" title="Tomcat 中的类加载器"></a>Tomcat 中的类加载器</h2><p>在 Tomcat 目录结构中，有三组目录（/common/<em>,/server/</em>和shared/<em>）可以存放公用 Java 类库，此外还有第四组 Web 应用程序自身的目录 /WEB-INF/</em> ，把 Java 类库放置在这些目录中的含义分别是：</p>
<p>放置在 common 目录中：类库可被 Tomcat 和所有的 Web 应用程序共同使用。<br>放置在 server 目录中：类库可被 Tomcat 使用，但对所有的 Web 应用程序都不可见。<br>放置在 shared 目录中：类库可被所有的 Web 应用程序共同使用，但对 Tomcat 自己不可见。<br>放置在 /WebApp/WEB-INF 目录中：类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 应用程序都不可见。<br>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat 自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，如下图所示：</p>
<p> <img src="/2019/12/17/深入理解Java虚拟机之破坏双亲委派加载机制/1240" alt="image.png"> </p>
<p>灰色背景的 3 个类加载器是 JDK 默认提供的类加载器，这 3 个加载器的作用前面已经介绍过了。而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebAppClassLoader 则是 Tomcat 自己定义的类加载器，它们分别加载 /common/<em>、/server/</em>、/shared/<em> 和 /WebApp/WEB-INF/</em> 中的 Java 类库。其中 WebApp 类加载器和 JSP 类加载器通常会存在多个实例，每一个 Web 应用程序对应一个 WebApp 类加载器，每一个 JSP 文件对应一个 JSP 类加载器。</p>
<p>从图中的委派关系中可以看出，CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 自己能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。而 JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class，它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 JSP 类加载器来实现 JSP 文件的 HotSwap 功能。</p>
<h2 id="Spring-加载问题"><a href="#Spring-加载问题" class="headerlink" title="Spring 加载问题"></a>Spring 加载问题</h2><p>Tomcat 加载器的实现清晰易懂，并且采用了官方推荐的“正统”的使用类加载器的方式。这时作者提一个问题：如果有 10 个 Web 应用程序都用到了 Spring 的话，可以把 Spring 的 jar 包放到 common 或 shared 目录下让这些程序共享。Spring 的作用是管理每个 web 应用程序的 bean， getBean 时自然要能访问到应用程序的类，而用户的程序显然是放在/WebApp/WEB-INF 目录中的（由 WebAppClassLoader 加载），那么在 CommonClassLoader 或 SharedClassLoader 中的 Spring 容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的 Class 呢？</p>
<p>实际上，Spring 根本不会去管自己被放在哪里，它统统使用 TCCL 来加载类，而 TCCL 默认设置为了 WebAppClassLoader，也就是说哪个 WebApp 应用调用了 Spring，Spring 就去取该应用自己的 WebAppClassLoader 来加载 bean，简直完美~</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>有兴趣的可以接着看看具体实现：</p>
<p>在 web.xml 中定义的 listener 为 org.springframework.web.context.ContextLoaderListener，它最终调用了 org.springframework.web.context.ContextLoader 类来装载 bean，具体方法如下（删去了部分不相关内容）：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 创建WebApplicationContext</span><br><span class="line">		if (this.context == null) &#123;</span><br><span class="line">			this.context = createWebApplicationContext(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		// 将其保存到该webapp的servletContext中		</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line">		// 获取线程上下文类加载器，默认为WebAppClassLoader</span><br><span class="line">		ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		// 如果spring的jar包放在每个webapp自己的目录中</span><br><span class="line">		// 此时线程上下文类加载器会与本类的类加载器（加载spring的）相同，都是WebAppClassLoader</span><br><span class="line">		if (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">			currentContext = this.context;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (ccl != null) &#123;</span><br><span class="line">			// 如果不同，也就是上面说的那个问题的情况，那么用一个map把刚才创建的WebApplicationContext及对应的WebAppClassLoader存下来</span><br><span class="line">			// 一个webapp对应一个记录，后续调用时直接根据WebAppClassLoader来取出</span><br><span class="line">			currentContextPerThread.put(ccl, this.context);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return this.context;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (RuntimeException ex) &#123;</span><br><span class="line">		logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Error err) &#123;</span><br><span class="line">		logger.error(&quot;Context initialization failed&quot;, err);</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体说明都在注释中，Spring 考虑到了自己可能被放到其他位置，所以直接用 TCCL 来解决所有可能面临的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的两个案例分析，我们可以总结出线程上下文类加载器的适用场景：</p>
<p>当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。<br>当使用本类托管类加载，然而加载本类的 ClassLoader 未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>真正理解线程上下文类加载器（多案例分析）<br>JVM双亲委派机制与Tomcat</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://enfangzhong.github.io/2019/12/12/Spring Cloud快速开发入门第02篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnFrank">
      <meta itemprop="description" content="你若晴天，我便安好。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnFrank's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/12/Spring Cloud快速开发入门第02篇/" itemprop="url">
                  Spring Cloud快速开发入门第02篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-12 00:03:11" itemprop="dateCreated datePublished" datetime="2019-12-12T00:03:11+08:00">2019-12-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-29 05:02:09" itemprop="dateModified" datetime="2019-12-29T05:02:09+08:00">2019-12-29</time>
              
            
          </span>


          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Spring-Cloud/微服务/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/12/Spring Cloud快速开发入门第02篇/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/12/12/Spring Cloud快速开发入门第02篇/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>会配置Hystix熔断</li>
<li>会使用Feign进行远程调用</li>
<li>能独立搭建Zuul网关</li>
<li>能编写Zuul的过滤器</li>
</ul>
<h1 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1.Hystrix"></a>1.Hystrix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>Hystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。</p>
<p>Hystrix也是Netflix公司的一款组件。</p>
<p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525658740266.png" alt="1525658740266"></p>
<p>那么Hystix的作用是什么呢？具体要保护什么呢？</p>
<p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p>
<h2 id="1-2-雪崩问题"><a href="#1-2-雪崩问题" class="headerlink" title="1.2.雪崩问题"></a>1.2.雪崩问题</h2><p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1533829099748.png" alt="1533829099748"></p>
<p>如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。</p>
<p>如果此时，某个服务出现异常：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1533829198240.png" alt="1533829198240"></p>
<p>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1533829307389.png" alt="1533829307389"></p>
<p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。</p>
<p>这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 </p>
<p>Hystix解决雪崩问题的手段有两个：</p>
<ul>
<li>线程隔离</li>
<li>服务熔断</li>
</ul>
<h2 id="1-3-线程隔离，服务降级"><a href="#1-3-线程隔离，服务降级" class="headerlink" title="1.3.线程隔离，服务降级"></a>1.3.线程隔离，服务降级</h2><h3 id="1-3-1-原理"><a href="#1-3-1-原理" class="headerlink" title="1.3.1.原理"></a>1.3.1.原理</h3><p>线程隔离示意图：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1533829598310.png" alt="1533829598310"></p>
<p>解读：</p>
<p>Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</p>
<p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果<strong>线程池已满</strong>，或者<strong>请求超时</strong>，则会进行降级处理，什么是服务降级？</p>
<blockquote>
<p>服务降级：优先保证核心服务，而非核心服务不可用或弱可用。</p>
</blockquote>
<p>用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。</p>
<p>服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。</p>
<p>触发Hystix服务降级的情况：</p>
<ul>
<li>线程池已满</li>
<li>请求超时</li>
</ul>
<h3 id="1-3-2-动手实践"><a href="#1-3-2-动手实践" class="headerlink" title="1.3.2.动手实践"></a>1.3.2.动手实践</h3><h4 id="1-3-2-1-引入依赖"><a href="#1-3-2-1-引入依赖" class="headerlink" title="1.3.2.1.引入依赖"></a>1.3.2.1.引入依赖</h4><p>首先在itcast-service-consumer的pom.xml中引入Hystrix依赖：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="1-3-2-2-开启熔断"><a href="#1-3-2-2-开启熔断" class="headerlink" title="1.3.2.2.开启熔断"></a>1.3.2.2.开启熔断</h4><p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535341341482.png" alt="1535341341482"></p>
<p>可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535341390087.png" alt="1535341390087"></p>
<p>因此，我们可以使用这个组合注解来代替之前的3个注解。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="1-3-2-3-编写降级逻辑"><a href="#1-3-2-3-编写降级逻辑" class="headerlink" title="1.3.2.3.编写降级逻辑"></a>1.3.2.3.编写降级逻辑</h4><p>我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"queryUserByIdFallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserByIdFallBack</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"请求繁忙，请稍后再试！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：<strong>相同的参数列表和返回值声明</strong>。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。</p>
<p>说明：</p>
<ul>
<li>@HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法</li>
</ul>
<p>测试：</p>
<p>当itcast-service-provder正常提供服务时，访问与以前一致。但是当我们将itcast-service-provider停机时，会发现页面返回了降级处理信息：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535852634763.png" alt="1535852634763"></p>
<h4 id="1-3-2-4-默认FallBack"><a href="#1-3-2-4-默认FallBack" class="headerlink" title="1.3.2.4.默认FallBack"></a>1.3.2.4.默认FallBack</h4><p>我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"fallBackMethod"</span>) <span class="comment">// 指定一个类的全局熔断方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span> <span class="comment">// 标记该方法需要熔断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 熔断方法</span></span><br><span class="line"><span class="comment">     * 返回值要和被熔断的方法的返回值一致</span></span><br><span class="line"><span class="comment">     * 熔断方法不需要参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallBackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"请求繁忙，请稍后再试！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>@DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的失败降级方法</li>
<li>@HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法。</li>
<li>defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致</li>
</ul>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535852634763.png" alt="1535852634763"></p>
<h4 id="1-3-2-5-设置超时"><a href="#1-3-2-5-设置超时" class="headerlink" title="1.3.2.5.设置超时"></a>1.3.2.5.设置超时</h4><p>在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：</p>
<p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。该配置没有提示。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure></div>
<p><strong>改造服务提供者</strong></p>
<p>改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="1-4-服务熔断"><a href="#1-4-服务熔断" class="headerlink" title="1.4.服务熔断"></a>1.4.服务熔断</h2><h3 id="1-4-1-熔断原理"><a href="#1-4-1-熔断原理" class="headerlink" title="1.4.1.熔断原理"></a>1.4.1.熔断原理</h3><p>熔断器，也叫断路器，其英文单词为：Circuit Breaker </p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525658640314.png" alt="1525658640314"></p>
<p>熔断状态机3个状态：</p>
<ul>
<li>Closed：关闭状态，所有请求都正常访问。</li>
<li>Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。</li>
<li>Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时</li>
</ul>
<h3 id="1-4-2-动手实践"><a href="#1-4-2-动手实践" class="headerlink" title="1.4.2.动手实践"></a>1.4.2.动手实践</h3><p>为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"太忙了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String.class);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑）</p>
<p>我们准备两个请求窗口：</p>
<ul>
<li>一个请求：<a href="http://localhost/consumer/user/1，注定失败" target="_blank" rel="noopener">http://localhost/consumer/user/1，注定失败</a></li>
<li>一个请求：<a href="http://localhost/consumer/user/2，肯定成功" target="_blank" rel="noopener">http://localhost/consumer/user/2，肯定成功</a></li>
</ul>
<p>当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。</p>
<p>此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1543053265477.png" alt="1543053265477"></p>
<p>不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">circuitBreaker.requestVolumeThreshold=10</span><br><span class="line">circuitBreaker.sleepWindowInMilliseconds=10000</span><br><span class="line">circuitBreaker.errorThresholdPercentage=50</span><br></pre></td></tr></table></figure></div>
<p>解读：</p>
<ul>
<li>requestVolumeThreshold：触发熔断的最小请求次数，默认20</li>
<li>errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%</li>
<li>sleepWindowInMilliseconds：休眠时长，默认是5000毫秒</li>
</ul>
<h1 id="2-Feign"><a href="#2-Feign" class="headerlink" title="2.Feign"></a>2.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String.class);</span><br></pre></td></tr></table></figure></div>
<p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p>
<p>这就是我们接下来要学的Feign的功能了。</p>
<h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h2><p>有道词典的英文解释：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1528855057359.png" alt="1528855057359"></p>
<p>为什么叫伪装？</p>
<p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p>
<p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525652009416.png" alt="1525652009416"></p>
<h2 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2.快速入门"></a>2.2.快速入门</h2><p>改造itcast-service-consumer工程</p>
<h3 id="2-2-1-导入依赖"><a href="#2-2-1-导入依赖" class="headerlink" title="2.2.1.导入依赖"></a>2.2.1.导入依赖</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-2-开启Feign功能"><a href="#2-2-2-开启Feign功能" class="headerlink" title="2.2.2.开启Feign功能"></a>2.2.2.开启Feign功能</h3><p>我们在启动类上，<strong>添加注解</strong>，开启Feign功能</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启feign客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>删除RestTemplate</strong>：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。</p>
<h3 id="2-2-3-Feign的客户端"><a href="#2-2-3-Feign的客户端" class="headerlink" title="2.2.3.Feign的客户端"></a>2.2.3.Feign的客户端</h3><p>在itcast-service-consumer工程中，添加UserClient接口：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1540683659305.png" alt="1540683659305"></p>
<p>内容：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-provider"</span>) <span class="comment">// 标注该类是一个feign接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li>
<li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li>
<li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li>
</ul>
<p>改造原来的调用逻辑，调用UserClient接口：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userClient.queryUserById(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-4-启动测试"><a href="#2-2-4-启动测试" class="headerlink" title="2.2.4.启动测试"></a>2.2.4.启动测试</h3><p>访问接口： </p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535346290987.png" alt="1535346290987"></p>
<p>正常获取到了结果。</p>
<h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3.负载均衡"></a>2.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1528859608579.png" alt="1528859608579"></p>
<p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p>
<h2 id="2-4-Hystrix支持"><a href="#2-4-Hystrix支持" class="headerlink" title="2.4.Hystrix支持"></a>2.4.Hystrix支持</h2><p>Feign默认也有对Hystrix的集成：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1528861288636.png" alt="1528861288636"></p>
<p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在itcast-service-consumer工程添加配置内容)</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure></div>
<p>但是，Feign中的Fallback配置不像hystrix中那样简单了。</p>
<p>1）首先，我们要定义一个类UserClientFallback，实现刚才编写的UserClient，作为fallback的处理类</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1540683742479.png" alt="1540683742479"></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallback</span> <span class="keyword">implements</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"服务器繁忙，请稍后再试！"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2）然后在UserFeignClient中，指定刚才编写的实现类</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-provider"</span>, fallback = UserClientFallback.class) <span class="comment">// 标注该类是一个feign接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3）重启测试：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1535346896313.png" alt="1535346896313"></p>
<h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5.请求压缩(了解)"></a>2.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启响应压缩</span></span><br></pre></td></tr></table></figure></div>
<p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line"><span class="attr">      mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br></pre></td></tr></table></figure></div>
<p>注：上面的数据类型、压缩大小下限均为默认值。</p>
<h2 id="2-6-日志级别-了解"><a href="#2-6-日志级别-了解" class="headerlink" title="2.6.日志级别(了解)"></a>2.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p>
<p>1）设置com.leyou包下的日志级别都为debug</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">cn.itcast:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></div>
<p>2）编写配置类，定义日志级别</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529113196740.png" alt="1529113196740"></p>
<p>内容：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignLogConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里指定的Level级别是FULL，Feign支持4种级别：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1528863525224.png" alt="1528863525224"></p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p>3）在FeignClient中指定配置类：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-privider"</span>, fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4）重启项目，即可看到每次访问的日志：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1528863489923.png" alt="1528863489923"></p>
<h1 id="3-Zuul网关"><a href="#3-Zuul网关" class="headerlink" title="3.Zuul网关"></a>3.Zuul网关</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525674644660.png" alt="1525674644660"></p>
<p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p>
<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p>
<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>
<ul>
<li><p>破坏了服务无状态特点。</p>
<pre><code>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。
</code></pre><p> 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</p>
</li>
<li><p>无法直接复用既有接口。</p>
<pre><code>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。
</code></pre></li>
</ul>
<p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p>
<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p>
<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备<code>服务路由</code>、<code>均衡负载</code>功能之外，它还具备了<code>权限控制</code>等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525675037152.png" alt=""></p>
<p>Zuul：维基百科</p>
<p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p>
<p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525675168152.png" alt="1525675168152"></p>
<h2 id="3-2-Zuul加入后的架构"><a href="#3-2-Zuul加入后的架构" class="headerlink" title="3.2.Zuul加入后的架构"></a>3.2.Zuul加入后的架构</h2><p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525675648881.png" alt="1525675648881"></p>
<p>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</p>
<h2 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3.快速入门"></a>3.3.快速入门</h2><h3 id="3-3-1-新建工程"><a href="#3-3-1-新建工程" class="headerlink" title="3.3.1.新建工程"></a>3.3.1.新建工程</h3><p>填写基本信息：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529112749084.png" alt="1529112749084"></p>
<p>添加Zuul依赖：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529112691169.png" alt="1529112691169"></p>
<h3 id="3-3-2-编写配置"><a href="#3-3-2-编写配置" class="headerlink" title="3.3.2.编写配置"></a>3.3.2.编写配置</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-3-编写引导类"><a href="#3-3-3-编写引导类" class="headerlink" title="3.3.3.编写引导类"></a>3.3.3.编写引导类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启网关功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-4-编写路由规则"><a href="#3-3-4-编写路由规则" class="headerlink" title="3.3.4.编写路由规则"></a>3.3.4.编写路由规则</h3><p>我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1542672192226.png" alt="1542672192226"></p>
<ul>
<li>ip为：127.0.0.1</li>
<li>端口为：8081</li>
</ul>
<p>映射规则：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    service-provider:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://127.0.0.1:8081</span> <span class="comment"># 映射路径对应的实际url地址</span></span><br></pre></td></tr></table></figure></div>
<p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p>
<p>本例中，我们将 <code>/service-provider/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p>
<h3 id="3-3-5-启动测试"><a href="#3-3-5-启动测试" class="headerlink" title="3.3.5.启动测试"></a>3.3.5.启动测试</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:10010/service-provider/user/1" target="_blank" rel="noopener">http://127.0.0.1:10010/service-provider/user/1</a></p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1543054030005.png" alt="1543054030005"></p>
<h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4.面向服务的路由"></a>3.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p>
<p>对itcast-zuul工程修改优化：</p>
<h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1.添加Eureka客户端依赖"></a>3.4.1.添加Eureka客户端依赖</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-2-添加Eureka配置，获取服务信息"><a href="#3-4-2-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.2.添加Eureka配置，获取服务信息"></a>3.4.2.添加Eureka配置，获取服务信息</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-3-开启Eureka客户端发现功能"><a href="#3-4-3-开启Eureka客户端发现功能" class="headerlink" title="3.4.3.开启Eureka客户端发现功能"></a>3.4.3.开启Eureka客户端发现功能</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ZuulDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4.修改映射配置，通过服务名称获取"></a>3.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    service-provider:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">service-provider</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5.启动测试"></a>3.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1543054030005.png" alt="1543054030005"></p>
<h2 id="3-5-简化的路由配置"><a href="#3-5-简化的路由配置" class="headerlink" title="3.5.简化的路由配置"></a>3.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li>
<li><code>zuul.routes.&lt;route&gt;.serviceId=service-provider</code>：来指定服务名。</li>
</ul>
<p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p>
<p>比方说上面我们关于service-provider的配置可以简化为一条：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    service-provider:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure></div>
<p>省去了对服务名称的配置。</p>
<h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6.默认的路由规则"></a>3.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p>
<ul>
<li>默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：<code>service-provider</code>，则默认的映射路径就    是：<code>/service-provider/**</code></li>
</ul>
<p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p>
<h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7.路由前缀"></a>3.7.路由前缀</h2><p>配置示例：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    service-provider:</span> <span class="string">/service-provider/**</span></span><br><span class="line"><span class="attr">    service-consumer:</span> <span class="string">/service-consumer/**</span></span><br><span class="line"><span class="attr">  prefix:</span> <span class="string">/api</span> <span class="comment"># 添加路由前缀</span></span><br></pre></td></tr></table></figure></div>
<p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1543054221479.png" alt="1543054221479"></p>
<h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8.过滤器"></a>3.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p>
<h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1.ZuulFilter"></a>3.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;<span class="comment">// 来自IZuulFilter</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException</span>;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li>
<li><code>run</code>：过滤器的具体业务逻辑。</li>
<li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul>
<li><code>pre</code>：请求在被路由之前执行</li>
<li><code>route</code>：在路由请求时调用</li>
<li><code>post</code>：在route和errror过滤器之后调用</li>
<li><code>error</code>：处理请求时发生错误调用</li>
</ul>
</li>
<li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li>
</ul>
<h3 id="3-8-2-过滤器执行生命周期"><a href="#3-8-2-过滤器执行生命周期" class="headerlink" title="3.8.2.过滤器执行生命周期"></a>3.8.2.过滤器执行生命周期</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529152248172.png" alt="1529152248172"></p>
<p>正常流程：</p>
<ul>
<li>请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li>
</ul>
<p>异常流程：</p>
<ul>
<li>整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li>
<li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。</li>
<li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。</li>
</ul>
<p>所有内置过滤器列表：</p>
<p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1525682427811.png" alt=""></p>
<h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3.使用场景"></a>3.8.3.使用场景</h3><p>场景非常多：</p>
<ul>
<li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li>
<li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li>
<li>服务调用时长统计：pre和post结合使用。</li>
</ul>
<h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9.自定义过滤器"></a>3.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p>
<h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1.定义过滤器类"></a>3.9.1.定义过滤器类</h3><p> <img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529136926454.png" alt="1529136926454"></p>
<p>内容：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器类型，前置过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的执行顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器是否生效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆校验逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取zuul提供的上下文对象</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 从上下文对象中获取请求对象</span></span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        <span class="comment">// 获取token信息</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"access-token"</span>);</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 过滤该请求，不对其进行路由</span></span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置响应状态码，401</span></span><br><span class="line">            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="comment">// 设置响应信息</span></span><br><span class="line">            context.setResponseBody(<span class="string">"&#123;\"status\":\"401\", \"text\":\"request error!\"&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验通过，把登陆信息放入上下文信息，继续向后执行</span></span><br><span class="line">        context.set(<span class="string">"token"</span>, token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2.测试"></a>3.9.2.测试</h3><p>没有token参数时，访问失败：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529161460740.png" alt="1529161460740"></p>
<p>添加token参数后：</p>
<p><img src="/2019/12/12/Spring Cloud快速开发入门第02篇/1529161252733.png" alt="1529161252733"></p>
<h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">2000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure></div>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>



  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="AnFrank">
            
              <p class="site-author-name" itemprop="name">AnFrank</p>
              <p class="site-description motion-element" itemprop="description">你若晴天，我便安好。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/enfangzhong" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/qintian888" target="_blank" title="CSDN"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/5604852325" target="_blank" title="weibo"><i class="fa fa-fw fa-weibo"></i>weibo</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/anfrankit" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.facebook.com/enfangzhong" target="_blank" title="FB Page"><i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:enfangzhong@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lruihao.cn/" title="博采众长" target="_blank">博采众长</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.leridy.pw/" title="乐余地" target="_blank">乐余地</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://tmy123.com/" title="同盟源" target="_blank">同盟源</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yremp.live" title="Yremp" target="_blank">Yremp</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          <marquee>
	<a href="/links">
	<font size="4" face="STXingkai">
		<font color="#FF0000">欢</font>
		<font color="#E80017">迎</font>
		<font color="#D1002E">点</font>
		<font color="#BA0045">我</font>
		<font color="#A3005C">互</font>
		<font color="#A00073">换</font>
		<font color="#A0008A">友</font>
		<font color="#A000A1">链</font>
		<font color="#A000B8">哦</font>
		<font color="#A000CF">~</font>
		<font color="#A000E6">~</font>
	</font>
	</a>
</marquee>

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      


      

<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java虚拟机/">Java虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java编程思想/">java编程思想</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq/">rabbitmq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/写作标签/">写作标签</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标签云/">标签云</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息中间件/">消息中间件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入理解Java虚拟机/">深入理解Java虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/秋招/">秋招</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义友链页面/">自定义友链页面</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音乐播放器/">音乐播放器</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
    </div>
</div>




  <!-- canvas粒子时钟 -->
  
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>





    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AnFrank</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://github.com/enfangzhong">GitHub</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>


<!--
  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>
-->


  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://github.com/enfangzhong">Enfang</a> v6.3.0</div>





<font color="MediumPurple" face="STLiti">
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共154.1k字|</span>
</div>
</font>

<font color="MediumPurple" face="STLiti"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></font>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("05/28/2018 20:01:01");//此处为建站时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "我在此等候你："+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>


<div class="weixin-box">
  <div class="weixin-menu">
    <div class="weixin-hover">
      <div class="weixin-description">微信扫一扫，联系博主</div>
    </div>
  </div>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      我的第<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>位朋友
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      经历<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次回眸才与你相遇
    </span>
  
</div>









        
      </div>
    </footer>

    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>
  // <script src="/js/src/valine1.3.4.js"></script>

  <!-- https://deserts.io/diy-a-comment-system/ -->
  <script type="text/javascript">
    new Valine({
        lang: 'zh-cn',
        admin_email: '944727327@qq.com', //博主邮箱
        el: '#comments' ,
        appId: 'SACSC0biGE5t01ErmVSxYvVt-gzGzoHsz',
        appKey: 'td1GAOLqHNMnQ4BtJENstUVW',
        emoticon_url: 'https://cloud.panjunwen.com/alu',
        emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!填写邮箱能很快收到我的回复喔！老铁，你不想说两句吗？',
  });


  // if(window.location.hash){
  //       var checkExist = setInterval(function() {
  //          if ($(window.location.hash).length) {
  //             $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
  //             clearInterval(checkExist);
  //          }
  //       }, 100);
  //   }

  </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>



  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


<!--知乎卡片链接-->
<script type="text/javascript" src="/js/src/linkcard.js"></script>

</body>
</html>
